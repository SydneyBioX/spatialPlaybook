# Finding associations between clinical variables and spatial features

```{r code chunk timing, include = FALSE}
knitr::knit_hooks$set(time_it = local({
  now <- NULL
  function(before, options) {
    if (before) {
      # record the current time before each chunk
      now <<- Sys.time()
    } else {
      # calculate the time difference after a chunk
      res <- difftime(Sys.time(), now, units = "secs")
      # return a character string to show the time
      paste("Time for this code chunk to run with ", nCores, " cores: ", round(res, 2), " seconds")
    }
  }
}))
```

When it comes to biological datasets, the end goal is either mechanistic or translational. For example, if we had a mechanistic end goal, we might want to find what genes are differentially expressed between two conditions, and further aim to characterise the pathways which lead to this differential expression. Alternatively, if the end goal is translational, we might want to use a biological dataset that can be relatively cheaply obtained (e.g. IMC) to predict whether a patient's disease will progress or not progress (e.g. metastasize in cancer).

<!-- Steps: -->

<!-- 1.  Introduction to ClassifyR -->

<!-- 2.  Classification of patients by condition -->

<!-- 3.  Classification of patients by survival -->

<!-- 4.  Easy and Hard to classify patients (samplesMetricMap) -->

<!-- 5.  Maximising accuracy during classification (parameter tuning for crossValidate) -->

```{r load libraries, echo=FALSE, results="hide", warning=FALSE}
suppressPackageStartupMessages({
  library(ClassifyR)
  library(lisaClust)
  library(Statial)
  library(spicyR)
  library(ggplot2)
})
```

```{r libraries, eval = FALSE}
library(ClassifyR)
library(lisaClust)
library(Statial)
library(spicyR)
library(ggplot2)
```

```{r set parameters}
# set parameters
set.seed(51773)
use_mc <- TRUE
if (use_mc) {
  nCores <- max(parallel::detectCores()/2, 1)
} else {
  nCores <- 1
}
BPPARAM <- simpleSeg:::generateBPParam(nCores)
theme_set(theme_classic())
```

## Introduction to `ClassifyR`

[ClassifyR](https://www.bioconductor.org/packages/release/bioc/html/ClassifyR.html) provides a structured pipeline for cross-validated classification. Classification is viewed in terms of four stages: data transformation, feature selection, classifier training, and prediction. The driver functions `crossValidate` and `runTests` implements varieties of cross-validation. They are:

-   Permutation of the order of samples followed by k-fold cross-validation
-   Repeated $x\%$ test set cross-validation
-   leave-k-out cross-validation

We will use the Keren 2018 dataset to perform two predictions: 1) predict the patient's tumour type (compartmentalised or mixed) and 2) predict the patient's survival outcome.

```{r load keren dataset, message=FALSE,warning=FALSE}
# load the Keren 2018 dataset
kerenSPE <- SpatialDatasets::spe_Keren_2018()

# remove any missing data in our outcome columns
kerenSPE = kerenSPE[, complete.cases(colData(kerenSPE)[, c("Censored", "Survival_days_capped*",
                                                           "tumour_type")])]

# read in pre-saved results from Kontextual and SpatioMark
kontextMat <- readRDS("data/kontextMat.rds")
stateMat <- readRDS("data/stateMat.rds")
```

## Classification of patients by condition

We will use the Keren 2018 dataset to classify a patient's tumour into one of two types: compartmentalised and mixed. First, we will filter out all cases which had cold tumours, as there are only 5 of them.

```{r filter out cold tumours}
# filter out cold tumours
kerenSPE = kerenSPE[, colData(kerenSPE)$tumour_type != "cold"]
kerenSPE$tumour_type = droplevels(kerenSPE$tumour_type)
levels(kerenSPE$tumour_type) = c("mixed", "compartmentalised")


kontextMat = kontextMat[rownames(kontextMat) %in% unique(kerenSPE$imageID), ]
stateMat = stateMat[rownames(stateMat) %in% unique(kerenSPE$imageID), ]
```

We will build a list of feature matrices using the features we've generated in the previous chapters:

1.  Cell type proportions (FuseSOM)
2.  Co-localisation between pairs of cell types using the L-function (spicyR)
3.  Cell type co-localisation with respect to a parent population using `Kontextual` (Statial)
4.  Regions of co-localisation, or spatial domains (lisaClust)
5.  Marker means in each cell type (Statial)
6.  Marker means in each cell type in each region (Statial)
7.  Proximity-associated changes in marker expression using SpatioMark (Statial)

```{r create feature matrix, time_it = TRUE}
data <- list()

# Cell type proportions (FuseSOM)
data[["proportions"]] <- getProp(kerenSPE, "cellType")

# Cell localisation (spicyR)
data[["spicyR"]] <- getPairwise(kerenSPE,
                                BPPARAM = BPPARAM) |> as.data.frame()

# Cell localisation with respect to a parent (Kontextual)
data[["Kontextual"]] <- kontextMat

# Spatial Domains (lisaClust)
data[["lisaClust"]] <- getProp(lisaClust(kerenSPE, k = 5,
                                         BPPARAM = BPPARAM), "region")

# Marker means in each cell type (Statial)
data[["cellTypeMarkerMeans"]] <- getMarkerMeans(kerenSPE, imageID = "imageID",
                                        cellType = "cellType",
                                        region = "cellType")

# Marker means in each cell type in each region (Statial)
data[["regionMarkerMeans"]] <- getMarkerMeans(lisaClust(kerenSPE, k = 5,
                                                        BPPARAM = BPPARAM), 
                                        imageID = "imageID",
                                        cellType = "cellType",
                                        region = "region")

# Proximity-associated changes in marker expression (SpatioMark)
data[["SpatioMark"]] <- stateMat
```

We will then generate a factor vector of our outcome variable.

```{r outcome vector}
# outcome vector
outcome = kerenSPE$tumour_type[!duplicated(kerenSPE$imageID)]
names(outcome) = kerenSPE$imageID[!duplicated(kerenSPE$imageID)]

head(outcome, 5)
```

`ClassifyR` provides a convenient function, `crossValidate`, to build and test models. `crossValidate` must be supplied with `measurements`, a simple tabular data container or a list-like structure of such related tabular data on common samples. It can be in the form of a `matrix`, `data.frame`, `DataFrame`, `MultiAssayExperiment` or a list of `data.frames`.

`crossValidate` must also be supplied with `outcome`, which represents the prediction to be made. `outcome` can be either a factor containing the class labels for each observation, or a `character` of length 1 that matches a column name in `measurements` which holds the classes. If a `character` is provided, `crossValidate` will automatically remove the classes before training.

By default, `crossValidate` will build and train a random forest. Alternative classifiers can be specified using the `classifier` argument. To view all available feature selection and classification approaches, use the `available` function.

```{r cv, warning = FALSE, message = FALSE, time_it = TRUE}
# perform 50 repeats of 5-fold cross-validation
cv = crossValidate(measurements = data,
                   outcome = outcome,
                   nFolds = 5,
                   nRepeats = 50,
                   nCores = nCores)
```

We can use `performancePlot` to visualise performance metrics for all our features. Here, we visualise the AUC for each of the seven feature matrices we tested. Additional performance metrics can be specified in the `metric` argument.

```{r performancePlot, eval = F, fig.width = 12, fig.height = 6}
performancePlot(
  cv,
  metric = "AUC",
  characteristicsList = list(x = "Assay Name"),
  orderingList = list("Assay Name" = c("proportions", "spicyR", "lisaClust", "Kontextual", "celltypeMarkerMeans", "regionMarkerMeans", "SpatioMark"))
)
```

From the graph, both `lisaClust` and `proportions` appear to capture information which is predictive of the tumour type of patients.

## Classification of patients by survival

`crossValidate` also has the capacity to test classification performance for a survival outcome. In this case, `outcome` must be a `Surv` object of the same length as the number of samples in the feature matrix and should contain information about the time and censoring of the samples. Alternatively, we can specify `outcome` to be a `character` of length 2 or 3 that each match a column name in a data frame which holds information about the time and censoring of the samples. The time-to-event columns will automatically be removed before training is done.

We will first add a `survival` column to the `kerenSPE` object.

```{r survival setup}
# create a Surv object named "survival"
kerenSPE$event = 1 - kerenSPE$Censored
kerenSPE$survival = Surv(kerenSPE$`Survival_days_capped*`, kerenSPE$event)

# outcome vector
surv_outcome = kerenSPE$survival[!duplicated(kerenSPE$imageID)]
names(surv_outcome) = kerenSPE$imageID[!duplicated(kerenSPE$imageID)]

surv_outcome
```

We can then run `crossValidate` and specify the outcome to be `surv_outcome`, and use `performancePlot` to visualise the performance of the cross-validation. Since we are performing survival analysis, we will specify `metric = "C-index"`.

```{r survival cv, fig.width = 12, fig.height = 6, warning = FALSE, message = FALSE}
# perform 50 repeats of 5-fold cross-validation
surv_cv = crossValidate(measurements = data,
                   outcome = surv_outcome,
                   nFolds = 5,
                   nRepeats = 50,
                   nCores = nCores)

performancePlot(surv_cv,
  metric = "C-index",
  characteristicsList = list(x = "Assay Name"),
  orderingList = list("Assay Name" = c("proportions", "spicyR", "lisaClust", "Kontextual", "celltypeMarkerMeans", "regionMarkerMeans", "SpatioMark"))
)
```

From the graph, we can see that `lisaClust` appears to capture information that is predictive of survival outcomes comparatively well.

## Easy and hard to classify patients

The `samplesMetricMap` function allows the visual comparison of sample-wise error rate or accuracy measures from the cross-validation process.

### Predicting tumour type

```{r samplesMetricMap, warning = FALSE, message = FALSE, fig.width=15}
samplesMetricMap(cv,  
                 classColours = c("#3F48CC", "#880015"),
                 metricColours = list(c("#FFFFFF", "#CFD1F2", "#9FA3E5", "#6F75D8", "#3F48CC"),
                                      c("#FFFFFF", "#E1BFC4", "#C37F8A", "#A53F4F", "#880015")))
```

The benefit of this plot is that it allows the easy identification of samples which are hard to classify and could be explained by considering additional information about them. For example, samples 36 and 13 were difficult to classify across all feature metrics. We can appreciate that overall, we were better at identifying compartmentalised tumours compared to mixed tumours. Both cell type proportions (FuseSOM) and cell type co-localisation (spicyR) performed comparatively well at classifying patients on the basis of tumour type.

### Predicting survival outcomes

We can also use `sampleMetricMap` to identify samples that were difficult to classify with respect to a survival outcome.

```{r samplesMetricMap survival, warning = FALSE, message = FALSE, fig.width = 12}
samplesMetricMap(surv_cv)
```

Here, we can see that most methods performed the same, but lisaClust performed particularly well for samples 31-20. However, we had difficulty in predicting the outcome for sample 35.

In this way, we can use ClassifyR to predict clinical outcomes and identify samples or patients that are hard to classify with respect to an outcome of interest.

In subsequent sections, we will demonstrate how the end-to-end workflow can be applied to a single dataset in the form of case studies.

## sessionInfo

```{r sessionInfo}
sessionInfo()
```