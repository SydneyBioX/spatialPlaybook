[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "spicyWorkBook",
    "section": "",
    "text": "spicyWorkBook",
    "crumbs": [
      "spicyWorkBook"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n1 + 1\n\n[1] 2\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\n\n1 + 1\n\n[1] 2",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Summary</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "01-overview.html",
    "href": "01-overview.html",
    "title": "1  Overview",
    "section": "",
    "text": "1.1 MIBITOF\nMIBI-TOF (multiplexed ion beam imaging by time of flight) is an instrument that uses bright ion sources and orthogonal time-of-flight mass spectrometry to image metal-tagged antibodies at subcellular resolution in clinical tissue sections. The datasets we have seen image approximately 40 labeled antibodies and image fields of about \\(1mm^2\\) at resolutions down to \\(260nm\\)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Overview</span>"
    ]
  },
  {
    "objectID": "02-processing.html",
    "href": "02-processing.html",
    "title": "2  Processing",
    "section": "",
    "text": "2.1 Reading in images\nlibrary(cytomapper)\nlibrary(ggplot2)\nlibrary(simpleSeg)\nuse_mc &lt;- TRUE\n\nif (use_mc) {\n  nCores &lt;- max(parallel::detectCores()/2, 1)\n} else {\n  nCores &lt;- 2\n}\nBPPARAM &lt;- simpleSeg:::generateBPParam(nCores)\n\ntheme_set(theme_classic())\npathToImages &lt;- SpatialDatasets::Ferguson_Images()\n\nWarning: download failed\n  web resource path: 'https://experimenthub.bioconductor.org/metadata/experimenthub.sqlite3'\n  local file path: '/enna/users/ststaff/alexq/.cache/R/ExperimentHub/file25c8c575fae509'\n  reason: Transferred a partial file [experimenthub.bioconductor.org]: transfer closed with 8527872 bytes remaining to read\n\n\nWarning: bfcdownload() failed\n  rid: BFC1\n  file: 'https://experimenthub.bioconductor.org/metadata/experimenthub.sqlite3'\n  reason: download failed\n\n\nWarning: Could not check database for updates.\n  Database source currently unreachable.\n  This should only be a temporary interruption. \n  Using previously cached version.\n\n\nsee ?SpatialDatasets and browseVignettes('SpatialDatasets') for documentation\n\n\nloading from cache\n\ntmp &lt;- tempfile()\nunzip(pathToImages, exdir = tmp)\n\n# Store images in a CytoImageList on_disk as h5 files to save memory.\nimages &lt;- cytomapper::loadImages(\n  tmp,\n  single_channel = TRUE,\n  on_disk = TRUE,\n  h5FilesPath = HDF5Array::getHDF5DumpDir(),\n  BPPARAM = BPPARAM\n)\n\nmcols(images) &lt;- S4Vectors::DataFrame(imageID = names(images))\ncn &lt;- channelNames(images) # Read in channel names\nhead(cn)\n\n[1] \"139La_139La_panCK.ome\"      \"141Pr_141Pr_CD20.ome\"      \n[3] \"142Nd_142Nd_HH3.ome\"        \"143Nd_143Nd_CD45RA.ome\"    \n[5] \"146Nd_146Nd_CD8a.ome\"       \"147Sm_147Sm_podoplanin.ome\"\n\ncn &lt;- sub(\".*_\", \"\", cn) # Remove preceding letters\ncn &lt;- sub(\".ome\", \"\", cn) # Remove the .ome\nhead(cn)\n\n[1] \"panCK\"      \"CD20\"       \"HH3\"        \"CD45RA\"     \"CD8a\"      \n[6] \"podoplanin\"\n\nchannelNames(images) &lt;- cn # Reassign channel names\nhead(names(images))\n\n[1] \"ROI001_ROI 01_F3_SP16-001550_1E\" \"ROI002_ROI 02_F4_SP16-001550_1E\"\n[3] \"ROI003_ROI 03_F5_SP16-001550_1E\" \"ROI005_ROI 05_G4_SP17-002069_1F\"\n[5] \"ROI006_ROI 06_G5_SP17-002069_1F\" \"ROI007_ROI 07_G6_SP17-005715_1B\"\n\nnam &lt;- stringr::str_split_fixed(names(images), \"_\", n = 4)[, 3]\n\nhead(nam)\n\n[1] \"F3\" \"F4\" \"F5\" \"G4\" \"G5\" \"G6\"\n\nnames(images) &lt;- nam # Reassigning image names\nmcols(images)[[\"imageID\"]] &lt;- nam # Reassigning image names",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Processing</span>"
    ]
  },
  {
    "objectID": "03-quality_control.html",
    "href": "03-quality_control.html",
    "title": "3  Quality Control",
    "section": "",
    "text": "Steps:\n\nHow to qc segmentation (simpleSeg/cellSPA?)\nHow to qc image batch-effect (simpleSeg::normalizeCells)\nHow to qc patient batch-effect (simpleSeg::normalizeCells)\nHow to qc batch effects (scMerge)\n\n\n1 + 1\n\n[1] 2",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Quality Control</span>"
    ]
  },
  {
    "objectID": "04-cell_annotation.html",
    "href": "04-cell_annotation.html",
    "title": "4  Cell Annotation",
    "section": "",
    "text": "4.1 Which package should I use? Clustering vs Annotation\nClustering is…",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Cell Annotation</span>"
    ]
  },
  {
    "objectID": "05-condition_analysis.html",
    "href": "05-condition_analysis.html",
    "title": "5  Differential Analysis",
    "section": "",
    "text": "Steps:\n\nDifferential proportions of cells (spicyR::getProp)\nDifferential localisation of cells (spicyR)\nDifferential region proportions (lisaClust)\nDifferential localisation of cells with respect to a parent (Kontextual)\nDifferential cell-cell interactions (SpatioMark)\n\n\n1 + 1\n\n[1] 2",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Differential Analysis</span>"
    ]
  },
  {
    "objectID": "06-survival_analysis.html",
    "href": "06-survival_analysis.html",
    "title": "6  Survival Analysis",
    "section": "",
    "text": "Steps:\n\nAssociation between survival and cell proportion (spicyR::colTest)\nAssociation between survival and localisation (spicyR)\nAssociation between survival and region proportions (lisaClust)\nAssociation between survival and Kontextual features (Kontextual)\nAssociation between survival and cell-cell interactions (SpatioMark)\n\n\n1 + 1\n\n[1] 2",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Survival Analysis</span>"
    ]
  },
  {
    "objectID": "07-classification.html",
    "href": "07-classification.html",
    "title": "7  Survival Analysis",
    "section": "",
    "text": "Steps:\n\nMotivation of classification (prediction)\nClassification of patients by condition\nClassification of patients by survival\nEasy and Hard to classify patients (samplesMetricMap)\nMaximising accuracy during classification (parameter tuning for crossValidate)\n\n\n1 + 1\n\n[1] 2",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Survival Analysis</span>"
    ]
  },
  {
    "objectID": "01-overview.html#packages",
    "href": "01-overview.html#packages",
    "title": "1  Overview",
    "section": "1.2 Packages",
    "text": "1.2 Packages\n\n\n\n\n\n    \n\nDeeper explanations of the functionality of our software can be found in the Software tab",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Overview</span>"
    ]
  },
  {
    "objectID": "07-changes_in_marker_expression.html",
    "href": "07-changes_in_marker_expression.html",
    "title": "7  Marker expression",
    "section": "",
    "text": "Steps:\n(SpatioMark/scFeatures, e.g. Moran’s I, marker means within spatial domains, marker means wtihin cell types etc.)\n\n1 + 1\n\n[1] 2\n\n\nhow do you see us doing multiple analyses in parallel? Just have them as separate subheadings? have them on separate pages?",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Marker expression</span>"
    ]
  },
  {
    "objectID": "05-cell_localisation.html",
    "href": "05-cell_localisation.html",
    "title": "5  Cell localisation",
    "section": "",
    "text": "5.1 spicyR\nThis guide provides step-by-step instructions on how to apply a linear model to multiple segmented and labelled images to assess how the localisation of different cell types changes across different disease conditions.\nWe use the (keren2018?) breast cancer dataset to compare the spatial distribution of immune cells in individuals with different levels of tumour infiltration (cold and compartmentalised).\nThe data is stored as a SpatialExperiment object and contains single-cell spatial data from 41 images.\nkerenSPE &lt;- SpatialDatasets::spe_Keren_2018()\nThe cell types in this dataset includes 11 immune cell types (double negative CD3 T cells, CD4 T cells, B cells, monocytes, macrophages, CD8 T cells, neutrophils, natural killer cells, dendritic cells, regulatory T cells), 2 structural cell types (endothelial, mesenchymal), 2 tumour cell types (keratin+ tumour, tumour) and one unidentified category.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Cell localisation</span>"
    ]
  },
  {
    "objectID": "06-cellular_niches.html",
    "href": "06-cellular_niches.html",
    "title": "6  Cellular niches",
    "section": "",
    "text": "6.1 lisaClust\nClustering local indicators of spatial association (LISA) functions is a methodology for identifying consistent spatial organisation of multiple cell-types in an unsupervised way. This can be used to enable the characterization of interactions between multiple cell-types simultaneously and can complement traditional pairwise analysis. In our implementation our LISA curves are a localised summary of an L-function from a Poisson point process model. Our framework lisaClust can be used to provide a high-level summary of cell-type colocalization in high-parameter spatial cytometry data, facilitating the identification of distinct tissue compartments or identification of complex cellular microenvironments.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Cellular niches</span>"
    ]
  },
  {
    "objectID": "08-classification.html",
    "href": "08-classification.html",
    "title": "8  Classification",
    "section": "",
    "text": "Steps:\n\nMotivation of classification (prediction)\nClassification of patients by condition\nClassification of patients by survival\nEasy and Hard to classify patients (samplesMetricMap)\nMaximising accuracy during classification (parameter tuning for crossValidate)\n\n\n1 + 1\n\n[1] 2",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Classification</span>"
    ]
  },
  {
    "objectID": "01-overview.html#mibitof",
    "href": "01-overview.html#mibitof",
    "title": "1  Overview",
    "section": "",
    "text": "1.1.1 Triple Negative Breast Cancer - Keren_2018\nA MIBI-TOF dataset profiling tissue from triple-negative breast cancer patients is used to illustrate the functionality of our Statial package. That is, identifying changes in cell state that are related to spatial localisation of cells. This dataset simultaneously quantifies in situ expression of 36 proteins in 41 patients.\n Keren et al. (2018). A Structured Tumor-Immune Microenvironment in Triple Negative Breast Cancer Revealed by Multiplexed Ion Beam Imaging. Cell, 174(6), 1373-1387.e1319. (DOI) \n\n\n1.1.2 Ductal carcinoma in situ - Risom_2022\nA MIBI-TOF data profiling the spatial landscape of ductal carcinoma in situ (DCIS), which is a pre-invasive lesion that is thought to be a precursor to invasive breast cancer (IBC). This is currently the primary dataset used for illustration of our spicyWorkflow on Bioconductor. The key conclusion of this manuscript (amongst others) is that spatial information about cells can be used to predict disease progression in patients. We use a bunch of our packages to make a similar conclusion and cover topics such as cell segmentation, data normalisation, various tests of proportion and spatial localisation, microenvironment estimation and patient prediction.\n Risom et al. (2022). Transition to invasive breast cancer is associated with progressive changes in the structure and composition of tumor stroma. Cell, 185(2), 299-310.e18 (DOI)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Overview</span>"
    ]
  },
  {
    "objectID": "01-overview.html#seqfish",
    "href": "01-overview.html#seqfish",
    "title": "1  Overview",
    "section": "1.2 seqFISH",
    "text": "1.2 seqFISH\nSeqFISH (sequential Fluorescence In Situ Hybridization) is a technology that enables the identification of thousands of molecules like RNA, DNA, and proteins directly in single cells with their spatial context preserved. seqFISH can multiplex over 10,000 molecules and integrate multiple modalities, such as imaging the transcriptome and proteins\n\n1.2.1 Mouse organogenesis - Lohoff_2022\nWe use our package scHOT to analyse Lohoff et al’s study of early mouse organogenesis that was performed using a seqFISH. This analysis was adapted from a workshop that Shila and Ellis deliver as an introduction to spatial data analysis and in addition to scHOT, covers basic manipulation and visualisation of SpatialExperiment objects.\n Lohoff et al. (2022). Integration of spatial and single-cell transcriptomic data elucidates mouse organogenesis. Nature Biotechnology 40, 74–85 (DOI).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Overview</span>"
    ]
  },
  {
    "objectID": "index.html#welcome",
    "href": "index.html#welcome",
    "title": "spicyWorkBook",
    "section": "Welcome!",
    "text": "Welcome!\n\nRecent advances in highly multiplexed cell imaging technologies such as PhenoCycler, IMC, CosMx, Xenium, and MERFISH (and many more) have fundamentally revolutionized our ability to observe complex cellular relationships in tissue. Where previous immunohistochemistry protocols only allowed the visualization of cells that could be characterized by two or three surface proteins, cutting-edge technologies characterize cells with upwards of 50 proteins or 1000s of RNA in situ. These technologies enable precise classification of cell sub-types and provide an unprecedented depiction of cellular heterogeneity in a tissue environment. These technical developments have necessitated the development of a variety of new analytical approaches that are required to harness these new imaging technologies. On this website we will demonstrate how packages in scdney can be used to provide new insights into complex biological systems and diseases.",
    "crumbs": [
      "spicyWorkBook"
    ]
  },
  {
    "objectID": "index.html#packages",
    "href": "index.html#packages",
    "title": "spicyWorkBook",
    "section": "Packages",
    "text": "Packages\n\n\n\n\n\n    \n\n\n\nMoleculeExperiment\n\nMoleculeExperiment contains functions to create and work with objects from the new MoleculeExperiment class. We introduce this class for analysing molecule-based spatial transcriptomics data (e.g., Xenium by 10X, Cosmx SMI by Nanostring, and Merscope by Vizgen). This allows researchers to analyse spatial transcriptomics data at the molecule level, and to have standardised data formats accross vendors.\n\n\nPeters Couto B, Robertson N, Patrick E, Ghazanfar S (2024). MoleculeExperiment: Prioritising a molecule-level storage of Spatial Transcriptomics Data. R package version 1.6.0.\n\n\n\n\nsimpleSeg\n\nImage segmentation is the process of identifying the borders of individual objects (in this case cells) within an image. This allows for the features of cells such as marker expression and morphology to be extracted, stored and analysed. simpleSeg provides functionality for user friendly, watershed based segmentation on multiplexed cellular images in R based on the intensity of user specified protein marker channels. simpleSeg can also be used for the normalization of single cell data obtained from multiple images.\n\n\nCanete N, Nicholls A, Patrick E (2024). simpleSeg: A package to perform simple cell segmentation. R package version 1.8.0.\n\n\n\n\nscMerge\n\nLike all gene expression data, single-cell data suffers from batch effects and other unwanted variations that makes accurate biological interpretations difficult. The scMerge method leverages factor analysis, stably expressed genes (SEGs) and (pseudo-) replicates to remove unwanted variations and merge multiple single-cell data. This package contains all the necessary functions in the scMerge pipeline, including the identification of SEGs, replication-identification methods, and merging of single-cell data.\n\n\nLin Y, Ghazanfar S, Wang K, Gagnon-Bartsch J, Lo K, Su X, Han Z, Ormerod J, Speed T, Yang P, Yang J (2019). “scMerge leverages factor analysis, stable expression, and pseudoreplication to merge multiple single-cell RNA-seq datasets.” Proceedings of the National Academy of Sciences. doi:10.1073/pnas.1820006116.\n\n\n\n\nFuseSOM\n\nA correlation-based multiview self-organizing map for the characterization of cell types in highly multiplexed in situ imaging cytometry assays (FuseSOM) is a tool for unsupervised clustering. FuseSOM is robust and achieves high accuracy by combining a Self Organizing Map architecture and a Multiview integration of correlation based metrics. This allows FuseSOM to cluster highly multiplexed in situ imaging cytometry assays.\n\n&lt;0-length citation&gt;\n\n\n\ntreekoR\n\ntreekoR is a novel framework that aims to utilise the hierarchical nature of single cell cytometry data to find robust and interpretable associations between cell subsets and patient clinical end points. These associations are aimed to recapitulate the nested proportions prevalent in workflows inovlving manual gating, which are often overlooked in workflows using automatic clustering to identify cell populations. We developed treekoR to: Derive a hierarchical tree structure of cell clusters; quantify a cell types as a proportion relative to all cells in a sample (%total), and, as the proportion relative to a parent population (%parent); perform significance testing using the calculated proportions; and provide an interactive html visualisation to help highlight key results.\n\n\nChan A (2024). treekoR: Cytometry Cluster Hierarchy and Cellular-to-phenotype Associations. R package version 1.14.0.\n\n\n\n\nscFeatures\n\nscFeatures constructs multi-view representations of single-cell and spatial data. scFeatures is a tool that generates multi-view representations of single-cell and spatial data through the construction of a total of 17 feature types. These features can then be used for a variety of analyses using other software in Biocondutor.\n\n\nCao,Y., Lin,Y., Patrick,E., Yang,P., Yang,J.Y.H. & (2022). “scFeatures: multi-view representations of single-cell and spatial data for disease outcome prediction.” Bioinformatics, 38(20), 4745-4753. ISSN 1367-4803, doi:10.1093/bioinformatics/btac590.\n\n\n\n\nscHOT\n\nSingle cell Higher Order Testing (scHOT) is an R package that facilitates testing changes in higher order structure of gene expression along either a developmental trajectory or across space. scHOT is general and modular in nature, can be run in multiple data contexts such as along a continuous trajectory, between discrete groups, and over spatial orientations; as well as accommodate any higher order measurement such as variability or correlation. scHOT meaningfully adds to first order effect testing, such as differential expression, and provides a framework for interrogating higher order interactions from single cell data.\n\n\nGhazanfar S, Lin Y (2024). scHOT: single-cell higher order testing. R package version 1.18.0.\n\n\n\n\nspicyR\n\nThe spicyR package provides a framework for performing inference on changes in spatial relationships between pairs of cell types for cell-resolution spatial omics technologies. spicyR consists of three primary steps: (i) summarizing the degree of spatial localization between pairs of cell types for each image; (ii) modelling the variability in localization summary statistics as a function of cell counts and (iii) testing for changes in spatial localizations associated with a response variable.\n\n\nCanete N, Iyengar S, Ormerod J, Baharlou H, Harman A, Patrick E (2022). “spicyR: spatial analysis of in situ cytometry data in R.” Bioinformatics, 38(11), 3099–3105. doi:10.1093/bioinformatics/btac268.\n\n\n\n\nStatial\n\nStatial is a suite of functions for identifying changes in cell state. The functionality provided by Statial provides robust quantification of cell type localisation which are invariant to changes in tissue structure. In addition to this Statial uncovers changes in marker expression associated with varying levels of localisation. These features can be used to explore how the structure and function of different cell types may be altered by the agents they are surrounded with.\n\n\nAmeen F, Robertson N, Lin D, Ghazanfar S, Patrick E (2024). “Kontextual: Reframing analysis of spatial omics data reveals consistent cell relationships across images.” bioRxiv. doi:10.1101/2024.09.03.611109.\n\n\n\n\nlisaClust\n\nlisaClust provides a series of functions to identify and visualise regions of tissue where spatial associations between cell-types is similar. This package can be used to provide a high-level summary of cell-type colocalization in multiplexed imaging data that has been segmented at a single-cell resolution.\n\n\nPatrick E, Canete N (2024). lisaClust: lisaClust: Clustering of Local Indicators of Spatial Association. R package version 1.14.4.\n\n\n\n\nClassifyR\n\nThe software formalises a framework for classification and survival model evaluation in R. There are four stages; Data transformation, feature selection, model training, and prediction. The requirements of variable types and variable order are fixed, but specialised variables for functions can also be provided. The framework is wrapped in a driver loop that reproducibly carries out a number of cross-validation schemes. Functions for differential mean, differential variability, and differential distribution are included. Additional functions may be developed by the user, by creating an interface to the framework.\n\n\nStrbenac D, Mann GJ, Ormerod JT, Yang JYH (2015). “ClassifyR: an R package for performance assessment of classification with applications to transcriptomics.” Bioinformatics, 31(11), 1851-1853.",
    "crumbs": [
      "spicyWorkBook"
    ]
  },
  {
    "objectID": "05-cell_localisation.html#test-for-change-in-localisation-for-a-specific-pair-of-cells",
    "href": "05-cell_localisation.html#test-for-change-in-localisation-for-a-specific-pair-of-cells",
    "title": "5  Cell localisation",
    "section": "5.2 Test for change in localisation for a specific pair of cells",
    "text": "5.2 Test for change in localisation for a specific pair of cells\nFirstly, we can test whether one cell type tends to be more localised with another cell type in one condition compared to the other. This can be done using the spicy() function, where we specify the condition parameter.\nIn this example, we want to see whether or not neutrophils (to) tend to be found around CD8 T cells (from) in compartmentalised tumours compared to cold tumours. Given that there are 3 conditions, we can specify the desired conditions by setting the order of our condition factor. spicy will choose the first level of the factor as the base condition and the second level as the comparison condition. spicy will also naturally coerce the condition column into a factor if it is not already a factor. The column containing cell type annotations can be specified using the cellTypeCol argument. By default, spicy uses the column named cellType in the SpatialExperiment object.\n\nspicyTestPair &lt;- spicy(\n  kerenSPE,\n  condition = \"tumour_type\",\n  from = \"CD8_T_cell\",\n  to = \"Neutrophils\"\n)\n\ntopPairs(spicyTestPair)\n\n                        intercept coefficient      p.value   adj.pvalue\nCD8_T_cell__Neutrophils  -109.081    112.0185 2.166646e-05 2.166646e-05\n                              from          to\nCD8_T_cell__Neutrophils CD8_T_cell Neutrophils\n\n\nWe obtain a spicy object which details the results of the modelling performed. The topPairs() function can be used to obtain the associated coefficients and p-value.\nAs the coefficient in spicyTestPair is positive, we find that neutrophils are significantly more likely to be found near CD8 T cells in the compartmentalised tumours group compared to the cold tumour group.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Cell localisation</span>"
    ]
  },
  {
    "objectID": "05-cell_localisation.html#test-for-change-in-localisation-for-all-pairwise-cell-combinations",
    "href": "05-cell_localisation.html#test-for-change-in-localisation-for-all-pairwise-cell-combinations",
    "title": "5  Cell localisation",
    "section": "5.3 Test for change in localisation for all pairwise cell combinations",
    "text": "5.3 Test for change in localisation for all pairwise cell combinations\nWe can perform what we did above for all pairwise combinations of cell types by excluding the from and to parameters in spicy().\n\nspicyTest &lt;- spicy(\n  kerenSPE,\n  condition = \"tumour_type\"\n)\n\ntopPairs(spicyTest)\n\n                            intercept coefficient      p.value   adj.pvalue\nMacrophages__dn_T_CD3       56.446064   -50.08474 1.080273e-07 3.035568e-05\ndn_T_CD3__Macrophages       54.987151   -48.38664 2.194018e-07 3.082595e-05\nMacrophages__DC_or_Mono     73.239404   -59.90361 5.224660e-06 4.893765e-04\nDC_or_Mono__Macrophages     71.777087   -58.46833 7.431172e-06 5.220399e-04\ndn_T_CD3__dn_T_CD3         -63.786032   100.61010 2.878804e-05 1.208706e-03\nNeutrophils__dn_T_CD3      -63.141840    69.64356 2.891872e-05 1.208706e-03\ndn_T_CD3__Neutrophils      -63.133725    70.15508 3.011012e-05 1.208706e-03\nDC__Macrophages             96.893239   -92.55112 1.801300e-04 5.758129e-03\nMacrophages__DC             96.896215   -93.25194 1.844241e-04 5.758129e-03\nCD4_T_cell__Keratin_Tumour  -4.845037   -22.14995 2.834659e-04 7.409016e-03\n                                  from             to\nMacrophages__dn_T_CD3      Macrophages       dn_T_CD3\ndn_T_CD3__Macrophages         dn_T_CD3    Macrophages\nMacrophages__DC_or_Mono    Macrophages     DC_or_Mono\nDC_or_Mono__Macrophages     DC_or_Mono    Macrophages\ndn_T_CD3__dn_T_CD3            dn_T_CD3       dn_T_CD3\nNeutrophils__dn_T_CD3      Neutrophils       dn_T_CD3\ndn_T_CD3__Neutrophils         dn_T_CD3    Neutrophils\nDC__Macrophages                     DC    Macrophages\nMacrophages__DC            Macrophages             DC\nCD4_T_cell__Keratin_Tumour  CD4_T_cell Keratin_Tumour\n\n\nAgain, we obtain a spicy object which outlines the result of the linear models performed for each pairwise combination of cell types.\nWe can also examine the L-function metrics of individual images by using the convenient bind() function on our spicyTest results object.\n\nbind(spicyTest)[1:5, 1:5]\n\n  imageID         condition Keratin_Tumour__Keratin_Tumour\n1       1             mixed                      -2.300602\n2       2             mixed                      -1.989699\n3       3 compartmentalised                      11.373530\n4       4 compartmentalised                      33.931133\n5       5 compartmentalised                      17.922818\n  dn_T_CD3__Keratin_Tumour B_cell__Keratin_Tumour\n1                -5.298543             -20.827279\n2               -16.020022               3.025815\n3               -21.857447             -24.962913\n4               -36.438476             -40.470221\n5               -20.816783             -38.138076\n\n\nThe results can be represented as a bubble plot using the signifPlot() function.\n\nsignifPlot(\n  spicyTest,\n  breaks = c(-3, 3, 1),\n  marksToPlot = c(\"Macrophages\", \"DC_or_Mono\", \"dn_T_CD3\", \"Neutrophils\",\n                  \"CD8_T_cell\", \"Keratin_Tumour\")\n)\n\n\n\n\n\n\n\n\nHere, we can observe that the most significant relationships occur between macrophages and double negative CD3 T cells, suggesting that the two cell types are far more dispersed in compartmentalised tumours compared to cold tumours.\nTo examine a specific cell type-cell type relationship in more detail, we can use spicyBoxplot() and specify either from = \"Macrophages\" and to = \"dn_T_CD3\" or rank = 1.\n\nspicyBoxPlot(results = spicyTest, \n             # from = \"Macrophages\",\n             # to = \"dn_T_CD3\"\n             rank = 1)\n\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_boxplot()`).\n\n\n\n\n\n\n\n\n\n\n5.3.1 Linear modelling for custom metrics\nspicyR can also be applied to custom distance or abundance metrics. A kNN interactions graph can be generated with the function buildSpatialGraph from the imcRtools package. This generates a colPairs object inside of the SpatialExperiment object.\nspicyR provides the function convPairs for converting a colPairs object into an abundance matrix by calculating the average number of nearby cells types for every cell type for a given k. For example, if there exists on average 5 neutrophils for every macrophage in image 1, the column Neutrophil__Macrophage would have a value of 5 for image 1.\n\nkerenSPE &lt;- imcRtools::buildSpatialGraph(kerenSPE, \n                                         img_id = \"imageID\", \n                                         type = \"knn\", k = 20,\n                                        coords = c(\"x\", \"y\"))\n\n'sample_id's are duplicated across 'SpatialExperiment' objects to cbind; appending sample indices.\n\n\nThe returned object is ordered by the 'imageID' entry.\n\npairAbundances &lt;- convPairs(kerenSPE,\n                  colPair = \"knn_interaction_graph\")\n\nhead(pairAbundances[\"B_cell__B_cell\"])\n\n   B_cell__B_cell\n1      12.7349608\n10      0.2777778\n11      0.0000000\n12      1.3333333\n13      1.2200957\n14      0.0000000\n\n\nThe custom distance or abundance metrics can then be included in the analysis with the alternateResult parameter. The Statial package contains other custom distance metrics which can be used with spicy.\n\nspicyTestColPairs &lt;- spicy(\n  kerenSPE,\n  condition = \"tumour_type\",\n  alternateResult = pairAbundances,\n  weights = FALSE\n)\n\ntopPairs(spicyTestColPairs)\n\n                           intercept coefficient     p.value adj.pvalue\nCD8_T_cell__Neutrophils  0.833333333  -0.7592968 0.002645466  0.3291833\nB_cell__Tumour           0.001937984   0.2602822 0.004872664  0.3291833\nOther_Immune__NK         0.012698413   0.2612881 0.005673068  0.3291833\nUnidentified__CD8_T_cell 0.106626794   0.6387339 0.005906526  0.3291833\ndn_T_CD3__NK             0.004242424   0.2148797 0.006317829  0.3291833\nCD4_T_cell__Neutrophils  0.036213602   0.2947696 0.007902670  0.3291833\nTregs__CD4_T_cell        0.128876212   0.5726201 0.010207087  0.3291833\nEndothelial__DC          0.008771930   0.3008523 0.011189533  0.3291833\nTumour__Neutrophils      0.021638939   0.2529045 0.011388850  0.3291833\nMesenchymal__Neutrophils 0.004504505   0.2494301 0.012761315  0.3291833\n                                 from          to\nCD8_T_cell__Neutrophils    CD8_T_cell Neutrophils\nB_cell__Tumour                 B_cell      Tumour\nOther_Immune__NK         Other_Immune          NK\nUnidentified__CD8_T_cell Unidentified  CD8_T_cell\ndn_T_CD3__NK                 dn_T_CD3          NK\nCD4_T_cell__Neutrophils    CD4_T_cell Neutrophils\nTregs__CD4_T_cell               Tregs  CD4_T_cell\nEndothelial__DC           Endothelial          DC\nTumour__Neutrophils            Tumour Neutrophils\nMesenchymal__Neutrophils  Mesenchymal Neutrophils\n\n\n\nsignifPlot(\n  spicyTestColPairs,\n  breaks = c(-3, 3, 1),\n  marksToPlot = c(\"Macrophages\", \"dn_T_CD3\", \"CD4_T_cell\", \n                  \"B_cell\", \"DC_or_Mono\", \"Neutrophils\", \"CD8_T_cell\")\n)\n\n\n\n\n\n\n\n\n\n\n5.3.2 Performing survival analysis\nspicy can also be used to perform survival analysis to asses whether changes in co-localisation between cell types are associated with survival probability. spicy requires the SingleCellExperiment object being used to contain a column called survival as a Surv object.\n\nkerenSPE$event = 1 - kerenSPE$Censored\nkerenSPE$survival = Surv(kerenSPE$`Survival_days_capped*`, kerenSPE$event)\n\nWe can then perform survival analysis using the spicy function by specifying condition = \"survival\". We can then access the corresponding coefficients and p-values by accessing the survivalResults slot in the spicy results object.\n\n# Running survival analysis\nspicySurvival = spicy(kerenSPE,\n                      condition = \"survival\")\n\n# top 10 significant pairs\nhead(spicySurvival$survivalResults, 10)\n\n# A tibble: 10 × 4\n   test                       coef se.coef    p.value\n   &lt;chr&gt;                     &lt;dbl&gt;   &lt;dbl&gt;      &lt;dbl&gt;\n 1 Other_Immune__Tregs     0.0236  0.00866 0.00000893\n 2 CD4_T_cell__Tregs       0.0177  0.00685 0.0000124 \n 3 Tregs__Other_Immune     0.0237  0.00873 0.0000126 \n 4 Tregs__CD4_T_cell       0.0171  0.00676 0.0000285 \n 5 CD8_T_cell__CD8_T_cell  0.00605 0.00272 0.000332  \n 6 Tumour__CD8_T_cell     -0.0305  0.0114  0.000617  \n 7 CD8_T_cell__Tumour     -0.0305  0.0116  0.000721  \n 8 CD4_T_cell__dn_T_CD3    0.00845 0.00353 0.000794  \n 9 dn_T_CD3__CD4_T_cell    0.00840 0.00353 0.000937  \n10 DC__Other_Immune       -0.0289  0.0123  0.00103   \n\n\n\n\n5.3.3 Accounting for tissue inhomogeneity\nThe spicy function can also account for tissue inhomogeneity to avoid false positives or negatives. This can be done by setting the sigma = parameter within the spicy function. By default, sigma is set to NULL, and spicy assumes a homogeneous tissue structure.\nFor example, when we examine the L-function for Keratin_Tumour__Neutrophils when sigma = NULL and Rs = 100, the value is positive, indicating attraction between the two cell types.\n\n# filter SPE object to obtain image 24 data\nkerenSubset = kerenSPE[, colData(kerenSPE)$imageID == \"24\"]\n\npairwiseAssoc = getPairwise(kerenSubset, \n                            sigma = NULL, \n                            Rs = 100) |&gt;\n  as.data.frame()\n\npairwiseAssoc[[\"Keratin_Tumour__Neutrophils\"]]\n\n[1] 10.88892\n\n\nWhen we specify sigma = 20 and re-calculate the L-function, it indicates that there is no relationship between Keratin_Tumour and Neutrophils, i.e., there is no major attraction or dispersion, as it now takes into account tissue inhomogeneity.\n\npairwiseAssoc = getPairwise(kerenSubset, \n                            sigma = 20, \n                            Rs = 100) |&gt;\n  as.data.frame()\n\npairwiseAssoc[[\"Keratin_Tumour__Neutrophils\"]]\n\n[1] 0.9024836\n\n\n\n# obtain colData for image 24\ncData = colData(kerenSPE) |&gt; as.data.frame() |&gt; \n          dplyr::filter(imageID == \"24\")\n\n# obtain cells present in image 24\ncoords = spatialCoords(kerenSPE) |&gt; as.data.frame()\ncoords$cellID = rownames(coords)\ncoords = coords |&gt; dplyr::filter(cellID %in% cData$CellID)\n\ncData$X = coords$x\ncData$Y = coords$y\n\ncData = cData |&gt; \n  dplyr::mutate(cellTypeNew = ifelse(cellType %in% c(\"Keratin_Tumour\", \"Neutrophils\"), \n                                     cellType, \"Other\"))\n\n pal = setNames(c(\"#d6b11c\", \"#850f07\"), \n                c(\"Keratin_Tumour\", \"Neutrophils\"))\n\nggplot() +\n    stat_density_2d(data = cData, aes(x = X, y = Y, fill = after_stat(density)), \n                    geom = \"raster\", \n                    contour = FALSE) +\n    geom_point(data = cData |&gt; filter(cellType != \"Other\"),\n               aes(x = X, y = Y, colour = cellTypeNew), size = 1) +\n    scale_color_manual(values = pal) +\n    scale_fill_distiller(palette = \"Blues\", direction = 1) +\n    theme_classic() +\n    labs(title = \"image ID: 24\")\n\n\n\n\n\n\n\n\nPlotting image 24 shows that the supposed co-localisation occurs due to the dense cluster of cells near the top of the image.\n\n\n5.3.4 Mixed effects modelling\nspicyR supports mixed effects modelling when multiple images are obtained for each subject. In this case, subject is treated as a random effect and condition is treated as a fixed effect. To perform mixed effects modelling, we can specify the subject parameter in the spicy function.\n\nspicyMixedTest &lt;- spicy(\n  diabetesData,\n  condition = \"stage\",\n  subject = \"case\"\n)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Cell localisation</span>"
    ]
  },
  {
    "objectID": "06-cellular_niches.html#generate-toy-data",
    "href": "06-cellular_niches.html#generate-toy-data",
    "title": "6  Cellular niches",
    "section": "8.1 Generate toy data",
    "text": "8.1 Generate toy data\nTo illustrate our lisaClust framework, we consider a very simple toy example where two cell-types are completely separated spatially. We simulate data for two different images.\n\nset.seed(51773)\nx &lt;- round(c(\n  runif(200), runif(200) + 1, runif(200) + 2, runif(200) + 3,\n  runif(200) + 3, runif(200) + 2, runif(200) + 1, runif(200)\n), 4) * 100\ny &lt;- round(c(\n  runif(200), runif(200) + 1, runif(200) + 2, runif(200) + 3,\n  runif(200), runif(200) + 1, runif(200) + 2, runif(200) + 3\n), 4) * 100\ncellType &lt;- factor(paste(\"c\", rep(rep(c(1:2), rep(200, 2)), 4), sep = \"\"))\nimageID &lt;- rep(c(\"s1\", \"s2\"), c(800, 800))\n\ncells &lt;- data.frame(x, y, cellType, imageID)\n\nggplot(cells, aes(x, y, colour = cellType)) +\n  geom_point() +\n  facet_wrap(~imageID) +\n  theme_minimal()",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Cellular niches</span>"
    ]
  },
  {
    "objectID": "06-cellular_niches.html#create-single-cell-experiment-object",
    "href": "06-cellular_niches.html#create-single-cell-experiment-object",
    "title": "6  Cellular niches",
    "section": "8.2 Create Single Cell Experiment object",
    "text": "8.2 Create Single Cell Experiment object\nFirst we store our data in a SingleCellExperiment object.\n\nSCE &lt;- SingleCellExperiment(colData = cells)\nSCE\n\nclass: SingleCellExperiment \ndim: 0 1600 \nmetadata(0):\nassays(0):\nrownames: NULL\nrowData names(0):\ncolnames: NULL\ncolData names(4): x y cellType imageID\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Cellular niches</span>"
    ]
  },
  {
    "objectID": "06-cellular_niches.html#running-lisaclust",
    "href": "06-cellular_niches.html#running-lisaclust",
    "title": "6  Cellular niches",
    "section": "8.3 Running lisaCLust",
    "text": "8.3 Running lisaCLust\nWe can then use the convenience function lisaClust to simultaneously calculate local indicators of spatial association (LISA) functions and perform k-means clustering. The number of clusters can be specified with the k = parameter. In the example below, we’ve chosen k = 2, resulting in a total of 2 clusters. The cell type column can be specified using the cellType = argument. By default, lisaClust uses the column named cellType.\nThe clusters identified by lisaClust are stored in colData of the SingleCellExperiment object as a new column called regions.\n\nSCE &lt;- lisaClust(SCE, k = 2)\n\nGenerating local L-curves.\n\ncolData(SCE) |&gt; head()\n\nDataFrame with 6 rows and 5 columns\n          x         y cellType     imageID      region\n  &lt;numeric&gt; &lt;numeric&gt; &lt;factor&gt; &lt;character&gt; &lt;character&gt;\n1     36.72     38.58       c1          s1    region_2\n2     61.38     41.29       c1          s1    region_2\n3     33.59     80.98       c1          s1    region_2\n4     50.17     64.91       c1          s1    region_2\n5     82.93     35.60       c1          s1    region_2\n6     83.13      2.69       c1          s1    region_2",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Cellular niches</span>"
    ]
  },
  {
    "objectID": "06-cellular_niches.html#plot-identified-regions",
    "href": "06-cellular_niches.html#plot-identified-regions",
    "title": "6  Cellular niches",
    "section": "8.4 Plot identified regions",
    "text": "8.4 Plot identified regions\nlisaClust also provides the convenient hatchingPlot function to visualise the different regions that have been demarcated by the clustering. hatchingPlot outputs a ggplot object where the regions are marked by different hatching patterns. In a real biological dataset, this allows us to plot both regions and cell-types on the same visualization.\nIn the example below, we can visualise our stimulated data where our 2 cell types have been separated neatly into 2 distinct regions based on which cell type each region is dominated by. region_2 is dominated by the red cell type c1, and region_1 is dominated by the blue cell type c2.\n\nhatchingPlot(SCE, useImages = c(\"s1\", \"s2\"))\n\nConcave windows are temperamental. Try choosing values of window.length &gt; and &lt; 1 if you have problems.\nConcave windows are temperamental. Try choosing values of window.length &gt; and &lt; 1 if you have problems.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Cellular niches</span>"
    ]
  },
  {
    "objectID": "06-cellular_niches.html#using-other-clustering-methods.",
    "href": "06-cellular_niches.html#using-other-clustering-methods.",
    "title": "6  Cellular niches",
    "section": "8.5 Using other clustering methods.",
    "text": "8.5 Using other clustering methods.\nWhile the lisaClust function is convenient, we have not implemented an exhaustive suite of clustering methods as it is very easy to do this yourself. There are just two simple steps.\n\n8.5.1 Generate LISA curves\nWe can calculate local indicators of spatial association (LISA) functions using the lisa function. Here the LISA curves are a localised summary of an L-function from a Poisson point process model. The radii that will be calculated over can be set with Rs.\n\nlisaCurves &lt;- lisa(SCE, Rs = c(20, 50, 100))\n\nGenerating local L-curves.\n\nhead(lisaCurves)\n\n          20_c1     20_c2     50_c1     50_c2    100_c1     100_c2\ncell_1 5.556700 -2.764143 15.631209 -6.910357 11.733097  -9.198914\ncell_2 4.833149 -2.764143 13.940407 -6.910357  9.532662  -8.543440\ncell_3 5.918476 -2.764143  9.008588 -6.910357  9.157887  -7.813862\ncell_4 4.109597 -2.764143 11.907928 -6.910357  8.404425  -8.140036\ncell_5 3.024270 -2.764143 10.159278 -6.910357  9.006286  -8.283564\ncell_6 7.986742 -2.764143  8.675070 -6.910357 12.859615 -13.820714\n\n\n\n\n8.5.2 Perform some clustering\nThe LISA curves can then be used to cluster the cells. Here we use k-means clustering. However, other clustering methods like SOM could also be used. We can store these cell clusters or cell “regions” in our SingleCellExperiment object.\n\n# Custom clustering algorithm\nkM &lt;- kmeans(lisaCurves, 2)\n\n# Storing clusters into colData\ncolData(SCE)$custom_region &lt;- paste(\"region\", kM$cluster, sep = \"_\")\ncolData(SCE) |&gt; head()\n\nDataFrame with 6 rows and 6 columns\n          x         y cellType     imageID      region custom_region\n  &lt;numeric&gt; &lt;numeric&gt; &lt;factor&gt; &lt;character&gt; &lt;character&gt;   &lt;character&gt;\n1     36.72     38.58       c1          s1    region_2      region_2\n2     61.38     41.29       c1          s1    region_2      region_2\n3     33.59     80.98       c1          s1    region_2      region_2\n4     50.17     64.91       c1          s1    region_2      region_2\n5     82.93     35.60       c1          s1    region_2      region_2\n6     83.13      2.69       c1          s1    region_2      region_2",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Cellular niches</span>"
    ]
  },
  {
    "objectID": "06-cellular_niches.html#read-in-data",
    "href": "06-cellular_niches.html#read-in-data",
    "title": "6  Cellular niches",
    "section": "9.1 Read in data",
    "text": "9.1 Read in data\nWe will start by reading in the data from the SpatialDatasets package as a SingleCellExperiment object. Here the data is in a format consistent with that outputted by CellProfiler.\n\nkerenSPE &lt;- SpatialDatasets::spe_Keren_2018()\n\nsee ?SpatialDatasets and browseVignettes('SpatialDatasets') for documentation\n\n\nloading from cache",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Cellular niches</span>"
    ]
  },
  {
    "objectID": "06-cellular_niches.html#generate-lisa-curves-1",
    "href": "06-cellular_niches.html#generate-lisa-curves-1",
    "title": "6  Cellular niches",
    "section": "9.2 Generate LISA curves",
    "text": "9.2 Generate LISA curves\nThis data includes annotation of the cell-types of each cell. Hence, we can move directly to performing k-means clustering on the local indicators of spatial association (LISA) functions using the lisaClust function, remembering to specify the imageID, cellType, and spatialCoords columns in colData. For the purpose of demonstration, we will be using only images 5 and 6 of the kerenSPE dataset.\n\nkerenSPE &lt;- kerenSPE[,kerenSPE$imageID %in% c(\"5\", \"6\")]\n\nkerenSPE &lt;- lisaClust(kerenSPE,\n  k = 5\n)\n\nGenerating local L-curves.\n\n\nThese regions are stored in colData and can be extracted.\n\ncolData(kerenSPE)[, c(\"imageID\", \"region\")] |&gt;\n  head(20)\n\nDataFrame with 20 rows and 2 columns\n          imageID      region\n      &lt;character&gt; &lt;character&gt;\n21154           5    region_4\n21155           5    region_4\n21156           5    region_4\n21157           5    region_3\n21158           5    region_3\n...           ...         ...\n21169           5    region_3\n21170           5    region_3\n21171           5    region_1\n21172           5    region_3\n21173           5    region_1",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Cellular niches</span>"
    ]
  },
  {
    "objectID": "06-cellular_niches.html#examine-cell-type-enrichment",
    "href": "06-cellular_niches.html#examine-cell-type-enrichment",
    "title": "6  Cellular niches",
    "section": "9.3 Examine cell type enrichment",
    "text": "9.3 Examine cell type enrichment\nlisaClust also provides a convenient function, regionMap, for examining which cell types are located in which regions. In this example, we use this to check which cell types appear more frequently in each region than expected by chance.\nHere, we clearly see that healthy epithelial and mesenchymal tissue are highly concentrated in region 1, immune cells are concentrated in regions 2 and 4, whilst tumour cells are concentrated in region 3.\nWe can further segregate these cells by increasing the number of clusters, i.e., increasing the parameter k = in the lisaClust() function. For the purposes of demonstration, let’s take a look at the hatchingPlot of these regions.\n\nregionMap(kerenSPE,\n  type = \"bubble\"\n)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Cellular niches</span>"
    ]
  },
  {
    "objectID": "06-cellular_niches.html#plot-identified-regions-1",
    "href": "06-cellular_niches.html#plot-identified-regions-1",
    "title": "6  Cellular niches",
    "section": "9.4 Plot identified regions",
    "text": "9.4 Plot identified regions\nFinally, we can use hatchingPlot to construct a ggplot object where the regions are marked by different hatching patterns. This allows us to visualize the 5 regions and 17 cell-types simultaneously.\n\nhatchingPlot(kerenSPE, nbp = 300)\n\nConcave windows are temperamental. Try choosing values of window.length &gt; and &lt; 1 if you have problems.\n\n\nWarning in split.default(x = seq_len(nrow(x)), f = f, drop = drop, ...): data\nlength is not a multiple of split variable\nWarning in split.default(x = seq_len(nrow(x)), f = f, drop = drop, ...): data\nlength is not a multiple of split variable",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Cellular niches</span>"
    ]
  },
  {
    "objectID": "04-cell_annotation.html#fusesom",
    "href": "04-cell_annotation.html#fusesom",
    "title": "4  Cell Annotation",
    "section": "4.2 FuseSOM",
    "text": "4.2 FuseSOM\nA correlation based multiview self organizing map for the characterization of cell types (FuseSOM) is a tool for unsupervised clustering. FuseSOM is robust and achieves high accuracy by combining a Self Organizing Map architecture and a Multiview integration of correlation based metrics to cluster highly multiplexed in situ imaging cytometry assays. The FuseSOM pipeline has been streamlined and accepts currently used data structures including SingleCellExperiment and SpatialExperiment objects as well as DataFrames.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Cell Annotation</span>"
    ]
  },
  {
    "objectID": "04-cell_annotation.html#fusesom-matrix-input",
    "href": "04-cell_annotation.html#fusesom-matrix-input",
    "title": "4  Cell Annotation",
    "section": "4.3 FuseSOM Matrix Input",
    "text": "4.3 FuseSOM Matrix Input\nIf you have a matrix containing expression data that was QCed and normalised by some other tool, the next step is to run the FuseSOM algorithm.This can be done by calling the runFuseSOM() function which takes in the matrix of interest where the columns are markers and the rows are observations, the makers of interest (if this is not provided, it is assumed that all columns are markers), and the number of clusters.\n\n# load FuseSOM\nlibrary(FuseSOM)\n\nNext we will load in the Risom et al dataset and run it through the FuseSOM pipeline. This dataset profiles the spatial landscape of ductal carcinoma in situ (DCIS), which is a pre-invasive lesion that is thought to be a precursor to invasive breast cancer (IBC). The key conclusion of this manuscript (amongst others) is that spatial information about cells can be used to predict disease progression in patients.We will also be using the markers used in the original study.\n\n# load in the data\ndata(\"risom_dat\")\n\n# define the markers of interest\nrisomMarkers &lt;- c('CD45','SMA','CK7','CK5','VIM','CD31','PanKRT','ECAD',\n                   'Tryptase','MPO','CD20','CD3','CD8','CD4','CD14','CD68','FAP',\n                   'CD36','CD11c','HLADRDPDQ','P63','CD44')\n\n# we will be using the manual_gating_phenotype as the true cell type to gauge \n# performance\nnames(risom_dat)[names(risom_dat) == 'manual_gating_phenotype'] &lt;- 'CellType'\n\nNow that we have loaded the data and define the markers of interest. We can run the FuseSOM algorithm. We have provided a function runFuseSOM that runs the pipeline from top to bottom and returns the cluster labels as well as the Self Organizing Map model.\n\nrisomRes &lt;- runFuseSOM(data = risom_dat, markers = risomMarkers, \n                        numClusters = 23)\n\nYou have provided a dataset of class data.frame\n\n\nEverything looks good. Now running the FuseSOM algorithm\n\n\nNow Generating the Self Organizing Map Grid\n\n\nOptimal Grid Size is: 8\n\n\nNow Running the Self Organizing Map Model\n\n\nNow Clustering the Prototypes\n\n\nLoading required namespace: fastcluster\n\n\nNow Mapping Clusters to the Original Data\n\n\nThe Prototypes have been Clustered and Mapped Successfully\n\n\nThe FuseSOM algorithm has completed successfully\n\n\nLets look at the distribution of the clusters.\n\n# get the distribution of the clusters\ntable(risomRes$clusters)/sum(table(risomRes$clusters))\n\n\n  cluster_1  cluster_10  cluster_11  cluster_12  cluster_13  cluster_14 \n0.323602021 0.035968538 0.005439775 0.021443334 0.061100586 0.026596050 \n cluster_15  cluster_16  cluster_17  cluster_18  cluster_19   cluster_2 \n0.020582156 0.032624297 0.024931106 0.076128143 0.015802618 0.014927087 \n cluster_20  cluster_21  cluster_22  cluster_23   cluster_3   cluster_4 \n0.049962682 0.009185900 0.051771156 0.066913538 0.004923068 0.014108968 \n  cluster_5   cluster_6   cluster_7   cluster_8   cluster_9 \n0.040776783 0.064444827 0.020854863 0.010032725 0.007879780 \n\n\nLooks like cluster_1 has about \\(32\\%\\) of the cells which is interesting. Next, lets generate a heatmap of the marker expression for each cluster.\n\nrisomHeat &lt;- FuseSOM::markerHeatmap(data = risom_dat, markers = risomMarkers,\n                            clusters = risomRes$clusters, clusterMarkers = TRUE)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Cell Annotation</span>"
    ]
  },
  {
    "objectID": "04-cell_annotation.html#using-fusesom-to-estimate-the-number-of-clusters",
    "href": "04-cell_annotation.html#using-fusesom-to-estimate-the-number-of-clusters",
    "title": "4  Cell Annotation",
    "section": "4.4 Using FuseSOM to estimate the number of clusters",
    "text": "4.4 Using FuseSOM to estimate the number of clusters\nFuseSOM also provides functionality for estimating the number of clusters in a dataset using three classes of methods including:\n\nDiscriminant based method.\n\nA method developed in house based on discriminant based maximum clusterability projection pursuit\n\nDistance based methods which includes:\n\nThe Gap Statistic\nThe Jump Statistic\nThe Slope Statistic\nThe Within Cluster Dissimilarity Statistic\nThe Silhouette Statistic\n\n\nWe can estimate the number of clusters using the estimateNumCluster. Run help(estimateNumCluster) to see it’s complete functionality.\n\n# lets estimate the number of clusters using all the methods\n# original clustering has 23 clusters so we will set kseq from 2:25\n# we pass it the som model generated in the previous step\nrisomKest &lt;- estimateNumCluster(data = risomRes$model, kSeq = 2:25, \n                                  method = c(\"Discriminant\", \"Distance\"))\n\nNow Computing the Number of Clusters using Discriminant Analysis\n\n\nNow Computing The Number Of Clusters Using Distance Analysis\n\n\nWe can then use this result to determine the best number of clusters for this dataset based on the different metrics. The FuseSOM package provides a plotting function (optiPlot) which generates an elbow plot with the optimal value for the number of clusters for the distance based methods. See below\n\n# what is the best number of clusters determined by the discriminant method?\n# optimal number of clusters according to the discriminant method is 7\nrisomKest$Discriminant \n\n[1] 8\n\n# we can plot the results using the optiplot function\npSlope &lt;- optiPlot(risomKest, method = 'slope')\npSlope\n\n\n\n\n\n\n\npJump &lt;- optiPlot(risomKest, method = 'jump')\npJump\n\n\n\n\n\n\n\npWcd &lt;- optiPlot(risomKest, method = 'wcd')\npWcd\n\n\n\n\n\n\n\npGap &lt;- optiPlot(risomKest, method = 'gap')\npGap\n\n\n\n\n\n\n\npSil &lt;- optiPlot(risomKest, method = 'silhouette')\npSil\n\n\n\n\n\n\n\n\nFrom the plots, we see that the Jump statistics almost perfectly capture the number of clusters. The Gap method is a close second with \\(15\\) clusters. All the other methods significantly underestimates the number of clusters.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Cell Annotation</span>"
    ]
  },
  {
    "objectID": "04-cell_annotation.html#fusesom-sinlge-cell-epxeriment-object-as-input.",
    "href": "04-cell_annotation.html#fusesom-sinlge-cell-epxeriment-object-as-input.",
    "title": "4  Cell Annotation",
    "section": "4.5 FuseSOM Sinlge Cell Epxeriment object as input.",
    "text": "4.5 FuseSOM Sinlge Cell Epxeriment object as input.\nThe FuseSOM algorithm is also equipped to take in a SingleCellExperiment object as input. The results of the pipeline will be written to either the metada or the colData fields. See below.\nFirst we create a SingleCellExperiment object\n\nlibrary(SingleCellExperiment)\n\n# create a singelcellexperiment object\ncolDat &lt;- risom_dat[, setdiff(colnames(risom_dat), risomMarkers)]\nsce &lt;- SingleCellExperiment(assays = list(counts = t(risom_dat)),\n                                 colData = colDat)\n\nsce\n\nclass: SingleCellExperiment \ndim: 23 69672 \nmetadata(0):\nassays(1): counts\nrownames(23): CD45 SMA ... CD44 CellType\nrowData names(0):\ncolnames: NULL\ncolData names(1): X\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\n\n\nNext we pass it to the runFuseSOM() function. Here, we can provide the assay in which the data is stored and what name to store the clusters under in the colData section. Note that the Self Organizing Map that is generated will be stored in the metadata field.\n\nrisomRessce &lt;- runFuseSOM(sce, markers = risomMarkers, assay = 'counts', \n                      numClusters = 23, verbose = FALSE)\n\nYou have provided a dataset of class SingleCellExperiment\n\n\nEverything looks good. Now running the FuseSOM algorithm\n\n\nNow Generating the Self Organizing Map Grid\n\n\nOptimal Grid Size is: 8\n\n\nNow Running the Self Organizing Map Model\n\n\nNow Clustering the Prototypes\n\n\nNow Mapping Clusters to the Original Data\n\n\nThe Prototypes have been Clustered and Mapped Successfully\n\n\nThe FuseSOM algorithm has completed successfully\n\ncolnames(colData(risomRessce))\n\n[1] \"X\"        \"clusters\"\n\nnames(metadata(risomRessce))\n\n[1] \"SOM\"\n\n\nNotice how the there is now a clusters column in the colData and SOM field in the metadata. You can run this function again with a new set of cluster number. If you provide a new name for the clusters, it will be stored under that new column, else, it will overwrite the current clusters column. Running it again on the same object will overwrite the SOM field in the metadata.\nJust like before, lets plot the heatmap of the resulting clusters across all markers.\n\ndata &lt;- risom_dat[, risomMarkers] # get the original data used\nclusters &lt;- colData(risomRessce)$clusters # extract the clusters from the sce object\n# generate the heatmap\nrisomHeatsce &lt;- markerHeatmap(data = risom_dat, markers = risomMarkers,\n                            clusters = clusters, clusterMarkers = TRUE)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Cell Annotation</span>"
    ]
  },
  {
    "objectID": "04-cell_annotation.html#using-fusesom-to-estimate-the-number-of-clusters-for-single-cell-experiment-objects",
    "href": "04-cell_annotation.html#using-fusesom-to-estimate-the-number-of-clusters-for-single-cell-experiment-objects",
    "title": "4  Cell Annotation",
    "section": "4.6 Using FuseSOM to estimate the number of clusters for single cell experiment objects",
    "text": "4.6 Using FuseSOM to estimate the number of clusters for single cell experiment objects\nJust like before, we can estimate the number of clusters\n\n# lets estimate the number of clusters using all the methods\n# original clustering has 23 clusters so we will set kseq from 2:25\n# now we pass it a singlecellexperiment object instead of the som model as before\n# this will return a singelcellexperiment object where the metatdata contains the\n# cluster estimation information\nrisomRessce &lt;- estimateNumCluster(data = risomRessce, kSeq = 2:25, \n                                  method = c(\"Discriminant\", \"Distance\"))\n\nYou have provided a dataset of class: SingleCellExperiment\n\n\nNow Computing the Number of Clusters using Discriminant Analysis\n\n\nNow Computing The Number Of Clusters Using Distance Analysis\n\nnames(metadata(risomRessce))\n\n[1] \"SOM\"               \"clusterEstimation\"\n\n\nNotice how the metadata now contains a clusterEstimation field which holds the results from the estimateNumCluster() function\nWe can assess the results in a similar fashion as before\n\n# what is the best number of clusters determined by the discriminant method?\n# optimal number of clusters according to the discriminant method is 8\nmetadata(risomRessce)$clusterEstimation$Discriminant \n\n[1] 10\n\n# we can plot the results using the optiplot function\npSlope &lt;- optiPlot(risomRessce, method = 'slope')\n\nYou have provided a dataset of class: SingleCellExperiment\n\npSlope\n\n\n\n\n\n\n\npJump &lt;- optiPlot(risomRessce, method = 'jump')\n\nYou have provided a dataset of class: SingleCellExperiment\n\npJump\n\n\n\n\n\n\n\npWcd &lt;- optiPlot(risomRessce, method = 'wcd')\n\nYou have provided a dataset of class: SingleCellExperiment\n\npWcd\n\n\n\n\n\n\n\npGap &lt;- optiPlot(risomRessce, method = 'gap')\n\nYou have provided a dataset of class: SingleCellExperiment\n\npGap\n\n\n\n\n\n\n\npSil &lt;- optiPlot(risomRessce, method = 'silhouette')\n\nYou have provided a dataset of class: SingleCellExperiment\n\npSil\n\n\n\n\n\n\n\n\nAgain, we see that the Jump statistics almost perfectly capture the number of clusters. The Gap method is a close second with \\(15\\) clusters. All the other methods significantly underestimates the number of clusters.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Cell Annotation</span>"
    ]
  },
  {
    "objectID": "05-cell_localisation.html#spicyr",
    "href": "05-cell_localisation.html#spicyr",
    "title": "5  Cell localisation",
    "section": "",
    "text": "5.1.1 Linear modelling\nTo investigate changes in localisation between two different cell types, we measure the level of localisation between two cell types by modelling with the L-function. The L-function is a variance-stabilised K-function given by the equation\n\\[\n\\widehat{L_{ij}} (r) = \\sqrt{\\frac{\\widehat{K_{ij}}(r)}{\\pi}}\n\\]\nwith \\(\\widehat{K_{ij}}\\) defined as\n\\[\n\\widehat{K_{ij}} (r) = \\frac{|W|}{n_i n_j} \\sum_{n_i} \\sum_{n_j} 1 \\{d_{ij} \\leq r \\} e_{ij} (r)\n\\]\nwhere \\(\\widehat{K_{ij}}\\) summarises the degree of co-localisation of cell type \\(j\\) with cell type \\(i\\), \\(n_i\\) and \\(n_j\\) are the number of cells of type \\(i\\) and \\(j\\), \\(|W|\\) is the image area, \\(d_{ij}\\) is the distance between two cells and \\(e_{ij} (r)\\) is an edge correcting factor.\nSpecifically, the mean difference between the experimental function and the theoretical function is used as a measure for the level of localisation, defined as\n\\[\nu = \\sum_{r' = r_{\\text{min}}}^{r_{\\text{max}}} \\widehat L_{ij, \\text{Experimental}} (r') - \\widehat L_{ij, \\text{Poisson}} (r')\n\\]\nwhere \\(u\\) is the sum is taken over a discrete range of \\(r\\) between \\(r_{\\text{min}}\\) and \\(r_{\\text{max}}\\). Differences of the statistic \\(u\\) between two conditions is modelled using a weighted linear model.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Cell localisation</span>"
    ]
  },
  {
    "objectID": "06-cellular_niches.html#why-look-at-cellular-niches",
    "href": "06-cellular_niches.html#why-look-at-cellular-niches",
    "title": "6  Cellular niches",
    "section": "6.2 Why look at cellular niches?",
    "text": "6.2 Why look at cellular niches?\nTo illustrate our lisaClust framework, we consider a very simple toy example where two cell-types are completely separated spatially. We simulate data for two different images.\n\nset.seed(51773)\nx &lt;- round(c(\n  runif(200), runif(200) + 1, runif(200) + 2, runif(200) + 3,\n  runif(200) + 3, runif(200) + 2, runif(200) + 1, runif(200)\n), 4) * 100\ny &lt;- round(c(\n  runif(200), runif(200) + 1, runif(200) + 2, runif(200) + 3,\n  runif(200), runif(200) + 1, runif(200) + 2, runif(200) + 3\n), 4) * 100\ncellType &lt;- factor(paste(\"c\", rep(rep(c(1:2), rep(200, 2)), 4), sep = \"\"))\nimageID &lt;- rep(c(\"s1\", \"s2\"), c(800, 800))\n\ncells &lt;- data.frame(x, y, cellType, imageID)\n\nggplot(cells, aes(x, y, colour = cellType)) +\n  geom_point() +\n  facet_wrap(~imageID) +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n6.2.1 Create Single Cell Experiment object\nFirst we store our data in a SingleCellExperiment object.\n\nSCE &lt;- SingleCellExperiment(colData = cells)\nSCE\n\nclass: SingleCellExperiment \ndim: 0 1600 \nmetadata(0):\nassays(0):\nrownames: NULL\nrowData names(0):\ncolnames: NULL\ncolData names(4): x y cellType imageID\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\n\n\n\n\n6.2.2 Running lisaCLust\nWe can then use the convenience function lisaClust to simultaneously calculate local indicators of spatial association (LISA) functions and perform k-means clustering. The number of clusters can be specified with the k = parameter. In the example below, we’ve chosen k = 2, resulting in a total of 2 clusters. The cell type column can be specified using the cellType = argument. By default, lisaClust uses the column named cellType.\nThe clusters identified by lisaClust are stored in colData of the SingleCellExperiment object as a new column called regions.\n\nSCE &lt;- lisaClust(SCE, k = 2)\n\nGenerating local L-curves.\n\ncolData(SCE) |&gt; head()\n\nDataFrame with 6 rows and 5 columns\n          x         y cellType     imageID      region\n  &lt;numeric&gt; &lt;numeric&gt; &lt;factor&gt; &lt;character&gt; &lt;character&gt;\n1     36.72     38.58       c1          s1    region_2\n2     61.38     41.29       c1          s1    region_2\n3     33.59     80.98       c1          s1    region_2\n4     50.17     64.91       c1          s1    region_2\n5     82.93     35.60       c1          s1    region_2\n6     83.13      2.69       c1          s1    region_2\n\n\n\n\n6.2.3 Plot identified regions\nlisaClust also provides the convenient hatchingPlot function to visualise the different regions that have been demarcated by the clustering. hatchingPlot outputs a ggplot object where the regions are marked by different hatching patterns. In a real biological dataset, this allows us to plot both regions and cell-types on the same visualization.\nIn the example below, we can visualise our stimulated data where our 2 cell types have been separated neatly into 2 distinct regions based on which cell type each region is dominated by. region_2 is dominated by the red cell type c1, and region_1 is dominated by the blue cell type c2.\n\nhatchingPlot(SCE, useImages = c(\"s1\", \"s2\"))\n\nConcave windows are temperamental. Try choosing values of window.length &gt; and &lt; 1 if you have problems.\nConcave windows are temperamental. Try choosing values of window.length &gt; and &lt; 1 if you have problems.\n\n\n\n\n\n\n\n\n\n\n\n6.2.4 Using other clustering methods.\nWhile the lisaClust function is convenient, we have not implemented an exhaustive suite of clustering methods as it is very easy to do this yourself. There are just two simple steps.\n\n\n6.2.5 Generate LISA curves\nWe can calculate local indicators of spatial association (LISA) functions using the lisa function. Here the LISA curves are a localised summary of an L-function from a Poisson point process model. The radii that will be calculated over can be set with Rs.\n\nlisaCurves &lt;- lisa(SCE, Rs = c(20, 50, 100))\n\nGenerating local L-curves.\n\nhead(lisaCurves)\n\n          20_c1     20_c2     50_c1     50_c2    100_c1     100_c2\ncell_1 5.556700 -2.764143 15.631209 -6.910357 11.733097  -9.198914\ncell_2 4.833149 -2.764143 13.940407 -6.910357  9.532662  -8.543440\ncell_3 5.918476 -2.764143  9.008588 -6.910357  9.157887  -7.813862\ncell_4 4.109597 -2.764143 11.907928 -6.910357  8.404425  -8.140036\ncell_5 3.024270 -2.764143 10.159278 -6.910357  9.006286  -8.283564\ncell_6 7.986742 -2.764143  8.675070 -6.910357 12.859615 -13.820714\n\n\n\n\n6.2.6 Perform some clustering\nThe LISA curves can then be used to cluster the cells. Here we use k-means clustering. However, other clustering methods like SOM could also be used. We can store these cell clusters or cell “regions” in our SingleCellExperiment object.\n\n# Custom clustering algorithm\nkM &lt;- kmeans(lisaCurves, 2)\n\n# Storing clusters into colData\ncolData(SCE)$custom_region &lt;- paste(\"region\", kM$cluster, sep = \"_\")\ncolData(SCE) |&gt; head()\n\nDataFrame with 6 rows and 6 columns\n          x         y cellType     imageID      region custom_region\n  &lt;numeric&gt; &lt;numeric&gt; &lt;factor&gt; &lt;character&gt; &lt;character&gt;   &lt;character&gt;\n1     36.72     38.58       c1          s1    region_2      region_2\n2     61.38     41.29       c1          s1    region_2      region_2\n3     33.59     80.98       c1          s1    region_2      region_2\n4     50.17     64.91       c1          s1    region_2      region_2\n5     82.93     35.60       c1          s1    region_2      region_2\n6     83.13      2.69       c1          s1    region_2      region_2\n\n\n\n\n6.2.7 Case study: Keren\nWe will start by reading in the data from the SpatialDatasets package as a SingleCellExperiment object. Here the data is in a format consistent with that outputted by CellProfiler.\n\nkerenSPE &lt;- SpatialDatasets::spe_Keren_2018()\n\nCannot connect to ExperimentHub server, using 'localHub=TRUE' instead\n\n\nWarning: download failed\n  web resource path: 'https://experimenthub.bioconductor.org/metadata/experimenthub.sqlite3'\n  local file path: '/enna/users/ststaff/alexq/.cache/R/ExperimentHub/file25c67b67b45560'\n  reason: Internal Server Error (HTTP 500).\n\n\nWarning: bfcdownload() failed\n  rid: BFC1\n  file: 'https://experimenthub.bioconductor.org/metadata/experimenthub.sqlite3'\n  reason: download failed\n\n\nWarning: Could not check database for updates.\n  Database source currently unreachable.\n  This should only be a temporary interruption. \n  Using previously cached version.\n\n\nsee ?SpatialDatasets and browseVignettes('SpatialDatasets') for documentation\n\n\nloading from cache\n\n\n\n6.2.7.1 Generate LISA curves\nThis data includes annotation of the cell-types of each cell. Hence, we can move directly to performing k-means clustering on the local indicators of spatial association (LISA) functions using the lisaClust function, remembering to specify the imageID, cellType, and spatialCoords columns in colData. For the purpose of demonstration, we will be using only images 5 and 6 of the kerenSPE dataset.\n\nkerenSPE &lt;- kerenSPE[,kerenSPE$imageID %in% c(\"5\", \"6\")]\n\nkerenSPE &lt;- lisaClust(kerenSPE,\n  k = 5\n)\n\nGenerating local L-curves.\n\n\nThese regions are stored in colData and can be extracted.\n\ncolData(kerenSPE)[, c(\"imageID\", \"region\")] |&gt;\n  head(20)\n\nDataFrame with 20 rows and 2 columns\n          imageID      region\n      &lt;character&gt; &lt;character&gt;\n21154           5    region_4\n21155           5    region_4\n21156           5    region_4\n21157           5    region_3\n21158           5    region_3\n...           ...         ...\n21169           5    region_3\n21170           5    region_3\n21171           5    region_1\n21172           5    region_3\n21173           5    region_1\n\n\n\n\n6.2.7.2 Examine cell type enrichment\nlisaClust also provides a convenient function, regionMap, for examining which cell types are located in which regions. In this example, we use this to check which cell types appear more frequently in each region than expected by chance.\nHere, we clearly see that healthy epithelial and mesenchymal tissue are highly concentrated in region 1, immune cells are concentrated in regions 2 and 4, whilst tumour cells are concentrated in region 3.\nWe can further segregate these cells by increasing the number of clusters, i.e., increasing the parameter k = in the lisaClust() function. For the purposes of demonstration, let’s take a look at the hatchingPlot of these regions.\n\nregionMap(kerenSPE,\n  type = \"bubble\"\n)\n\n\n\n\n\n\n\n\n\n\n6.2.7.3 Plot identified regions\nFinally, we can use hatchingPlot to construct a ggplot object where the regions are marked by different hatching patterns. This allows us to visualize the 5 regions and 17 cell-types simultaneously.\n\nhatchingPlot(kerenSPE, nbp = 300)\n\nConcave windows are temperamental. Try choosing values of window.length &gt; and &lt; 1 if you have problems.\n\n\nWarning in split.default(x = seq_len(nrow(x)), f = f, drop = drop, ...): data\nlength is not a multiple of split variable\nWarning in split.default(x = seq_len(nrow(x)), f = f, drop = drop, ...): data\nlength is not a multiple of split variable",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Cellular niches</span>"
    ]
  },
  {
    "objectID": "02-processing.html#simpleseg",
    "href": "02-processing.html#simpleseg",
    "title": "2  Processing",
    "section": "2.2 simpleSeg",
    "text": "2.2 simpleSeg\nIf your images are stored in a list or CytoImageList they can be segmented with a simple call to simpleSeg(). To summarise, simpleSeg() is an R implementation of a simple segmentation technique which traces out the nuclei using a specified channel using nucleus then dilates around the traced nuclei by a specified amount using discSize. The nucleus can be traced out using either one specified channel, or by using the principal components of all channels most correlated to the specified nuclear channel by setting pca = TRUE.\nIn the particular example below, we have asked simpleSeg to do the following:\nBy setting nucleus = c(\"HH3\"), we’ve asked simpleSeg to trace out the nuclei signal in the images using the HH3 channel. By setting pca = TRUE, simpleSeg segments out the nuclei mask using a principal component analysis of all channels and using the principal components most aligned with the nuclei channel, in this case, HH3. By setting cellBody = \"dilate\", simpleSeg uses a dilation strategy of segmentation, expanding out from the nucleus by a specified discSize. By setting discSize = 3, simpleSeg dilates out from the nucleus by 3 pixels. By setting sizeSelection = 20, simpleSeg ensures that only cells with a size greater than 20 pixels will be used. By setting transform = \"sqrt\", simpleSeg square root transforms each of the channels prior to segmentation. By setting tissue = c(\"panCK\", \"CD45\", \"HH3\"), we specify a tissue mask which simpleSeg uses, filtering out all background noise outside the tissue mask. This is important as these are tumour cores, wand hence circular, so we’d want to ignore background noise which happens outside of the tumour core.\nThere are many other parameters that can be specified in simpleSeg (smooth, watershed, tolerance, and ext), and we encourage the user to select the best parameters which suit their biological context.\n\nmasks &lt;- simpleSeg(images,\n                   nucleus = c(\"HH3\"),\n                   pca = TRUE,\n                   cellBody = \"dilate\",\n                   discSize = 3,\n                   sizeSelection = 20,\n                   transform = \"sqrt\",\n                   tissue = c(\"panCK\", \"CD45\", \"HH3\"),\n                   cores = nCores\n                   )\n\n\n2.2.1 Visualise separation\nThe display and colorLabels functions in EBImage make it very easy to examine the performance of the cell segmentation. The great thing about display is that if used in an interactive session it is very easy to zoom in and out of the image.\n\nEBImage::display(colorLabels(masks[[1]]))\n\n\n\n\n\n\n\n\n\n\n2.2.2 Visualise outlines\nThe plotPixels function in cytomapper makes it easy to overlay the mask on top of the nucleus intensity marker to see how well our segmentation process has performed. Here we can see that the segmentation appears to be performing reasonably.\nIf you see over or under-segmentation of your images, discSize is a key parameter in simpleSeg() for optimising the size of the dilation disc after segmenting out the nuclei.\n\nplotPixels(image = images[\"F3\"], \n           mask = masks[\"F3\"],\n           img_id = \"imageID\", \n           colour_by = c(\"HH3\"), \n           display = \"single\",\n           colour = list(HH3 = c(\"black\",\"blue\")),\n           legend = NULL,\n           bcg = list(\n             HH3 = c(1, 1, 2)\n           ))\n\n\n\n\n\n\n\n\nIf you wish to visualise multiple markers instead of just the HH3 marker and see how the segmentation mask performs, this can also be done. Here, we can see that our segmentation mask has done a good job of capturing the CD31 signal, but perhaps not such a good job of capturing the FXIIIA signal, which often lies outside of our dilated nuclear mask. This could suggest that we might need to increase the discSize of our dilation.\n\nplotPixels(image = images[\"F3\"], \n           mask = masks[\"F3\"],\n           img_id = \"imageID\", \n           colour_by = c(\"HH3\", \"CD31\", \"FX111A\"), \n           display = \"single\",\n           colour = list(HH3 = c(\"black\",\"blue\"),\n                         CD31 = c(\"black\", \"red\"),\n                         FX111A = c(\"black\", \"green\") ),\n           legend = NULL,\n           bcg = list(\n             HH3 = c(1, 1, 2),\n             CD31 = c(0, 1, 2),\n             FX111A = c(0, 1, 1.5)\n           ))",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Processing</span>"
    ]
  }
]