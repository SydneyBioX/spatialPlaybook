[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "spicyPlayBook",
    "section": "",
    "text": "Overview",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "index.html#welcome",
    "href": "index.html#welcome",
    "title": "spicyPlayBook",
    "section": "Welcome!",
    "text": "Welcome!\n\nRecent advances in highly multiplexed cell imaging technologies such as PhenoCycler, IMC, CosMx, Xenium, and MERFISH (and many more) have fundamentally revolutionized our ability to observe complex cellular relationships in tissue. Where previous immunohistochemistry protocols only allowed the visualization of cells that could be characterized by two or three surface proteins, cutting-edge technologies characterize cells with upwards of 50 proteins or 1000s of RNA in situ. These technologies enable precise classification of cell sub-types and provide an unprecedented depiction of cellular heterogeneity in a tissue environment. These technical developments have necessitated the development of a variety of new analytical approaches that are required to harness these new imaging technologies. On this website we will demonstrate how packages in scdney can be used to provide new insights into complex biological systems and diseases.",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "index.html#packages",
    "href": "index.html#packages",
    "title": "spicyPlayBook",
    "section": "Packages",
    "text": "Packages\n\n\n\n\n\n    \n\n\nMoleculeExperiment\n\nMoleculeExperiment contains functions to create and work with objects from the new MoleculeExperiment class. We introduce this class for analysing molecule-based spatial transcriptomics data (e.g., Xenium by 10X, Cosmx SMI by Nanostring, and Merscope by Vizgen). This allows researchers to analyse spatial transcriptomics data at the molecule level, and to have standardised data formats accross vendors.\n\n\nPeters Couto B, Robertson N, Patrick E, Ghazanfar S (2024). MoleculeExperiment: Prioritising a molecule-level storage of Spatial Transcriptomics Data. R package version 1.6.0.\n\n\n\n\nsimpleSeg\n\nImage segmentation is the process of identifying the borders of individual objects (in this case cells) within an image. This allows for the features of cells such as marker expression and morphology to be extracted, stored and analysed. simpleSeg provides functionality for user friendly, watershed based segmentation on multiplexed cellular images in R based on the intensity of user specified protein marker channels. simpleSeg can also be used for the normalization of single cell data obtained from multiple images.\n\n\nCanete N, Nicholls A, Patrick E (2024). simpleSeg: A package to perform simple cell segmentation. R package version 1.8.0.\n\n\n\n\nscMerge\n\nLike all gene expression data, single-cell data suffers from batch effects and other unwanted variations that makes accurate biological interpretations difficult. The scMerge method leverages factor analysis, stably expressed genes (SEGs) and (pseudo-) replicates to remove unwanted variations and merge multiple single-cell data. This package contains all the necessary functions in the scMerge pipeline, including the identification of SEGs, replication-identification methods, and merging of single-cell data.\n\n\nLin Y, Ghazanfar S, Wang K, Gagnon-Bartsch J, Lo K, Su X, Han Z, Ormerod J, Speed T, Yang P, Yang J (2019). “scMerge leverages factor analysis, stable expression, and pseudoreplication to merge multiple single-cell RNA-seq datasets.” Proceedings of the National Academy of Sciences. doi:10.1073/pnas.1820006116.\n\n\n\n\nFuseSOM\n\nA correlation-based multiview self-organizing map for the characterization of cell types in highly multiplexed in situ imaging cytometry assays (FuseSOM) is a tool for unsupervised clustering. FuseSOM is robust and achieves high accuracy by combining a Self Organizing Map architecture and a Multiview integration of correlation based metrics. This allows FuseSOM to cluster highly multiplexed in situ imaging cytometry assays.\n\n&lt;0-length citation&gt;\n\n\n\ntreekoR\n\ntreekoR is a novel framework that aims to utilise the hierarchical nature of single cell cytometry data to find robust and interpretable associations between cell subsets and patient clinical end points. These associations are aimed to recapitulate the nested proportions prevalent in workflows inovlving manual gating, which are often overlooked in workflows using automatic clustering to identify cell populations. We developed treekoR to: Derive a hierarchical tree structure of cell clusters; quantify a cell types as a proportion relative to all cells in a sample (%total), and, as the proportion relative to a parent population (%parent); perform significance testing using the calculated proportions; and provide an interactive html visualisation to help highlight key results.\n\n\nChan A (2024). treekoR: Cytometry Cluster Hierarchy and Cellular-to-phenotype Associations. R package version 1.14.0.\n\n\n\n\nscFeatures\n\nscFeatures constructs multi-view representations of single-cell and spatial data. scFeatures is a tool that generates multi-view representations of single-cell and spatial data through the construction of a total of 17 feature types. These features can then be used for a variety of analyses using other software in Biocondutor.\n\n\nCao,Y., Lin,Y., Patrick,E., Yang,P., Yang,J.Y.H. & (2022). “scFeatures: multi-view representations of single-cell and spatial data for disease outcome prediction.” Bioinformatics, 38(20), 4745-4753. ISSN 1367-4803, doi:10.1093/bioinformatics/btac590.\n\n\n\n\nscHOT\n\nSingle cell Higher Order Testing (scHOT) is an R package that facilitates testing changes in higher order structure of gene expression along either a developmental trajectory or across space. scHOT is general and modular in nature, can be run in multiple data contexts such as along a continuous trajectory, between discrete groups, and over spatial orientations; as well as accommodate any higher order measurement such as variability or correlation. scHOT meaningfully adds to first order effect testing, such as differential expression, and provides a framework for interrogating higher order interactions from single cell data.\n\n\nGhazanfar S, Lin Y (2024). scHOT: single-cell higher order testing. R package version 1.18.0.\n\n\n\n\nspicyR\n\nThe spicyR package provides a framework for performing inference on changes in spatial relationships between pairs of cell types for cell-resolution spatial omics technologies. spicyR consists of three primary steps: (i) summarizing the degree of spatial localization between pairs of cell types for each image; (ii) modelling the variability in localization summary statistics as a function of cell counts and (iii) testing for changes in spatial localizations associated with a response variable.\n\n\nCanete N, Iyengar S, Ormerod J, Baharlou H, Harman A, Patrick E (2022). “spicyR: spatial analysis of in situ cytometry data in R.” Bioinformatics, 38(11), 3099–3105. doi:10.1093/bioinformatics/btac268.\n\n\n\n\nStatial\n\nStatial is a suite of functions for identifying changes in cell state. The functionality provided by Statial provides robust quantification of cell type localisation which are invariant to changes in tissue structure. In addition to this Statial uncovers changes in marker expression associated with varying levels of localisation. These features can be used to explore how the structure and function of different cell types may be altered by the agents they are surrounded with.\n\n\nAmeen F, Robertson N, Lin D, Ghazanfar S, Patrick E (2024). “Kontextual: Reframing analysis of spatial omics data reveals consistent cell relationships across images.” bioRxiv. doi:10.1101/2024.09.03.611109.\n\n\n\n\nlisaClust\n\nlisaClust provides a series of functions to identify and visualise regions of tissue where spatial associations between cell-types is similar. This package can be used to provide a high-level summary of cell-type colocalization in multiplexed imaging data that has been segmented at a single-cell resolution.\n\n\nPatrick E, Canete N (2024). lisaClust: lisaClust: Clustering of Local Indicators of Spatial Association. R package version 1.14.4.\n\n\n\n\nClassifyR\n\nThe software formalises a framework for classification and survival model evaluation in R. There are four stages; Data transformation, feature selection, model training, and prediction. The requirements of variable types and variable order are fixed, but specialised variables for functions can also be provided. The framework is wrapped in a driver loop that reproducibly carries out a number of cross-validation schemes. Functions for differential mean, differential variability, and differential distribution are included. Additional functions may be developed by the user, by creating an interface to the framework.\n\n\nStrbenac D, Mann GJ, Ormerod JT, Yang JYH (2015). “ClassifyR: an R package for performance assessment of classification with applications to transcriptomics.” Bioinformatics, 31(11), 1851-1853.\n\n\nThis guide presents a comprehensive workflow for analysing spatial omics data, featuring examples sorted by different technologies as described below. The workflow covers cell segmentation, data normalisation, various tests of proportion and spatial localisation, microenvironment estimation and patient prediction. We encourage focusing on the biological questions these methods can address rather than the specific technologies used.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDisease\nTechnology\nTitle\nSegmentation\nAlignment\nClustering\nLocalisation\nMicroenvironments\nPatient Classification\n\n\n\n\n\nBreast cancer\nMIBI-TOF\nKeren_2018\n\n\n\nX\nX\nX\n\n\n\nBreast cancer\nMIBI-TOF\nRisom_2022\nX\nX\nX\nX\nX\nX\n\n\n\nMouse organogenesis\nseqFISH\nLohoff_2022\n\nX\n\nX",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "index.html#datasets",
    "href": "index.html#datasets",
    "title": "spicyPlayBook",
    "section": "Datasets",
    "text": "Datasets\nThrough the course of this spicyWorkBook, we will take advantage of several different spatial datasets that are publicly available. These datasets are all accessible within our SpatialDatasets package on bioconductor. We will demonstrate several questions that could be answered or explored for each of these datasets using the available information.\n\nSpatial Proteomics - MIBITOF\nMIBI-TOF (multiplexed ion beam imaging by time of flight) is an instrument that uses bright ion sources and orthogonal time-of-flight mass spectrometry to image metal-tagged antibodies at subcellular resolution in clinical tissue sections. It is capable of imaging approximately 40 labelled antibodies and image fields of about \\(1mm^2\\) at resolutions down to \\(260nm\\).\n\nTriple Negative Breast Cancer - Keren_2018\nThis study profiles 36 proteins in tissue samples from 41 patients with triple-negative breast cancer using MIBI-TOF. We will use this dataset to demonstrate the functionality of our Statial package, which allows us to identify changes in cell state that are related to the spatial localisation of cells.\n Keren et al. (2018). A Structured Tumor-Immune Microenvironment in Triple Negative Breast Cancer Revealed by Multiplexed Ion Beam Imaging. Cell, 174(6), 1373-1387.e1319. (DOI) \n\n\nDuctal carcinoma in situ - Risom_2022\nThis study uses MIBI-TOF to profile the spatial landscape of ductal carcinoma in situ (DCIS), a pre-invasive lesion believed to be a precursor to invasive breast cancer (IBC). A key conclusion of the manuscript is that spatial information about cells can be leveraged to predict disease progression in patients. We use the workflow described in this guide to reach a similar conclusion.\n Risom et al. (2022). Transition to invasive breast cancer is associated with progressive changes in the structure and composition of tumor stroma. Cell, 185(2), 299-310.e18 (DOI) \n\n\n\nSpatial Proteomics - CODEX\nCODEX (Co-detection by indexing) is a highly multiplexed tissue imaging technique that uses DNA-barcoded antibodies which are later revealed by fluorescent detector oligonucleotides. It can visualise up to 60 labelled antibodies at subcellular resolution.\n\nColorectal cancer - Schurch_2020\nA CODEX dataset which aimed to characterise the immune tumour microenvironment in advanced-stage colorectal cancer. The dataset consists of 35 advanced colorectal cancer patients, with 4 images per patient for a total of 140 images. Each image is marked with a 56-antibody panel to characterise a total of 24 distinct tumour and immune cell populations. Overall, the dataset contains 240,000 cells along with clinical information including patient tumour grade, tumour type, and patient survival.\n Schürch et al. (2020). Coordinated Cellular Neighborhoods Orchestrate Antitumoral Immunity at the Colorectal Cancer Invasive Front et al. (2018). A Coordinated Cellular Neighborhoods Orchestrate Antitumoral Immunity at the Colorectal Cancer Invasive Front. Cell, 182(5), 1341-1359.e19. (DOI) \n\n\n\nSpatial Proteomics - IMC\nIMC (Imaging Mass Cytometry) is an instrument that combines laser ablation with mass cytometry to image metal-tagged antibodies at subcellular resolution in clinical tissue sections. The datasets produced by IMC can image approximately 30–40 labeled antibodies, covering tissue areas of around \\(1mm^2\\) with a resolution down to \\(1 \\mu m\\).\n\nBreast cancer - Ali_2020\nAlso known as the METABRIC dataset, this 37-panel IMC dataset contains images of 456 primary invasive breast carcinoma patients obtained from 548 samples. Clinical variables in the dataset include age, chemotherapy (CT), radiotherapy (RT), hormone treatment (HT) indicators, estrogen receptor (ER) status, and gene expression markers (MKI67, EGFR, PGR, and ERBB2).\n Ali et al. (2020). Imaging mass cytometry and multiplatform genomics define the phenogenomic landscape of breast cancer. Nature Cancer, 1, 163-175. (DOI)\n\n\nHead and neck squamous cell carcinoma - Ferguson_2020\nThis study uses IMC to map the immune landscape and identify differences between high-risk primary head and neck cancer (HNcSCC) tumors that did not progress and those that developed metastases (progressing tumours). The key conclusion of this manuscript (amongst others) is that spatial information about cells and the immune environment can be used to predict primary tumour progression or metastases in patients. We will use our spicyWorkflow to reach a similar conclusion.\n Ferguson et al. (2022). High-Dimensional and Spatial Analysis Reveals Immune Landscape–Dependent Progression in Cutaneous Squamous Cell Carcinoma. Clinical Cancer Research, 28(21), 4677-4688. (DOI)\n\n\n\nSpatial Transcriptomics - seqFISH\nSeqFISH (sequential Fluorescence In Situ Hybridization) is a technology that enables the identification of thousands of molecules like RNA, DNA, and proteins directly in single cells with their spatial context preserved. seqFISH can multiplex over 10,000 molecules and integrate multiple modalities.\n\nMouse organogenesis - Lohoff_2022\nThis study uses seqFISH to spatially profile the expression of 387 genes in mouse embryos. A comprehensive spatially resolved map of gene expression was created by integrating the seqFISH data with existing scRNAseq data. This integration facilitated the exploration of cellular relationships across different regions of the embryo.\n Lohoff et al. (2022). Integration of spatial and single-cell transcriptomic data elucidates mouse organogenesis. Nature Biotechnology 40, 74–85 (DOI).",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "01-processing.html",
    "href": "01-processing.html",
    "title": "1  Processing",
    "section": "",
    "text": "1.1 Reading in images\nIn this section, we will describe how to read in and pre-process images obtained through various imaging technologies for downstream analysis.\nSteps:\nlibrary(cytomapper)\nlibrary(ggplot2)\nlibrary(simpleSeg)\nIt is convenient to set the number of cores for running code in parallel. Please choose a number that is appropriate for your resources. A minimum of 2 cores is suggested since running this workflow is rather computationally intensive.\nIf you would like to use parallel processing for the rest of the vignette, set the use_mc flag to TRUE.\nuse_mc &lt;- TRUE\n\nif (use_mc) {\n  nCores &lt;- max(parallel::detectCores()/2, 1)\n} else {\n  nCores &lt;- 2\n}\nBPPARAM &lt;- simpleSeg:::generateBPParam(nCores)\n\ntheme_set(theme_classic())\nWe will be using the Ferguson 2022 dataset to demonstrate how to perform pre-processing and cell segmentation. This dataset can be accessed through the SpatialDatasets package. The loadImages() function form the cytomapper package can be used to load all the TIFF images into a CytoImageList object and store the images as h5 file on-disk in a temporary directory using the h5FilesPath = HDF5Array::getHDF5DumpDir() parameter.\nWe will also assign the metadata columns of the CytoImageList object using the mcols() function.\npathToImages &lt;- SpatialDatasets::Ferguson_Images()\n\nsee ?SpatialDatasets and browseVignettes('SpatialDatasets') for documentation\n\n\nloading from cache\n\ntmp &lt;- tempfile()\nunzip(pathToImages, exdir = tmp)\n\n# Store images in a CytoImageList on_disk as h5 files to save memory.\nimages &lt;- cytomapper::loadImages(\n  tmp,\n  single_channel = TRUE,\n  on_disk = TRUE,\n  h5FilesPath = HDF5Array::getHDF5DumpDir(),\n  BPPARAM = BPPARAM\n)\n\nmcols(images) &lt;- S4Vectors::DataFrame(imageID = names(images))\nAs we’re reading the image channels directly from the names of the TIFF image, often these channel names will need to be cleaned for ease of downstream processing.\nThe channel names can be accessed from the CytoImageList object using the channelNames() function.\nchannelNames(images) &lt;- channelNames(images) |&gt;\n                          # Remove preceding letters\n                          sub(pattern = \".*_\", replacement = \"\", x = _) |&gt; \n                          # Remove the .ome\n                          sub(pattern = \".ome\", replacement = \"\", x = _)\nSimilarly, the image names will be taken from the folder name containing the individual TIFF images for each channel. These will often also need to be cleaned.\nsplit_names &lt;- function(x) {\n  sapply(strsplit(x, \"_\"), `[`, 3)\n}\n\nnames(images) &lt;- names(images) |&gt; split_names()\n\nmcols(images) &lt;- S4Vectors::DataFrame(imageID = names(images))",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Processing</span>"
    ]
  },
  {
    "objectID": "01-processing.html#cell-segmentation-with-simpleseg",
    "href": "01-processing.html#cell-segmentation-with-simpleseg",
    "title": "1  Processing",
    "section": "1.2 Cell segmentation with simpleSeg",
    "text": "1.2 Cell segmentation with simpleSeg\nThe simpleSeg package provides functionality to perform cell segmentation on multiplexed imaging data. The simpleSeg() function can be used to perform a simple cell segmentation process that traces out the nuclei using a specified channel.\nIn the particular example below, we have asked simpleSeg to do the following:\n\nnucleus = c(\"HH3\"): trace out the nuclei signal in the images using the HH3 channel.\npca = TRUE: segment out the nuclei mask using a principal component analysis of all channels and using the principal components most aligned with the nuclei channel, in this case, HH3.\ncellBody = \"dilate\": use a dilation strategy of segmentation, expanding out from the nucleus by a specified discSize. In this case, discSize = 3, which means simpleSeg dilates out from the nucleus by 3 pixels.\nsizeSelection = 20: ensure that only cells with a size greater than 20 pixels will be used.\ntransform = \"sqrt\": perform square root transformation on each of the channels prior to segmentation.\ntissue = c(\"panCK\", \"CD45\", \"HH3\"): use the specified tissue mask to filter out all background noise outside the tissue mask. This allows us to ignore background noise which happens outside of the tumour core.\n\nThere are many other parameters that can be specified in simpleSeg (smooth, watershed, tolerance, and ext), and we encourage the user to select the best parameters which suit their biological context.\n\nmasks &lt;- simpleSeg(images,\n                   nucleus = c(\"HH3\"),\n                   pca = TRUE,\n                   cellBody = \"dilate\",\n                   discSize = 3,\n                   sizeSelection = 20,\n                   transform = \"sqrt\",\n                   tissue = c(\"panCK\", \"CD45\", \"HH3\"),\n                   cores = nCores\n                   )\n\n\n1.2.1 Visualise separation\nThe display() and colorLabels() functions in the EBImage packagemake it very easy to examine the performance of the cell segmentation. If used in an interactive session, display() allows you to zoom in and out of the image.\n\nEBImage::display(colorLabels(masks[[1]]))\n\n\n\n\n\n\n\n\n\n\n1.2.2 Visualise outlines\nThe plotPixels function in cytomapper makes it easy to overlay the mask on top of the nucleus intensity marker to see how well our segmentation process has performed. Here we can see that the segmentation appears to be performing reasonably.\nIf you see over or under-segmentation of your images, discSize is a key parameter in simpleSeg() for optimising the size of the dilation disc after segmenting out the nuclei.\n\nplotPixels(image = images[\"F3\"], \n           mask = masks[\"F3\"],\n           img_id = \"imageID\", \n           colour_by = c(\"HH3\"), \n           display = \"single\",\n           colour = list(HH3 = c(\"black\",\"blue\")),\n           legend = NULL,\n           bcg = list(\n             HH3 = c(1, 1, 2)\n           ))\n\n\n\n\n\n\n\n\nWe can also visualise multiple markers at once instead of just the HH3 marker to see how the segmentation mask performs. Below, we can see that our segmentation mask has done a good job of capturing the CD31 signal, but perhaps not such a good job of capturing the FXIIIA signal, which often lies outside of our dilated nuclear mask. This could suggest that we might need to increase the discSize or other parameters of simpleSeg.\n\nplotPixels(image = images[\"F3\"], \n           mask = masks[\"F3\"],\n           img_id = \"imageID\", \n           colour_by = c(\"HH3\", \"CD31\", \"FX111A\"), \n           display = \"single\",\n           colour = list(HH3 = c(\"black\",\"blue\"),\n                         CD31 = c(\"black\", \"red\"),\n                         FX111A = c(\"black\", \"green\") ),\n           legend = NULL,\n           bcg = list(\n             HH3 = c(1, 1, 2),\n             CD31 = c(0, 1, 2),\n             FX111A = c(0, 1, 1.5)\n           ))\n\n\n\n\n\n\n\n\nIn particular, the cellBody and watershed parameters can strongly influence the way cells are segmented using simpleSeg(). We’ve provided further details on how the user may specify cell body identification and watershedding in the tables below.\n\n1.2.2.1 cellBody Parameters\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\n\n“distance”\nPerforms watershedding on a distance map of the thresholded nuclei signal. With a pixels distance being defined as the distance from the closest background signal.\n\n\n\n“intensity”\nPerforms watershedding using the intensity of the nuclei marker.\n\n\n\n“combine”\nCombines the previous two methods by multiplying the distance map by the nuclei marker intensity.\n\n\n\n\n\n\n1.2.2.2 watershed Parameters\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\n\n“dilation”\nDilates the nuclei by an amount defined by the user. The size of the dilatation in pixels may be specified with the discDize argument.\n\n\n\n“discModel”\nUses all the markers to predict the presence of dilated ‘discs’ around the nuclei. The model therefore learns which markers are typically present in the cell cytoplasm and generates a mask based on this.\n\n\n\n“marker”\nThe user may specify one or multiple dedicated cytoplasm markers to predict the cytoplasm. This can be done using cellBody = \"marker name\"/\"index\"\n\n\n\n“None”\nThe nuclei mask is returned directly.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Processing</span>"
    ]
  },
  {
    "objectID": "01-processing.html#cell-segmentation-with-bidcell",
    "href": "01-processing.html#cell-segmentation-with-bidcell",
    "title": "1  Processing",
    "section": "1.3 Cell segmentation with BIDCell",
    "text": "1.3 Cell segmentation with BIDCell",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Processing</span>"
    ]
  },
  {
    "objectID": "01-processing.html#visual-comparison-of-segmentations",
    "href": "01-processing.html#visual-comparison-of-segmentations",
    "title": "1  Processing",
    "section": "1.4 Visual comparison of segmentations",
    "text": "1.4 Visual comparison of segmentations\nplotPixels can plot multiple images &lt;– use this to visualise multiple images at once after you have BIDCell ready.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Processing</span>"
    ]
  },
  {
    "objectID": "01-processing.html#summarise-cell-features",
    "href": "01-processing.html#summarise-cell-features",
    "title": "1  Processing",
    "section": "1.5 Summarise cell features",
    "text": "1.5 Summarise cell features\nIn order to characterise the phenotypes of each of the segmented cells, measureObjects() from cytomapper will calculate the average intensity of each channel within each cell as well as a few morphological features. By default, the measureObjects() function will return a SingleCellExperiment object, where the channel intensities are stored in the counts assay and the spatial location of each cell is stored in colData in the m.cx and m.cy columns.\nHowever, you can also specify measureObjects() to return a SpatialExperiment object by specifying return_as = \"spe\". As a SpatialExperiment object, the spatial location of each cell is stored in the spatialCoords slot, as m.cx and m.cy, which simplifies plotting. In this demonstration, we will return a SpatialExperiment object.\n\n# Summarise the expression of each marker in each cell\ncells &lt;- cytomapper::measureObjects(masks,\n                                    images,\n                                    img_id = \"imageID\",\n                                    return_as = \"spe\",\n                                    BPPARAM = BPPARAM)\n\nspatialCoordsNames(cells) &lt;- c(\"x\", \"y\")",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Processing</span>"
    ]
  },
  {
    "objectID": "01-processing.html#sessioninfo",
    "href": "01-processing.html#sessioninfo",
    "title": "1  Processing",
    "section": "1.6 sessionInfo",
    "text": "1.6 sessionInfo\n\nsessionInfo()\n\nR version 4.4.1 (2024-06-14)\nPlatform: x86_64-pc-linux-gnu\nRunning under: Debian GNU/Linux 12 (bookworm)\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 \nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.21.so;  LAPACK version 3.11.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Australia/Sydney\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] SpatialDatasets_1.4.0       SpatialExperiment_1.16.0   \n [3] ExperimentHub_2.14.0        AnnotationHub_3.14.0       \n [5] BiocFileCache_2.14.0        dbplyr_2.5.0               \n [7] simpleSeg_1.8.0             ggplot2_3.5.1              \n [9] cytomapper_1.18.0           SingleCellExperiment_1.28.1\n[11] SummarizedExperiment_1.36.0 Biobase_2.66.0             \n[13] GenomicRanges_1.58.0        GenomeInfoDb_1.42.0        \n[15] IRanges_2.40.0              S4Vectors_0.44.0           \n[17] BiocGenerics_0.52.0         MatrixGenerics_1.18.0      \n[19] matrixStats_1.4.1           EBImage_4.48.0             \n\nloaded via a namespace (and not attached):\n  [1] DBI_1.2.3               bitops_1.0-9            deldir_2.0-4           \n  [4] gridExtra_2.3           rlang_1.1.4             magrittr_2.0.3         \n  [7] svgPanZoom_0.3.4        shinydashboard_0.7.2    RSQLite_2.3.7          \n [10] compiler_4.4.1          spatstat.geom_3.3-3     png_0.1-8              \n [13] systemfonts_1.1.0       fftwtools_0.9-11        vctrs_0.6.5            \n [16] pkgconfig_2.0.3         crayon_1.5.3            fastmap_1.2.0          \n [19] magick_2.8.5            XVector_0.46.0          utf8_1.2.4             \n [22] promises_1.3.0          rmarkdown_2.29          UCSC.utils_1.2.0       \n [25] ggbeeswarm_0.7.2        purrr_1.0.2             bit_4.5.0              \n [28] xfun_0.49               cachem_1.1.0            zlibbioc_1.52.0        \n [31] jsonlite_1.8.9          blob_1.2.4              later_1.3.2            \n [34] rhdf5filters_1.18.0     DelayedArray_0.32.0     spatstat.utils_3.1-1   \n [37] Rhdf5lib_1.28.0         BiocParallel_1.40.0     jpeg_0.1-10            \n [40] tiff_0.1-12             terra_1.7-83            parallel_4.4.1         \n [43] R6_2.5.1                RColorBrewer_1.1-3      spatstat.data_3.1-2    \n [46] spatstat.univar_3.1-1   Rcpp_1.0.13-1           knitr_1.49             \n [49] httpuv_1.6.15           Matrix_1.7-1            nnls_1.6               \n [52] tidyselect_1.2.1        yaml_2.3.10             rstudioapi_0.17.1      \n [55] abind_1.4-8             viridis_0.6.5           codetools_0.2-20       \n [58] curl_6.0.1              lattice_0.22-6          tibble_3.2.1           \n [61] KEGGREST_1.46.0         shiny_1.9.1             withr_3.0.2            \n [64] evaluate_1.0.1          polyclip_1.10-7         Biostrings_2.74.0      \n [67] filelock_1.0.3          BiocManager_1.30.25     pillar_1.9.0           \n [70] generics_0.1.3          sp_2.1-4                RCurl_1.98-1.16        \n [73] BiocVersion_3.20.0      munsell_0.5.1           scales_1.3.0           \n [76] xtable_1.8-4            glue_1.8.0              tools_4.4.1            \n [79] locfit_1.5-9.10         rhdf5_2.50.0            grid_4.4.1             \n [82] AnnotationDbi_1.68.0    colorspace_2.1-1        GenomeInfoDbData_1.2.13\n [85] raster_3.6-30           beeswarm_0.4.0          HDF5Array_1.34.0       \n [88] vipor_0.4.7             cli_3.6.3               rappdirs_0.3.3         \n [91] fansi_1.0.6             S4Arrays_1.6.0          viridisLite_0.4.2      \n [94] svglite_2.1.3           dplyr_1.1.4             gtable_0.3.6           \n [97] digest_0.6.37           SparseArray_1.6.0       rjson_0.2.23           \n[100] htmlwidgets_1.6.4       memoise_2.0.1           htmltools_0.5.8.1      \n[103] lifecycle_1.0.4         httr_1.4.7              mime_0.12              \n[106] bit64_4.5.2",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Processing</span>"
    ]
  },
  {
    "objectID": "02-quality_control.html",
    "href": "02-quality_control.html",
    "title": "2  Quality Control",
    "section": "",
    "text": "2.1 CellSPA: How do I determine segmentation quality?\nSteps:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Quality Control</span>"
    ]
  },
  {
    "objectID": "02-quality_control.html#simpleseg-do-my-images-have-a-batch-effect",
    "href": "02-quality_control.html#simpleseg-do-my-images-have-a-batch-effect",
    "title": "2  Quality Control",
    "section": "2.2 simpleSeg: Do my images have a batch effect?",
    "text": "2.2 simpleSeg: Do my images have a batch effect?\nIn many spatial imaging protocols, there tends to be a degree of variability in the intensity of each image. For example, in one image, the CD3 stain may be too strong, whereas in another image the CD3 staining is particularly weak. This variability is often times inevitable and can be hard to correct for in the imaging process. Hence, it is important that we identify when such variance occurs and correct it.\nFirst, let’s load in the images we previously segmented out in the last section. The SpatialDatasets package conveniently provides the segmented out images for the HNsCC dataset from Ferguson et al., 2022.\n\nlibrary(tidySingleCellExperiment)\n\nLoading required package: SingleCellExperiment\n\n\nLoading required package: SummarizedExperiment\n\n\nLoading required package: MatrixGenerics\n\n\nLoading required package: matrixStats\n\n\n\nAttaching package: 'MatrixGenerics'\n\n\nThe following objects are masked from 'package:matrixStats':\n\n    colAlls, colAnyNAs, colAnys, colAvgsPerRowSet, colCollapse,\n    colCounts, colCummaxs, colCummins, colCumprods, colCumsums,\n    colDiffs, colIQRDiffs, colIQRs, colLogSumExps, colMadDiffs,\n    colMads, colMaxs, colMeans2, colMedians, colMins, colOrderStats,\n    colProds, colQuantiles, colRanges, colRanks, colSdDiffs, colSds,\n    colSums2, colTabulates, colVarDiffs, colVars, colWeightedMads,\n    colWeightedMeans, colWeightedMedians, colWeightedSds,\n    colWeightedVars, rowAlls, rowAnyNAs, rowAnys, rowAvgsPerColSet,\n    rowCollapse, rowCounts, rowCummaxs, rowCummins, rowCumprods,\n    rowCumsums, rowDiffs, rowIQRDiffs, rowIQRs, rowLogSumExps,\n    rowMadDiffs, rowMads, rowMaxs, rowMeans2, rowMedians, rowMins,\n    rowOrderStats, rowProds, rowQuantiles, rowRanges, rowRanks,\n    rowSdDiffs, rowSds, rowSums2, rowTabulates, rowVarDiffs, rowVars,\n    rowWeightedMads, rowWeightedMeans, rowWeightedMedians,\n    rowWeightedSds, rowWeightedVars\n\n\nLoading required package: GenomicRanges\n\n\nLoading required package: stats4\n\n\nLoading required package: BiocGenerics\n\n\n\nAttaching package: 'BiocGenerics'\n\n\nThe following objects are masked from 'package:stats':\n\n    IQR, mad, sd, var, xtabs\n\n\nThe following objects are masked from 'package:base':\n\n    anyDuplicated, aperm, append, as.data.frame, basename, cbind,\n    colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find,\n    get, grep, grepl, intersect, is.unsorted, lapply, Map, mapply,\n    match, mget, order, paste, pmax, pmax.int, pmin, pmin.int,\n    Position, rank, rbind, Reduce, rownames, sapply, saveRDS, setdiff,\n    table, tapply, union, unique, unsplit, which.max, which.min\n\n\nLoading required package: S4Vectors\n\n\n\nAttaching package: 'S4Vectors'\n\n\nThe following object is masked from 'package:utils':\n\n    findMatches\n\n\nThe following objects are masked from 'package:base':\n\n    expand.grid, I, unname\n\n\nLoading required package: IRanges\n\n\nLoading required package: GenomeInfoDb\n\n\nLoading required package: Biobase\n\n\nWelcome to Bioconductor\n\n    Vignettes contain introductory material; view with\n    'browseVignettes()'. To cite Bioconductor, see\n    'citation(\"Biobase\")', and for packages 'citation(\"pkgname\")'.\n\n\n\nAttaching package: 'Biobase'\n\n\nThe following object is masked from 'package:MatrixGenerics':\n\n    rowMedians\n\n\nThe following objects are masked from 'package:matrixStats':\n\n    anyMissing, rowMedians\n\nlibrary(simpleSeg)\n# library(scMerge)\nlibrary(scater)\n\nLoading required package: scuttle\n\nlibrary(ggplot2)\n\n\nfergusonSPE &lt;- SpatialDatasets::spe_Ferguson_2022()\n\nsee ?SpatialDatasets and browseVignettes('SpatialDatasets') for documentation\n\n\nloading from cache\n\n\nNext, we can check if the marker intensities of each cell require some form of transformation or normalisation. The reason we do this is two-fold:\n1) The intensities of images are often highly skewed, preventing any meaningful downstream analysis.\n2) The intensities across different images are often different, meaning that what is considered “positive” can be different across images.\nBy transforming and normalising the data, we aim to reduce these two effects. Here we extract the intensities from the counts assay. Looking at CD3 which should be expressed in the majority of the T cells, the intensities are clearly very skewed, and it is difficult to see what is considered a CD3- cell, and what is a CD3+ cell. Further, we can clearly see some image-level batch effect, where across images, the intensity peaks differ drastically.\n\n# Plot densities of CD3 for each image.\nfergusonSPE |&gt; \n  join_features(features = rownames(fergusonSPE), shape = \"wide\", assay = \"counts\") |&gt; \n  ggplot(aes(x = CD3, colour = imageID)) + \n  geom_density() + \n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\nAnother method of visualising batch effect is using a dimensionality reduction technique and visualising how the images separate out on a 2D plot. If no batch effect is expected, we should see the images largely overlap with each other.\n\n# Usually we specify a subset of the original markers which are informative to separating out distinct cell types for the UMAP and clustering.\nct_markers &lt;- c(\"podoplanin\", \"CD13\", \"CD31\",\n                \"panCK\", \"CD3\", \"CD4\", \"CD8a\",\n                \"CD20\", \"CD68\", \"CD16\", \"CD14\", \n                \"HLADR\", \"CD66a\")\n\nset.seed(51773)\n# Perform dimension reduction using UMAP.\nfergusonSPE &lt;- scater::runUMAP(\n  fergusonSPE,\n  subset_row = ct_markers,\n  exprs_values = \"counts\"\n)\n\n# Select a subset of images to plot.\nsomeImages &lt;- unique(fergusonSPE$imageID)[c(1, 5, 10, 20, 30, 40)]\n\n# UMAP by imageID.\nscater::plotReducedDim(\n  fergusonSPE[, fergusonSPE$imageID %in% someImages],\n  dimred = \"UMAP\",\n  colour_by = \"imageID\"\n)\n\n\n\n\n\n\n\n\nWe can observe that from both our density plot and the UMAP, that there exists some level of batch effect in our dataset. simpleSeg also provides functionality for correcting image-level variability, using the normalizeCells() function.\nIn the normalizeCells() function, we specify the following parameters. transformation is an optional argument which specifies the function to be applied to the data. We do not apply an arcsinh transformation here, as we already apply a square root transform in the simpleSeg() function. method = c(\"trim99\", \"mean\", PC1\") is an optional argument which specifies the normalisation method/s to be performed. A comprehensive table of methods is provided below. assayIn = \"counts\" is a required argument which specifies what the assay you’ll be taking the intensity data from is named. In our context, this is called counts.\n\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\n\n“mean”\nDivides the marker cellular marker intensities by their mean.\n\n\n\n“minMax”\nSubtracts the minimum value and scales markers between 0 and 1.\n\n\n\n“trim99”\nSets the highest 1% of values to the value of the 99th percentile.`\n\n\n\n“PC1”\nRemoves the 1st principal component) can be performed with one call of the function, in the order specified by the user.\n\n\n\n\nThis modified data is then stored in the norm assay by default, but can be changed using the assayOut parameter.\n\n# Leave out the nuclei markers from our normalisation process. \nuseMarkers &lt;- rownames(fergusonSPE)[!rownames(fergusonSPE) %in% c(\"DNA1\", \"DNA2\", \"HH3\")]\n\n# Transform and normalise the marker expression of each cell type.\nfergusonSPE &lt;- normalizeCells(fergusonSPE,\n                        markers = useMarkers,\n                        transformation = NULL,\n                        method = c(\"trim99\", \"mean\", \"PC1\"),\n                        assayIn = \"counts\",\n                        cores = nCores\n)\n\nWe can then plot the same density curve where we can see that this normalised data appears more bimodal where we can at least observe a clear CD3+ peak at 1.00, and a CD3- peak at around 0.3, and the images overlap much more strongly.\n\n# Plot densities of CD3 for each image\nfergusonSPE |&gt; \n  join_features(features = rownames(fergusonSPE), shape = \"wide\", assay = \"norm\") |&gt; \n  ggplot(aes(x = CD3, colour = imageID)) + \n  geom_density() + \n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\nWe can also visualise the effect of normalisation on the UMAP, where our images now overlap much more strongly with each other.\n\nset.seed(51773)\n# Perform dimension reduction using UMAP.\nfergusonSPE &lt;- scater::runUMAP(\n  fergusonSPE,\n  subset_row = ct_markers,\n  exprs_values = \"norm\",\n  name = \"normUMAP\"\n)\n\nsomeImages &lt;- unique(fergusonSPE$imageID)[c(1, 5, 10, 20, 30, 40)]\n\n# UMAP by imageID.\nscater::plotReducedDim(\n  fergusonSPE[, fergusonSPE$imageID %in% someImages],\n  dimred = \"normUMAP\",\n  colour_by = \"imageID\"\n)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Quality Control</span>"
    ]
  },
  {
    "objectID": "02-quality_control.html#scmerge-combining-multiple-spatial-datasets",
    "href": "02-quality_control.html#scmerge-combining-multiple-spatial-datasets",
    "title": "2  Quality Control",
    "section": "2.3 scMerge: Combining multiple spatial datasets",
    "text": "2.3 scMerge: Combining multiple spatial datasets\nA common question that pops up when analysing spatial datasets is:\nCan I combine multiple spatial datasets?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Quality Control</span>"
    ]
  },
  {
    "objectID": "02-quality_control.html#sessioninfo",
    "href": "02-quality_control.html#sessioninfo",
    "title": "2  Quality Control",
    "section": "2.4 sessionInfo",
    "text": "2.4 sessionInfo\n\nsessionInfo()\n\nR version 4.4.1 (2024-06-14)\nPlatform: x86_64-pc-linux-gnu\nRunning under: Debian GNU/Linux 12 (bookworm)\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 \nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.21.so;  LAPACK version 3.11.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Australia/Sydney\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] SpatialDatasets_1.4.0           SpatialExperiment_1.16.0       \n [3] ExperimentHub_2.14.0            AnnotationHub_3.14.0           \n [5] BiocFileCache_2.14.0            dbplyr_2.5.0                   \n [7] scater_1.34.0                   scuttle_1.16.0                 \n [9] simpleSeg_1.8.0                 ggplot2_3.5.1                  \n[11] ttservice_0.4.1                 tidyr_1.3.1                    \n[13] dplyr_1.1.4                     tidySingleCellExperiment_1.16.0\n[15] SingleCellExperiment_1.28.1     SummarizedExperiment_1.36.0    \n[17] Biobase_2.66.0                  GenomicRanges_1.58.0           \n[19] GenomeInfoDb_1.42.0             IRanges_2.40.0                 \n[21] S4Vectors_0.44.0                BiocGenerics_0.52.0            \n[23] MatrixGenerics_1.18.0           matrixStats_1.4.1              \n\nloaded via a namespace (and not attached):\n  [1] RColorBrewer_1.1-3      rstudioapi_0.17.1       jsonlite_1.8.9         \n  [4] magrittr_2.0.3          spatstat.utils_3.1-1    ggbeeswarm_0.7.2       \n  [7] magick_2.8.5            farver_2.1.2            rmarkdown_2.29         \n [10] zlibbioc_1.52.0         vctrs_0.6.5             memoise_2.0.1          \n [13] RCurl_1.98-1.16         terra_1.7-83            svgPanZoom_0.3.4       \n [16] htmltools_0.5.8.1       S4Arrays_1.6.0          curl_6.0.1             \n [19] BiocNeighbors_2.0.0     raster_3.6-30           Rhdf5lib_1.28.0        \n [22] SparseArray_1.6.0       rhdf5_2.50.0            htmlwidgets_1.6.4      \n [25] cachem_1.1.0            plotly_4.10.4           mime_0.12              \n [28] lifecycle_1.0.4         pkgconfig_2.0.3         rsvd_1.0.5             \n [31] Matrix_1.7-1            R6_2.5.1                fastmap_1.2.0          \n [34] GenomeInfoDbData_1.2.13 shiny_1.9.1             digest_0.6.37          \n [37] colorspace_2.1-1        AnnotationDbi_1.68.0    irlba_2.3.5.1          \n [40] RSQLite_2.3.7           beachmat_2.22.0         labeling_0.4.3         \n [43] filelock_1.0.3          fansi_1.0.6             nnls_1.6               \n [46] httr_1.4.7              polyclip_1.10-7         abind_1.4-8            \n [49] compiler_4.4.1          bit64_4.5.2             withr_3.0.2            \n [52] tiff_0.1-12             BiocParallel_1.40.0     DBI_1.2.3              \n [55] viridis_0.6.5           HDF5Array_1.34.0        cytomapper_1.18.0      \n [58] rappdirs_0.3.3          DelayedArray_0.32.0     rjson_0.2.23           \n [61] tools_4.4.1             vipor_0.4.7             beeswarm_0.4.0         \n [64] httpuv_1.6.15           glue_1.8.0              EBImage_4.48.0         \n [67] rhdf5filters_1.18.0     promises_1.3.0          grid_4.4.1             \n [70] generics_0.1.3          gtable_0.3.6            spatstat.data_3.1-2    \n [73] data.table_1.16.2       BiocSingular_1.22.0     ScaledMatrix_1.14.0    \n [76] sp_2.1-4                utf8_1.2.4              XVector_0.46.0         \n [79] RcppAnnoy_0.0.22        spatstat.geom_3.3-3     BiocVersion_3.20.0     \n [82] ggrepel_0.9.6           pillar_1.9.0            stringr_1.5.1          \n [85] later_1.3.2             lattice_0.22-6          bit_4.5.0              \n [88] deldir_2.0-4            tidyselect_1.2.1        locfit_1.5-9.10        \n [91] Biostrings_2.74.0       knitr_1.49              gridExtra_2.3          \n [94] svglite_2.1.3           xfun_0.49               shinydashboard_0.7.2   \n [97] stringi_1.8.4           UCSC.utils_1.2.0        fftwtools_0.9-11       \n[100] yaml_2.3.10             lazyeval_0.2.2          evaluate_1.0.1         \n[103] codetools_0.2-20        tibble_3.2.1            BiocManager_1.30.25    \n[106] cli_3.6.3               uwot_0.2.2              xtable_1.8-4           \n[109] systemfonts_1.1.0       munsell_0.5.1           Rcpp_1.0.13-1          \n[112] png_0.1-8               spatstat.univar_3.1-1   parallel_4.4.1         \n[115] ellipsis_0.3.2          blob_1.2.4              jpeg_0.1-10            \n[118] bitops_1.0-9            viridisLite_0.4.2       scales_1.3.0           \n[121] purrr_1.0.2             crayon_1.5.3            rlang_1.1.4            \n[124] cowplot_1.1.3           KEGGREST_1.46.0",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Quality Control</span>"
    ]
  },
  {
    "objectID": "03-cell_annotation.html",
    "href": "03-cell_annotation.html",
    "title": "3  Cell Annotation",
    "section": "",
    "text": "3.1 Which package should I use? Clustering vs Annotation\nSteps:\nLabeling the identity of your cells is a key step in any spatial processing protocol in order to determine differential cell type compositions and changes which occur in specific cell types during disease. However, the method by which this is done can differ from study to study. Here, we provide two packages capable of either cell type clustering (FuseSOM) or cell type annotation (scClassify).\nClustering is an unsupervised method of labelling cells. This means that an algorithm separates out clusters of cells based purely off their marker expression, and the subsequent labeling of these clusters must be done with some biological domain knowledge. Cell annotation is a supervised method which requires a separate, reference dataset. The algorithm then uses that reference dataset to determine the identity of each of your cell types, thereby labelling your cells in the process. There are advantages and disadvantages to both, and the choice of one or the other will be discussed in this chapter. First we’ll walk through how to run both of these packages, and then we’ll discuss how to choose between FuseSOM and scClassify",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Cell Annotation</span>"
    ]
  },
  {
    "objectID": "03-cell_annotation.html#fusesom-cell-clustering",
    "href": "03-cell_annotation.html#fusesom-cell-clustering",
    "title": "3  Cell Annotation",
    "section": "3.2 FuseSOM: Cell clustering",
    "text": "3.2 FuseSOM: Cell clustering\nA correlation based multiview self organizing map for the characterization of cell types (FuseSOM) is a tool for unsupervised clustering. FuseSOM is robust and achieves high accuracy by combining a Self Organizing Map architecture and a Multiview integration of correlation based metrics to cluster highly multiplexed in situ imaging cytometry assays. The FuseSOM pipeline has been streamlined and accepts currently used data structures including SingleCellExperiment and SpatialExperiment objects as well as DataFrames.\n\n3.2.1 FuseSOM Matrix Input\nIf you have a matrix containing expression data that was QCed and normalised by some other tool, the next step is to run the FuseSOM algorithm.This can be done by calling the runFuseSOM() function which takes in the matrix of interest where the columns are markers and the rows are observations, the makers of interest (if this is not provided, it is assumed that all columns are markers), and the number of clusters.\n\n# load FuseSOM\nlibrary(FuseSOM)\n\nNext we will load in the Risom et al dataset and run it through the FuseSOM pipeline. This dataset profiles the spatial landscape of ductal carcinoma in situ (DCIS), which is a pre-invasive lesion that is thought to be a precursor to invasive breast cancer (IBC). The key conclusion of this manuscript (amongst others) is that spatial information about cells can be used to predict disease progression in patients.We will also be using the markers used in the original study.\n\n# load in the data\ndata(\"risom_dat\")\n\n# define the markers of interest\nrisomMarkers &lt;- c('CD45','SMA','CK7','CK5','VIM','CD31','PanKRT','ECAD',\n                   'Tryptase','MPO','CD20','CD3','CD8','CD4','CD14','CD68','FAP',\n                   'CD36','CD11c','HLADRDPDQ','P63','CD44')\n\n# we will be using the manual_gating_phenotype as the true cell type to gauge \n# performance\nnames(risom_dat)[names(risom_dat) == 'manual_gating_phenotype'] &lt;- 'CellType'\n\nNow that we have loaded the data and define the markers of interest. We can run the FuseSOM algorithm. We have provided a function runFuseSOM that runs the pipeline from top to bottom and returns the cluster labels as well as the Self Organizing Map model.\n\nrisomRes &lt;- runFuseSOM(data = risom_dat, markers = risomMarkers, \n                        numClusters = 23)\n\nYou have provided a dataset of class data.frame\n\n\nEverything looks good. Now running the FuseSOM algorithm\n\n\nNow Generating the Self Organizing Map Grid\n\n\nOptimal Grid Size is: 8\n\n\nNow Running the Self Organizing Map Model\n\n\nNow Clustering the Prototypes\n\n\nLoading required namespace: fastcluster\n\n\nNow Mapping Clusters to the Original Data\n\n\nThe Prototypes have been Clustered and Mapped Successfully\n\n\nThe FuseSOM algorithm has completed successfully\n\n\nLets look at the distribution of the clusters.\n\n# get the distribution of the clusters\ntable(risomRes$clusters)/sum(table(risomRes$clusters))\n\n\n  cluster_1  cluster_10  cluster_11  cluster_12  cluster_13  cluster_14 \n0.323602021 0.035968538 0.005439775 0.021443334 0.061100586 0.026596050 \n cluster_15  cluster_16  cluster_17  cluster_18  cluster_19   cluster_2 \n0.020582156 0.032624297 0.024931106 0.076128143 0.015802618 0.014927087 \n cluster_20  cluster_21  cluster_22  cluster_23   cluster_3   cluster_4 \n0.049962682 0.009185900 0.051771156 0.066913538 0.004923068 0.014108968 \n  cluster_5   cluster_6   cluster_7   cluster_8   cluster_9 \n0.040776783 0.064444827 0.020854863 0.010032725 0.007879780 \n\n\nLooks like cluster_1 has about \\(32\\%\\) of the cells which is interesting. Next, lets generate a heatmap of the marker expression for each cluster.\n\nrisomHeat &lt;- FuseSOM::markerHeatmap(data = risom_dat, markers = risomMarkers,\n                            clusters = risomRes$clusters, clusterMarkers = TRUE)\n\n\n\n\n\n\n\n\n\n\n3.2.2 Using FuseSOM to estimate the number of clusters\nFuseSOM also provides functionality for estimating the number of clusters in a dataset using three classes of methods including:\n\nDiscriminant based method.\n\nA method developed in house based on discriminant based maximum clusterability projection pursuit\n\nDistance based methods which includes:\n\nThe Gap Statistic\nThe Jump Statistic\nThe Slope Statistic\nThe Within Cluster Dissimilarity Statistic\nThe Silhouette Statistic\n\n\nWe can estimate the number of clusters using the estimateNumCluster. Run help(estimateNumCluster) to see it’s complete functionality.\n\n# lets estimate the number of clusters using all the methods\n# original clustering has 23 clusters so we will set kseq from 2:25\n# we pass it the som model generated in the previous step\nrisomKest &lt;- estimateNumCluster(data = risomRes$model, kSeq = 2:25, \n                                  method = c(\"Discriminant\", \"Distance\"))\n\nNow Computing the Number of Clusters using Discriminant Analysis\n\n\nNow Computing The Number Of Clusters Using Distance Analysis\n\n\nWe can then use this result to determine the best number of clusters for this dataset based on the different metrics. The FuseSOM package provides a plotting function (optiPlot) which generates an elbow plot with the optimal value for the number of clusters for the distance based methods. See below\n\n# what is the best number of clusters determined by the discriminant method?\n# optimal number of clusters according to the discriminant method is 7\nrisomKest$Discriminant \n\n[1] 7\n\n# we can plot the results using the optiplot function\npSlope &lt;- optiPlot(risomKest, method = 'slope')\npSlope\n\n\n\n\n\n\n\npJump &lt;- optiPlot(risomKest, method = 'jump')\npJump\n\n\n\n\n\n\n\npWcd &lt;- optiPlot(risomKest, method = 'wcd')\npWcd\n\n\n\n\n\n\n\npGap &lt;- optiPlot(risomKest, method = 'gap')\npGap\n\n\n\n\n\n\n\npSil &lt;- optiPlot(risomKest, method = 'silhouette')\npSil\n\n\n\n\n\n\n\n\nFrom the plots, we see that the Jump statistics almost perfectly capture the number of clusters. The Gap method is a close second with \\(15\\) clusters. All the other methods significantly underestimates the number of clusters.\n\n\n3.2.3 FuseSOM Single Cell Epxeriment object as input.\nThe FuseSOM algorithm is also equipped to take in a SingleCellExperiment object as input. The results of the pipeline will be written to either the metada or the colData fields. See below.\nFirst we create a SingleCellExperiment object\n\nlibrary(SingleCellExperiment)\n\n# create a singelcellexperiment object\ncolDat &lt;- risom_dat[, setdiff(colnames(risom_dat), risomMarkers)]\nsce &lt;- SingleCellExperiment(assays = list(counts = t(risom_dat)),\n                                 colData = colDat)\n\nsce\n\nclass: SingleCellExperiment \ndim: 23 69672 \nmetadata(0):\nassays(1): counts\nrownames(23): CD45 SMA ... CD44 CellType\nrowData names(0):\ncolnames: NULL\ncolData names(1): X\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\n\n\nNext we pass it to the runFuseSOM() function. Here, we can provide the assay in which the data is stored and what name to store the clusters under in the colData section. Note that the Self Organizing Map that is generated will be stored in the metadata field.\n\nrisomRessce &lt;- runFuseSOM(sce, markers = risomMarkers, assay = 'counts', \n                      numClusters = 23, verbose = FALSE)\n\nYou have provided a dataset of class SingleCellExperiment\n\n\nEverything looks good. Now running the FuseSOM algorithm\n\n\nNow Generating the Self Organizing Map Grid\n\n\nOptimal Grid Size is: 8\n\n\nNow Running the Self Organizing Map Model\n\n\nNow Clustering the Prototypes\n\n\nNow Mapping Clusters to the Original Data\n\n\nThe Prototypes have been Clustered and Mapped Successfully\n\n\nThe FuseSOM algorithm has completed successfully\n\ncolnames(colData(risomRessce))\n\n[1] \"X\"        \"clusters\"\n\nnames(metadata(risomRessce))\n\n[1] \"SOM\"\n\n\nNotice how the there is now a clusters column in the colData and SOM field in the metadata. You can run this function again with a new set of cluster number. If you provide a new name for the clusters, it will be stored under that new column, else, it will overwrite the current clusters column. Running it again on the same object will overwrite the SOM field in the metadata.\nJust like before, lets plot the heatmap of the resulting clusters across all markers.\n\ndata &lt;- risom_dat[, risomMarkers] # get the original data used\nclusters &lt;- colData(risomRessce)$clusters # extract the clusters from the sce object\n# generate the heatmap\nrisomHeatsce &lt;- markerHeatmap(data = risom_dat, markers = risomMarkers,\n                            clusters = clusters, clusterMarkers = TRUE)\n\n\n\n\n\n\n\n\n\n\n3.2.4 Using FuseSOM to estimate the number of clusters for single cell experiment objects\nJust like before, we can estimate the number of clusters\n\n# lets estimate the number of clusters using all the methods\n# original clustering has 23 clusters so we will set kseq from 2:25\n# now we pass it a singlecellexperiment object instead of the som model as before\n# this will return a singelcellexperiment object where the metatdata contains the\n# cluster estimation information\nrisomRessce &lt;- estimateNumCluster(data = risomRessce, kSeq = 2:25, \n                                  method = c(\"Discriminant\", \"Distance\"))\n\nYou have provided a dataset of class: SingleCellExperiment\n\n\nNow Computing the Number of Clusters using Discriminant Analysis\n\n\nNow Computing The Number Of Clusters Using Distance Analysis\n\nnames(metadata(risomRessce))\n\n[1] \"SOM\"               \"clusterEstimation\"\n\n\nNotice how the metadata now contains a clusterEstimation field which holds the results from the estimateNumCluster() function\nWe can assess the results in a similar fashion as before\n\n# what is the best number of clusters determined by the discriminant method?\n# optimal number of clusters according to the discriminant method is 8\nmetadata(risomRessce)$clusterEstimation$Discriminant \n\n[1] 10\n\n# we can plot the results using the optiplot function\npSlope &lt;- optiPlot(risomRessce, method = 'slope')\n\nYou have provided a dataset of class: SingleCellExperiment\n\npSlope\n\n\n\n\n\n\n\npJump &lt;- optiPlot(risomRessce, method = 'jump')\n\nYou have provided a dataset of class: SingleCellExperiment\n\npJump\n\n\n\n\n\n\n\npWcd &lt;- optiPlot(risomRessce, method = 'wcd')\n\nYou have provided a dataset of class: SingleCellExperiment\n\npWcd\n\n\n\n\n\n\n\npGap &lt;- optiPlot(risomRessce, method = 'gap')\n\nYou have provided a dataset of class: SingleCellExperiment\n\npGap\n\n\n\n\n\n\n\npSil &lt;- optiPlot(risomRessce, method = 'silhouette')\n\nYou have provided a dataset of class: SingleCellExperiment\n\npSil\n\n\n\n\n\n\n\n\nAgain, we see that the Jump statistics almost perfectly capture the number of clusters. The Gap method is a close second with \\(15\\) clusters. All the other methods significantly underestimates the number of clusters.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Cell Annotation</span>"
    ]
  },
  {
    "objectID": "03-cell_annotation.html#scclassify-cell-annotation",
    "href": "03-cell_annotation.html#scclassify-cell-annotation",
    "title": "3  Cell Annotation",
    "section": "3.3 scClassify: Cell annotation",
    "text": "3.3 scClassify: Cell annotation",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Cell Annotation</span>"
    ]
  },
  {
    "objectID": "03-cell_annotation.html#choosing-between-clustering-and-annotation",
    "href": "03-cell_annotation.html#choosing-between-clustering-and-annotation",
    "title": "3  Cell Annotation",
    "section": "3.4 Choosing between clustering and annotation",
    "text": "3.4 Choosing between clustering and annotation",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Cell Annotation</span>"
    ]
  },
  {
    "objectID": "03-cell_annotation.html#sessioninfo",
    "href": "03-cell_annotation.html#sessioninfo",
    "title": "3  Cell Annotation",
    "section": "3.5 sessionInfo",
    "text": "3.5 sessionInfo\n\nsessionInfo()\n\nR version 4.4.1 (2024-06-14)\nPlatform: x86_64-pc-linux-gnu\nRunning under: Debian GNU/Linux 12 (bookworm)\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 \nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.21.so;  LAPACK version 3.11.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Australia/Sydney\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] SingleCellExperiment_1.28.1 SummarizedExperiment_1.36.0\n [3] Biobase_2.66.0              GenomicRanges_1.58.0       \n [5] GenomeInfoDb_1.42.0         IRanges_2.40.0             \n [7] S4Vectors_0.44.0            BiocGenerics_0.52.0        \n [9] MatrixGenerics_1.18.0       matrixStats_1.4.1          \n[11] FuseSOM_1.8.0              \n\nloaded via a namespace (and not attached):\n [1] mnormt_2.1.1             permute_0.9-7            rlang_1.1.4             \n [4] magrittr_2.0.3           compiler_4.4.1           mgcv_1.9-1              \n [7] flexmix_2.3-19           analogue_0.17-7          vctrs_0.6.5             \n[10] stringr_1.5.1            pkgconfig_2.0.3          crayon_1.5.3            \n[13] fastmap_1.2.0            backports_1.5.0          XVector_0.46.0          \n[16] labeling_0.4.3           utf8_1.2.4               rmarkdown_2.29          \n[19] UCSC.utils_1.2.0         purrr_1.0.2              coop_0.6-3              \n[22] xfun_0.49                modeltools_0.2-23        zlibbioc_1.52.0         \n[25] jsonlite_1.8.9           DelayedArray_0.32.0      fpc_2.2-13              \n[28] psych_2.4.6.26           broom_1.0.7              parallel_4.4.1          \n[31] prabclus_2.3-4           cluster_2.1.6            R6_2.5.1                \n[34] profileModel_0.6.1       stringi_1.8.4            RColorBrewer_1.1-3      \n[37] car_3.1-3                diptest_0.77-1           Rcpp_1.0.13-1           \n[40] knitr_1.49               Matrix_1.7-1             splines_4.4.1           \n[43] nnet_7.3-19              tidyselect_1.2.1         rstudioapi_0.17.1       \n[46] abind_1.4-8              vegan_2.6-8              brglm_0.7.2             \n[49] lattice_0.22-6           tibble_3.2.1             withr_3.0.2             \n[52] evaluate_1.0.1           gridGraphics_0.5-1       proxy_0.4-27            \n[55] kernlab_0.9-33           mclust_6.1.1             pillar_1.9.0            \n[58] ggpubr_0.6.0             carData_3.0-5            generics_0.1.3          \n[61] sp_2.1-4                 ggplot2_3.5.1            munsell_0.5.1           \n[64] scales_1.3.0             princurve_2.1.6          class_7.3-22            \n[67] glue_1.8.0               pheatmap_1.0.12          tools_4.4.1             \n[70] robustbase_0.99-4-1      ggsignif_0.6.4           fs_1.6.5                \n[73] fastcluster_1.2.6        grid_4.4.1               tidyr_1.3.1             \n[76] colorspace_2.1-1         nlme_3.1-166             GenomeInfoDbData_1.2.13 \n[79] Formula_1.2-5            cli_3.6.3                DataVisualizations_1.3.2\n[82] FCPS_1.3.4               fansi_1.0.6              S4Arrays_1.6.0          \n[85] dplyr_1.1.4              DEoptimR_1.1-3           gtable_0.3.6            \n[88] rstatix_0.7.2            yulab.utils_0.1.8        digest_0.6.37           \n[91] SparseArray_1.6.0        ggplotify_0.1.2          htmlwidgets_1.6.4       \n[94] farver_2.1.2             htmltools_0.5.8.1        lifecycle_1.0.4         \n[97] httr_1.4.7               MASS_7.3-61",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Cell Annotation</span>"
    ]
  },
  {
    "objectID": "04-cell_localisation.html",
    "href": "04-cell_localisation.html",
    "title": "4  Cell localisation",
    "section": "",
    "text": "4.1 spicyR: Cell localisation\nNow that we’ve finished performing all of our upstream preprocessing (segmentation, quality control, and annotation), we can now begin dissecting out interesting findings for our datasets. One of the primary motivations behind pursuing a spatial technology as opposed to a space-agnostic technology such as single-cell RNA sequencing, is that we are more able to tease out whether changes are occurring spatially, i.e. are two cell types closer together in a disease state vs a non-disease state. Whilst these changes are usually visually obvious, to quantify localisation and dispersion relationships, more advanced statistical modelling is required.\nThis section provides step-by-step instructions on assessing how the localisation of different cell types changes across different disease conditions.\nWe use the (keren2018?) breast cancer dataset to compare the spatial distribution of immune cells in individuals with different levels of tumour infiltration (cold and compartmentalised).\nThe data is stored as a SpatialExperiment object and contains single-cell spatial data from 41 images.\nkerenSPE &lt;- SpatialDatasets::spe_Keren_2018()\nThe cell types in this dataset includes 11 immune cell types (double negative CD3 T cells, CD4 T cells, B cells, monocytes, macrophages, CD8 T cells, neutrophils, natural killer cells, dendritic cells, regulatory T cells), 2 structural cell types (endothelial, mesenchymal), 2 tumour cell types (keratin+ tumour, tumour) and one unidentified category. Below we’ve provided detailed information on the statistical backend of spicyR.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Cell localisation</span>"
    ]
  },
  {
    "objectID": "04-cell_localisation.html#spicyr-cell-localisation",
    "href": "04-cell_localisation.html#spicyr-cell-localisation",
    "title": "4  Cell localisation",
    "section": "",
    "text": "4.1.1 Linear modelling\nTo investigate changes in localisation between two different cell types, we measure the level of localisation between two cell types by modelling with the L-function. The L-function is a variance-stabilised K-function given by the equation\n\\[\n\\widehat{L_{ij}} (r) = \\sqrt{\\frac{\\widehat{K_{ij}}(r)}{\\pi}}\n\\]\nwith \\(\\widehat{K_{ij}}\\) defined as\n\\[\n\\widehat{K_{ij}} (r) = \\frac{|W|}{n_i n_j} \\sum_{n_i} \\sum_{n_j} 1 \\{d_{ij} \\leq r \\} e_{ij} (r)\n\\]\nwhere \\(\\widehat{K_{ij}}\\) summarises the degree of co-localisation of cell type \\(j\\) with cell type \\(i\\), \\(n_i\\) and \\(n_j\\) are the number of cells of type \\(i\\) and \\(j\\), \\(|W|\\) is the image area, \\(d_{ij}\\) is the distance between two cells and \\(e_{ij} (r)\\) is an edge correcting factor.\nSpecifically, the mean difference between the experimental function and the theoretical function is used as a measure for the level of localisation, defined as\n\\[\nu = \\sum_{r' = r_{\\text{min}}}^{r_{\\text{max}}} \\widehat L_{ij, \\text{Experimental}} (r') - \\widehat L_{ij, \\text{Poisson}} (r')\n\\]\nwhere \\(u\\) is the sum is taken over a discrete range of \\(r\\) between \\(r_{\\text{min}}\\) and \\(r_{\\text{max}}\\). Differences of the statistic \\(u\\) between two conditions is modelled using a weighted linear model.\n\n\n4.1.2 Test for changes in localisation for a specific pair of cells\nFirstly, we can test whether one cell type tends to be more localised with another cell type in one condition compared to the other. This can be done using the spicy() function, where we specify the condition parameter.\nIn this example, we want to see whether or not neutrophils (to) tend to be found around CD8 T cells (from) in compartmentalised tumours compared to cold tumours. Given that there are 3 conditions, we can specify the desired conditions by setting the order of our condition factor. spicy will choose the first level of the factor as the base condition and the second level as the comparison condition. spicy will also naturally coerce the condition column into a factor if it is not already a factor. The column containing cell type annotations can be specified using the cellTypeCol argument. By default, spicy uses the column named cellType in the SpatialExperiment object.\n\nspicyTestPair &lt;- spicy(\n  kerenSPE,\n  condition = \"tumour_type\",\n  from = \"CD8_T_cell\",\n  to = \"Neutrophils\"\n)\n\ntopPairs(spicyTestPair)\n\n                        intercept coefficient      p.value   adj.pvalue\nCD8_T_cell__Neutrophils  -109.081    112.0185 2.166646e-05 2.166646e-05\n                              from          to\nCD8_T_cell__Neutrophils CD8_T_cell Neutrophils\n\n\nWe obtain a spicy object which details the results of the modelling performed. The topPairs() function can be used to obtain the associated coefficients and p-value.\nAs the coefficient in spicyTestPair is positive, we find that neutrophils are significantly more likely to be found near CD8 T cells in the compartmentalised tumours group compared to the cold tumour group.\n\n\n4.1.3 Test for changes in localisation for all pairwise cell combinations\nWe can perform what we did above for all pairwise combinations of cell types by excluding the from and to parameters in spicy().\n\nspicyTest &lt;- spicy(\n  kerenSPE,\n  condition = \"tumour_type\"\n)\n\ntopPairs(spicyTest)\n\n                            intercept coefficient      p.value   adj.pvalue\nMacrophages__dn_T_CD3       56.446064   -50.08474 1.080273e-07 3.035568e-05\ndn_T_CD3__Macrophages       54.987151   -48.38664 2.194018e-07 3.082595e-05\nMacrophages__DC_or_Mono     73.239404   -59.90361 5.224660e-06 4.893765e-04\nDC_or_Mono__Macrophages     71.777087   -58.46833 7.431172e-06 5.220399e-04\ndn_T_CD3__dn_T_CD3         -63.786032   100.61010 2.878804e-05 1.208706e-03\nNeutrophils__dn_T_CD3      -63.141840    69.64356 2.891872e-05 1.208706e-03\ndn_T_CD3__Neutrophils      -63.133725    70.15508 3.011012e-05 1.208706e-03\nDC__Macrophages             96.893239   -92.55112 1.801300e-04 5.758129e-03\nMacrophages__DC             96.896215   -93.25194 1.844241e-04 5.758129e-03\nCD4_T_cell__Keratin_Tumour  -4.845037   -22.14995 2.834659e-04 7.409016e-03\n                                  from             to\nMacrophages__dn_T_CD3      Macrophages       dn_T_CD3\ndn_T_CD3__Macrophages         dn_T_CD3    Macrophages\nMacrophages__DC_or_Mono    Macrophages     DC_or_Mono\nDC_or_Mono__Macrophages     DC_or_Mono    Macrophages\ndn_T_CD3__dn_T_CD3            dn_T_CD3       dn_T_CD3\nNeutrophils__dn_T_CD3      Neutrophils       dn_T_CD3\ndn_T_CD3__Neutrophils         dn_T_CD3    Neutrophils\nDC__Macrophages                     DC    Macrophages\nMacrophages__DC            Macrophages             DC\nCD4_T_cell__Keratin_Tumour  CD4_T_cell Keratin_Tumour\n\n\nAgain, we obtain a spicy object which outlines the result of the linear models performed for each pairwise combination of cell types.\nWe can also examine the L-function metrics of individual images by using the convenient bind() function on our spicyTest results object.\n\nbind(spicyTest)[1:5, 1:5]\n\n  imageID         condition Keratin_Tumour__Keratin_Tumour\n1       1             mixed                      -2.300602\n2       2             mixed                      -1.989699\n3       3 compartmentalised                      11.373530\n4       4 compartmentalised                      33.931133\n5       5 compartmentalised                      17.922818\n  dn_T_CD3__Keratin_Tumour B_cell__Keratin_Tumour\n1                -5.298543             -20.827279\n2               -16.020022               3.025815\n3               -21.857447             -24.962913\n4               -36.438476             -40.470221\n5               -20.816783             -38.138076\n\n\nThe results can be represented as a bubble plot using the signifPlot() function.\n\nsignifPlot(\n  spicyTest,\n  breaks = c(-3, 3, 1),\n  marksToPlot = c(\"Macrophages\", \"DC_or_Mono\", \"dn_T_CD3\", \"Neutrophils\",\n                  \"CD8_T_cell\", \"Keratin_Tumour\")\n)\n\n\n\n\n\n\n\n\nHere, we can observe that the most significant relationships occur between macrophages and double negative CD3 T cells, suggesting that the two cell types are far more dispersed in compartmentalised tumours compared to cold tumours.\nTo examine a specific cell type-cell type relationship in more detail, we can use spicyBoxplot() and specify either from = \"Macrophages\" and to = \"dn_T_CD3\" or rank = 1.\n\nspicyBoxPlot(results = spicyTest, \n             # from = \"Macrophages\",\n             # to = \"dn_T_CD3\"\n             rank = 1)\n\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_boxplot()`).\n\n\n\n\n\n\n\n\n\n\n\n4.1.4 Linear modelling for custom metrics\nspicyR can also be applied to custom distance or abundance metrics. A kNN interactions graph can be generated with the function buildSpatialGraph from the imcRtools package. This generates a colPairs object inside of the SpatialExperiment object.\nspicyR provides the function convPairs for converting a colPairs object into an abundance matrix by calculating the average number of nearby cells types for every cell type for a given k. For example, if there exists on average 5 neutrophils for every macrophage in image 1, the column Neutrophil__Macrophage would have a value of 5 for image 1.\n\nkerenSPE &lt;- imcRtools::buildSpatialGraph(kerenSPE, \n                                         img_id = \"imageID\", \n                                         type = \"knn\", k = 20,\n                                        coords = c(\"x\", \"y\"))\n\n'sample_id's are duplicated across 'SpatialExperiment' objects to cbind; appending sample indices.\n\n\nThe returned object is ordered by the 'imageID' entry.\n\npairAbundances &lt;- convPairs(kerenSPE,\n                  colPair = \"knn_interaction_graph\")\n\nhead(pairAbundances[\"B_cell__B_cell\"])\n\n   B_cell__B_cell\n1      12.7349608\n10      0.2777778\n11      0.0000000\n12      1.3333333\n13      1.2200957\n14      0.0000000\n\n\nThe custom distance or abundance metrics can then be included in the analysis with the alternateResult parameter. The Statial package contains other custom distance metrics which can be used with spicy.\n\nspicyTestColPairs &lt;- spicy(\n  kerenSPE,\n  condition = \"tumour_type\",\n  alternateResult = pairAbundances,\n  weights = FALSE\n)\n\ntopPairs(spicyTestColPairs)\n\n                           intercept coefficient     p.value adj.pvalue\nCD8_T_cell__Neutrophils  0.833333333  -0.7592968 0.002645466  0.3291833\nB_cell__Tumour           0.001937984   0.2602822 0.004872664  0.3291833\nOther_Immune__NK         0.012698413   0.2612881 0.005673068  0.3291833\nUnidentified__CD8_T_cell 0.106626794   0.6387339 0.005906526  0.3291833\ndn_T_CD3__NK             0.004242424   0.2148797 0.006317829  0.3291833\nCD4_T_cell__Neutrophils  0.036213602   0.2947696 0.007902670  0.3291833\nTregs__CD4_T_cell        0.128876212   0.5726201 0.010207087  0.3291833\nEndothelial__DC          0.008771930   0.3008523 0.011189533  0.3291833\nTumour__Neutrophils      0.021638939   0.2529045 0.011388850  0.3291833\nMesenchymal__Neutrophils 0.004504505   0.2494301 0.012761315  0.3291833\n                                 from          to\nCD8_T_cell__Neutrophils    CD8_T_cell Neutrophils\nB_cell__Tumour                 B_cell      Tumour\nOther_Immune__NK         Other_Immune          NK\nUnidentified__CD8_T_cell Unidentified  CD8_T_cell\ndn_T_CD3__NK                 dn_T_CD3          NK\nCD4_T_cell__Neutrophils    CD4_T_cell Neutrophils\nTregs__CD4_T_cell               Tregs  CD4_T_cell\nEndothelial__DC           Endothelial          DC\nTumour__Neutrophils            Tumour Neutrophils\nMesenchymal__Neutrophils  Mesenchymal Neutrophils\n\n\n\nsignifPlot(\n  spicyTestColPairs,\n  breaks = c(-3, 3, 1),\n  marksToPlot = c(\"Macrophages\", \"dn_T_CD3\", \"CD4_T_cell\", \n                  \"B_cell\", \"DC_or_Mono\", \"Neutrophils\", \"CD8_T_cell\")\n)\n\n\n\n\n\n\n\n\n\n\n4.1.5 Performing survival analysis\nspicy can also be used to perform survival analysis to asses whether changes in co-localisation between cell types are associated with survival probability. spicy requires the SingleCellExperiment object being used to contain a column called survival as a Surv object.\n\nkerenSPE$event = 1 - kerenSPE$Censored\nkerenSPE$survival = Surv(kerenSPE$`Survival_days_capped*`, kerenSPE$event)\n\nWe can then perform survival analysis using the spicy function by specifying condition = \"survival\". We can then access the corresponding coefficients and p-values by accessing the survivalResults slot in the spicy results object.\n\n# Running survival analysis\nspicySurvival = spicy(kerenSPE,\n                      condition = \"survival\")\n\n# top 10 significant pairs\nhead(spicySurvival$survivalResults, 10)\n\n# A tibble: 10 × 4\n   test                       coef se.coef    p.value\n   &lt;chr&gt;                     &lt;dbl&gt;   &lt;dbl&gt;      &lt;dbl&gt;\n 1 Other_Immune__Tregs     0.0236  0.00866 0.00000893\n 2 CD4_T_cell__Tregs       0.0177  0.00685 0.0000124 \n 3 Tregs__Other_Immune     0.0237  0.00873 0.0000126 \n 4 Tregs__CD4_T_cell       0.0171  0.00676 0.0000285 \n 5 CD8_T_cell__CD8_T_cell  0.00605 0.00272 0.000332  \n 6 Tumour__CD8_T_cell     -0.0305  0.0114  0.000617  \n 7 CD8_T_cell__Tumour     -0.0305  0.0116  0.000721  \n 8 CD4_T_cell__dn_T_CD3    0.00845 0.00353 0.000794  \n 9 dn_T_CD3__CD4_T_cell    0.00840 0.00353 0.000937  \n10 DC__Other_Immune       -0.0289  0.0123  0.00103   \n\n\n\n\n4.1.6 Accounting for tissue inhomogeneity\nThe spicy function can also account for tissue inhomogeneity to avoid false positives or negatives. This can be done by setting the sigma = parameter within the spicy function. By default, sigma is set to NULL, and spicy assumes a homogeneous tissue structure.\nFor example, when we examine the L-function for Keratin_Tumour__Neutrophils when sigma = NULL and Rs = 100, the value is positive, indicating attraction between the two cell types.\n\n# filter SPE object to obtain image 24 data\nkerenSubset = kerenSPE[, colData(kerenSPE)$imageID == \"24\"]\n\npairwiseAssoc = getPairwise(kerenSubset, \n                            sigma = NULL, \n                            Rs = 100) |&gt;\n  as.data.frame()\n\npairwiseAssoc[[\"Keratin_Tumour__Neutrophils\"]]\n\n[1] 10.88892\n\n\nWhen we specify sigma = 20 and re-calculate the L-function, it indicates that there is no relationship between Keratin_Tumour and Neutrophils, i.e., there is no major attraction or dispersion, as it now takes into account tissue inhomogeneity.\n\npairwiseAssoc = getPairwise(kerenSubset, \n                            sigma = 20, \n                            Rs = 100) |&gt;\n  as.data.frame()\n\npairwiseAssoc[[\"Keratin_Tumour__Neutrophils\"]]\n\n[1] 0.9024836\n\n\n\n# obtain colData for image 24\ncData = colData(kerenSPE) |&gt; as.data.frame() |&gt; \n          dplyr::filter(imageID == \"24\")\n\n# obtain cells present in image 24\ncoords = spatialCoords(kerenSPE) |&gt; as.data.frame()\ncoords$cellID = rownames(coords)\ncoords = coords |&gt; dplyr::filter(cellID %in% cData$CellID)\n\ncData$X = coords$x\ncData$Y = coords$y\n\ncData = cData |&gt; \n  dplyr::mutate(cellTypeNew = ifelse(cellType %in% c(\"Keratin_Tumour\", \"Neutrophils\"), \n                                     cellType, \"Other\"))\n\n pal = setNames(c(\"#d6b11c\", \"#850f07\"), \n                c(\"Keratin_Tumour\", \"Neutrophils\"))\n\nggplot() +\n    stat_density_2d(data = cData, aes(x = X, y = Y, fill = after_stat(density)), \n                    geom = \"raster\", \n                    contour = FALSE) +\n    geom_point(data = cData |&gt; filter(cellType != \"Other\"),\n               aes(x = X, y = Y, colour = cellTypeNew), size = 1) +\n    scale_color_manual(values = pal) +\n    scale_fill_distiller(palette = \"Blues\", direction = 1) +\n    theme_classic() +\n    labs(title = \"image ID: 24\")\n\n\n\n\n\n\n\n\nPlotting image 24 shows that the supposed co-localisation occurs due to the dense cluster of cells near the top of the image.\n\n\n4.1.7 Mixed effects modelling\nspicyR supports mixed effects modelling when multiple images are obtained for each subject. In this case, subject is treated as a random effect and condition is treated as a fixed effect. To perform mixed effects modelling, we can specify the subject parameter in the spicy function.\n\nspicyMixedTest &lt;- spicy(\n  diabetesData,\n  condition = \"stage\",\n  subject = \"case\"\n)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Cell localisation</span>"
    ]
  },
  {
    "objectID": "04-cell_localisation.html#kontextual-context-aware-cell-localisation",
    "href": "04-cell_localisation.html#kontextual-context-aware-cell-localisation",
    "title": "4  Cell localisation",
    "section": "4.2 Kontextual: Context aware cell localisation",
    "text": "4.2 Kontextual: Context aware cell localisation\nKontextual is a method for performing inference on cell localisation which explicitly defines the contexts in which spatial relationships between cells can be identified and interpreted. These contexts may represent landmarks, spatial domains, or groups of functionally similar cells which are consistent across regions. By modelling spatial relationships between cells relative to these contexts, Kontextual produces robust spatial quantifications that are not confounded by biases such as the choice of region to image and the tissue structure present in the images.\nIn this example we demonstrate how cell type hierarchies can be used as a means to derive appropriate “contexts” for the evaluation of cell localisation. We then demonstrate the types of conclusions which Kontextual enables.\n\n4.2.1 Using cell type hierarchies to define a “context”\nA cell type hierarchy may be used to define the “context” in which cell type relationships are evaluated within. A cell type hierarchy defines how cell types are functionally related to one another. The bottom of the hierarchy represents homogeneous populations of a cell type (child), the cell populations at the nodes of the hierarchy represent broader parent populations with shared generalised function. For example CD4 T cells may be considered a child population to the Immune parent population.\nThere are two ways to define the cell type hierarchy. First, they can be defined based on our biological understanding of the cell types. We can represent this by creating a named list containing the names of each parent and the associated vector of child cell types.\nNote: The all vector must be created to include cell types which do not have a parent e.g. the undefined cell type in this data set.\n\n# Examine all cell types in image\nunique(kerenSPE$cellType)\n\n [1] \"Keratin_Tumour\" \"dn_T_CD3\"       \"B_cell\"         \"CD4_T_cell\"    \n [5] \"DC_or_Mono\"     \"Unidentified\"   \"Macrophages\"    \"CD8_T_cell\"    \n [9] \"Other_Immune\"   \"Endothelial\"    \"Mono_or_Neu\"    \"Mesenchymal\"   \n[13] \"Neutrophils\"    \"NK\"             \"Tumour\"         \"DC\"            \n[17] \"Tregs\"         \n\n# Named list of parents and their child cell types\nbiologicalHierarchy = list(\n  \"tumour\" = c(\"Keratin_Tumour\", \"Tumour\"),\n  \"tcells\" = c(\"dn_T_CD3\", \"CD4_T_cell\", \"CD8_T_cell\", \"Tregs\"),\n  \"myeloid\" = c(\"DC_or_Mono\", \"DC\", \"Mono_or_Neu\", \"Macrophages\", \"Neutrophils\"),\n  \"tissue\" = c(\"Endothelial\", \"Mesenchymal\")\n)\n\n# Adding more broader immune parent populationse\nbiologicalHierarchy$immune = c(biologicalHierarchy$bcells,\n                               biologicalHierarchy$tcells,\n                               biologicalHierarchy$myeloid,\n                               \"NK\", \"Other_Immune\", \"B_cell\")\n\n\n# Creating a vector for all cellTypes\nall &lt;- unique(kerenSPE$cellType)\n\nAlternatively, you can use the treeKor bioconductor package treekoR to define these hierarchies in a data driven way.\nNote: These parent populations may not be accurate as we are using a small subset of the data.\n\n# Calculate hierarchy using treekoR\nkerenTree &lt;- treekoR::getClusterTree(t(assay(kerenSPE, \"intensities\")),\n                            kerenSPE$cellType,\n                            hierarchy_method=\"hopach\",\n                            hopach_K = 1)\n\n# Convert treekoR result to a name list of parents and children.\ntreekorParents = getParentPhylo(kerenTree)\n\ntreekorParents\n\n$parent_1\n [1] \"Keratin_Tumour\" \"DC_or_Mono\"     \"Unidentified\"   \"Macrophages\"   \n [5] \"Endothelial\"    \"Mono_or_Neu\"    \"Mesenchymal\"    \"Neutrophils\"   \n [9] \"Tumour\"         \"DC\"            \n\n$parent_2\n[1] \"dn_T_CD3\"     \"B_cell\"       \"CD4_T_cell\"   \"CD8_T_cell\"   \"Other_Immune\"\n[6] \"NK\"           \"Tregs\"       \n\n\n\n\n4.2.2 Application on triple negative breast cancer image.\nHere we examine an image highlighted in the Keren et al. 2018 manuscript where accounting for context information enables new conclusions. In image 6 of the Keren et al. dataset, we can see that p53+ tumour cells and immune cells are dispersed i.e. these two cell types are not mixing. However we can also see that p53+ tumour cells appear much more localised to immune cells relative to the tumour context (tumour cells and p53+ tumour cells).\n\n# Lets define a new cell type vector\nkerenSPE$cellTypeNew &lt;- kerenSPE$cellType\n\n# Select for all cells that express higher than baseline level of p53\np53Pos &lt;- assay(kerenSPE)[\"p53\", ] &gt; -0.300460\n\n# Find p53+ tumour cells\nkerenSPE$cellTypeNew[kerenSPE$cellType %in% biologicalHierarchy$tumour] &lt;- \"Tumour\"\nkerenSPE$cellTypeNew[p53Pos & kerenSPE$cellType %in% biologicalHierarchy$tumour] &lt;- \"p53_Tumour\"\n\n# Group all immune cells under the name \"Immune\"\nkerenSPE$cellTypeNew[kerenSPE$cellType %in% biologicalHierarchy$immune] &lt;- \"Immune\"\n\nkerenSPE$x &lt;- spatialCoords(kerenSPE)[,\"x\"]\nkerenSPE$y &lt;- spatialCoords(kerenSPE)[,\"y\"]\n\n# Plot image 6\nkerenSPE |&gt;\n  colData() |&gt;\n  as.data.frame() |&gt;\n  filter(imageID == \"6\") |&gt;\n  filter(cellTypeNew %in% c(\"Immune\", \"Tumour\", \"p53_Tumour\")) |&gt;\n  arrange(cellTypeNew) |&gt;\n  ggplot(aes(x = x, y = y, color = cellTypeNew)) +\n  geom_point(size = 1) +\n  scale_colour_manual(values = c(\"Immune\" = \"#505050\", \"p53_Tumour\" = \"#64BC46\", \"Tumour\" = \"#D6D6D6\")) +\n  guides(colour = guide_legend(title = \"Cell types\", override.aes = list(size = 3)))\n\n\n\n\n\n\n\n\nKontextual accepts a SingleCellExperiment object, a single image, or list of images from a SingleCellExperiment object, which gets passed into the cells argument. The two cell types which will be evaluated are specified in the to and from arguments. A parent population must also be specified in the parent argument, note the parent cell population must include the to cell type. The argument r will specify the radius which the cell relationship will be evaluated on. Kontextual supports parallel processing, the number of cores can be specified using the cores argument. Kontextual can take a single value or multiple values for each argument and will test all combinations of the arguments specified.\nWe can calculate these relationships across all images for a single radius (r = 100). Small radii will examine local spatial relationships, whereas larger radii will examine global spatial relationships.\n\np53_Kontextual &lt;- Kontextual(\n  cells = kerenSPE,\n  r = 100,\n  from = \"Immune\",\n  to = \"p53_Tumour\",\n  parent = c(\"p53_Tumour\", \"Tumour\"),\n  cellType = \"cellTypeNew\"\n)\n\np53_Kontextual\n\n   imageID               test   original  kontextual   r inhomL\n1        1 Immune__p53_Tumour -16.212016  -1.6815952 100  FALSE\n2       10 Immune__p53_Tumour -14.715356  -1.7937407 100  FALSE\n3       11 Immune__p53_Tumour -11.696597  -7.4615661 100  FALSE\n4       12 Immune__p53_Tumour  -9.777271  -2.6287005 100  FALSE\n5       13 Immune__p53_Tumour -15.613023  -3.9937364 100  FALSE\n6       14 Immune__p53_Tumour -14.671281  -4.2879138 100  FALSE\n7       15 Immune__p53_Tumour   8.369183  10.6710168 100  FALSE\n8       16 Immune__p53_Tumour -41.081088 -20.9688333 100  FALSE\n9       17 Immune__p53_Tumour  -6.331105   5.0017104 100  FALSE\n10      18 Immune__p53_Tumour  -1.953366   0.5795853 100  FALSE\n11      19 Immune__p53_Tumour -27.834450 -18.7433000 100  FALSE\n12       2 Immune__p53_Tumour  -4.989150  -0.5330373 100  FALSE\n13      20 Immune__p53_Tumour -20.580091  -9.2542544 100  FALSE\n14      21 Immune__p53_Tumour -14.300802  -7.1425133 100  FALSE\n15      22 Immune__p53_Tumour -13.673007 -12.9663547 100  FALSE\n16      23 Immune__p53_Tumour  15.803493  37.3584378 100  FALSE\n17      24 Immune__p53_Tumour -30.319961 -31.8146274 100  FALSE\n18      25 Immune__p53_Tumour   6.262995   6.9429103 100  FALSE\n19      26 Immune__p53_Tumour -38.190137 -24.6000029 100  FALSE\n20      27 Immune__p53_Tumour  -2.373587   4.4044397 100  FALSE\n21      28 Immune__p53_Tumour -70.058615 -33.4395839 100  FALSE\n22      29 Immune__p53_Tumour -20.728463  -7.0172785 100  FALSE\n23       3 Immune__p53_Tumour   1.719549  44.5060581 100  FALSE\n24      31 Immune__p53_Tumour -12.306957  -5.2820792 100  FALSE\n25      32 Immune__p53_Tumour -18.174569 -10.8972277 100  FALSE\n26      33 Immune__p53_Tumour -19.750457 -19.6246151 100  FALSE\n27      34 Immune__p53_Tumour -49.004947 -35.1320255 100  FALSE\n28      35 Immune__p53_Tumour -75.980619 -66.2395276 100  FALSE\n29      36 Immune__p53_Tumour -18.853398 -21.4398044 100  FALSE\n30      37 Immune__p53_Tumour -43.624905 -27.7162991 100  FALSE\n31      38 Immune__p53_Tumour -12.544687  -3.0415484 100  FALSE\n32      39 Immune__p53_Tumour -19.293290  -4.5192485 100  FALSE\n33       4 Immune__p53_Tumour         NA          NA 100  FALSE\n34      40 Immune__p53_Tumour -37.744261 -27.9604962 100  FALSE\n35      41 Immune__p53_Tumour -33.776940 -22.6113096 100  FALSE\n36       5 Immune__p53_Tumour         NA          NA 100  FALSE\n37       6 Immune__p53_Tumour -24.897348  -1.2724241 100  FALSE\n38       7 Immune__p53_Tumour -13.068307   0.6361875 100  FALSE\n39       8 Immune__p53_Tumour         NA          NA 100  FALSE\n40       9 Immune__p53_Tumour -31.857501   1.0261067 100  FALSE\n\n\nThe kontextCurve function plots the L-function value and Kontextual values over a range of radii. If the points lie above the red line (expected pattern) then localisation is indicated for that radius, if the points lie below the red line then dispersion is indicated.\nAs seen in the following plot the L-function produces negative values over a range of radii, indicating that p53+ tumour cells and immune cells are dispersed from one another. However by taking into account the tumour context, Kontextual shows positive values over some radii, indicating localisation between p53+ tumour cells and immune cells.\n\ncurves &lt;- kontextCurve(\n  cells = kerenSPE,\n  from = \"Immune\",\n  to = \"p53_Tumour\",\n  parent = c(\"p53_Tumour\", \"Tumour\"),\n  rs = seq(50, 510, 50),\n  image = \"6\",\n  cellType = \"cellTypeNew\",\n  cores = nCores\n)\n\nkontextPlot(curves)\n\n\n\n\n\n\n\n\nAlternatively all pairwise cell relationships and their corresponding parent in the dataset can be tested. A data frame with all pairwise combinations can be creating using the parentCombinations function. This function takes in a vector of all the cells, as well as the named list of parents and children created earlier in the parentList argument. As shown below the output is a data frame specifying the to, from, and parent arguments for Kontextual.\nNote: the output of getPhyloParent may also be using the in the parentList argument, for example if you wanted to use the treekoR defined hierarchy instead.\n\n# Get all relationships between cell types and their parents\nparentDf &lt;- parentCombinations(\n  all = all,\n  parentList = biologicalHierarchy\n)\n\n\n\n4.2.3 Calculating all pairwise relationships\nRather than specifying to, from, and parent in Kontextual, the output from parentCombinations can be inputed into Kontextual using the parentDf argument, to examine all pairwise relationships in the dataset. This chunk will take a significant amount of time to run, for demonstration the results have been saved and are loaded in.\n\n# Running Kontextual on all relationships across all images.\nkerenKontextual &lt;- Kontextual(\n  cells = kerenSPE,\n  parentDf = parentDf,\n  r = 100,\n  cores = nCores\n)\n\nFor every pairwise relationship (named accordingly: from__to__parent) Kontextual outputs the L-function values (original) and the Kontextual value. The relationships where the L-function and Kontextual disagree (e.g. one metric is positive and the other is negative) represent relationships where adding context information results in different conclusions on the spatial relationship between the two cell types.\n\n\n4.2.4 Associating the relationships with survival outcomes.\nTo examine whether the features obtained from Statial are associated with patient outcomes or groupings, we can use the spicy function from the spicyR package.\nIn addition to this, the Kontextual results must be converted from a data.frame to a wide matrix, this can be done using prepMatrix. Note, to extract the original L-function values, specify column = \"original\" in prepMatrix.\n\n# Converting Kontextual result into data matrix\nkontextMat &lt;- prepMatrix(kerenKontextual)\n\n# Ensuring rownames of kontextMat match up with the image IDs of the SCE object\nkontextMat &lt;- kontextMat[kerenSPE$imageID |&gt; unique(), ]\n\n# Replace NAs with 0\nkontextMat[is.na(kontextMat)] &lt;- 0\n\nFinally, both the SingleCellExperiment object and the Kontextual matrix are passed into the spicy function, with condition = \"survival\". The resulting coefficients and p values can be obtained by accessing the survivalResults name.\nNote: You can specify additional covariates and include a subject id for mixed effects survival modelling, see spicyR for more information.\n\nkerenSPE$event = 1 - kerenSPE$Censored\nkerenSPE$survival = Surv(kerenSPE$`Survival_days_capped*`, kerenSPE$event)\n\n# Running survival analysis\nsurvivalResults = spicy(cells = kerenSPE,\n                        alternateResult = kontextMat,\n                        condition = \"survival\",\n                        weights = TRUE)\n\nhead(survivalResults$survivalResults, 10)\n\n# A tibble: 10 × 4\n   test                                    coef se.coef     p.value\n   &lt;chr&gt;                                  &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n 1 dn_T_CD3__Tregs__immune               0.0187 0.00716 0.000000572\n 2 Other_Immune__Tregs__immune           0.0255 0.00885 0.000000727\n 3 Tregs__dn_T_CD3__immune               0.0189 0.00715 0.00000169 \n 4 Neutrophils__CD8_T_cell__immune       0.0178 0.00651 0.00000172 \n 5 DC__dn_T_CD3__immune                 -0.0195 0.00661 0.00000710 \n 6 DC__dn_T_CD3__tcells                 -0.0171 0.00758 0.0000167  \n 7 Other_Immune__Keratin_Tumour__tumour  0.137  0.0406  0.0000212  \n 8 CD4_T_cell__Tregs__immune             0.0216 0.00901 0.0000306  \n 9 Other_Immune__DC__myeloid            -0.0181 0.00664 0.0000492  \n10 Other_Immune__DC__immune             -0.0186 0.00669 0.0000656  \n\n\nThe survival results can also be visualised using the signifPlot function.\n\nsignifPlot(survivalResults)\n\n\n\n\n\n\n\n\nAs we can see from the results DC__NK__immune is the one of the most significant pairwise relationship which contributes to patient survival. That is the relationship between dendritic cells and natural killer cells, relative to the parent population of immune cells. We can see that there is a negative coefficient associated with this relationship, which tells us an increase in localisation of these cell types relative to immune cells leads to better survival outcomes for patients.\nThe association between DC__NK__immune and survival can also be visualised on a Kaplan-Meier curve. First, we extract survival data from the SingleCellExperiment object and create a survival vector.\n\n# Extracting survival data\nsurvData &lt;- kerenSPE |&gt;\n  colData() |&gt;\n  data.frame() |&gt;\n  select(imageID, survival) |&gt;\n  unique()\n\n# Creating survival vector\nkerenSurv &lt;- survData$survival\nnames(kerenSurv) &lt;- survData$imageID\n\nkerenSurv\n\n    1     2     3     4     5     6     7     8     9    10    11    12    13 \n 2612   745 3130+ 2523+ 1683+ 2275+   584   946 3767+ 3822+ 3774+ 4353+  1072 \n   14    15    16    17    18    19    20    21    22    23    24    25    26 \n4145+  1754   530  2842 5063+ 3725+ 4761+   635   NA?    91   194 4785+ 4430+ \n   27    28    29    31    32    33    34    35    36    37    38    39    40 \n 3658 3767+  1319  1009 1568+ 1738+ 2832+ 2759+ 3063+ 2853+   NA? 2096+  3573 \n   41 \n3355+ \n\n\nNext, we extract the Kontextual values of this relationship across all images. We then determine if dendritic and natural killer cells are relatively attracted or avoiding in each image by comparing the Kontextual value in each image to the median Kontextual value.\nFinally, we plot a Kaplan-Meier curve using the ggsurvfit package. As shown below, when dendritic and natural killer cells are more localised to one another relative to the immune cell population, patients tend to have better survival outcomes.\n\n# Selecting most significant relationship\nsurvRelationship &lt;- kontextMat[[\"DC__NK__immune\"]]\nsurvRelationship &lt;- ifelse(survRelationship &gt; median(survRelationship), \"Localised\", \"Dispersed\")\n\n# Plotting Kaplan-Meier curve\nsurvfit2(kerenSurv ~ survRelationship) |&gt;\n  ggsurvfit() +\n  ggtitle(\"DC__NK__immune\")",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Cell localisation</span>"
    ]
  },
  {
    "objectID": "04-cell_localisation.html#sessioninfo",
    "href": "04-cell_localisation.html#sessioninfo",
    "title": "4  Cell localisation",
    "section": "4.3 sessionInfo",
    "text": "4.3 sessionInfo\n\nsessionInfo()\n\nR version 4.4.1 (2024-06-14)\nPlatform: x86_64-pc-linux-gnu\nRunning under: Debian GNU/Linux 12 (bookworm)\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 \nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.21.so;  LAPACK version 3.11.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Australia/Sydney\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] ggsurvfit_1.1.0             treekoR_1.14.0             \n [3] tibble_3.2.1                survival_3.7-0             \n [5] dplyr_1.1.4                 imcRtools_1.12.0           \n [7] SpatialDatasets_1.4.0       ExperimentHub_2.14.0       \n [9] AnnotationHub_3.14.0        BiocFileCache_2.14.0       \n[11] dbplyr_2.5.0                SpatialExperiment_1.16.0   \n[13] SingleCellExperiment_1.28.1 SummarizedExperiment_1.36.0\n[15] Biobase_2.66.0              GenomicRanges_1.58.0       \n[17] GenomeInfoDb_1.42.0         IRanges_2.40.0             \n[19] S4Vectors_0.44.0            BiocGenerics_0.52.0        \n[21] MatrixGenerics_1.18.0       matrixStats_1.4.1          \n[23] ggplot2_3.5.1               Statial_1.8.0              \n[25] spicyR_1.18.0              \n\nloaded via a namespace (and not attached):\n  [1] vroom_1.6.5                 tiff_0.1-12                \n  [3] goftest_1.2-3               DT_0.33                    \n  [5] Biostrings_2.74.0           HDF5Array_1.34.0           \n  [7] TH.data_1.1-2               vctrs_0.6.5                \n  [9] spatstat.random_3.3-2       digest_0.6.37              \n [11] png_0.1-8                   shape_1.4.6.1              \n [13] proxy_0.4-27                ggrepel_0.9.6              \n [15] deldir_2.0-4                magick_2.8.5               \n [17] MASS_7.3-61                 reshape2_1.4.4             \n [19] httpuv_1.6.15               foreach_1.5.2              \n [21] withr_3.0.2                 ggfun_0.1.7                \n [23] xfun_0.49                   ggpubr_0.6.0               \n [25] memoise_2.0.1               RTriangle_1.6-0.14         \n [27] cytomapper_1.18.0           ggbeeswarm_0.7.2           \n [29] RProtoBufLib_2.18.0         systemfonts_1.1.0          \n [31] tidytree_0.4.6              zoo_1.8-12                 \n [33] GlobalOptions_0.1.2         Formula_1.2-5              \n [35] KEGGREST_1.46.0             promises_1.3.0             \n [37] httr_1.4.7                  rstatix_0.7.2              \n [39] rhdf5filters_1.18.0         rhdf5_2.50.0               \n [41] rstudioapi_0.17.1           UCSC.utils_1.2.0           \n [43] units_0.8-5                 generics_0.1.3             \n [45] concaveman_1.1.0            curl_6.0.1                 \n [47] zlibbioc_1.52.0             ggraph_2.2.1               \n [49] polyclip_1.10-7             GenomeInfoDbData_1.2.13    \n [51] SparseArray_1.6.0           fftwtools_0.9-11           \n [53] xtable_1.8-4                stringr_1.5.1              \n [55] doParallel_1.0.17           evaluate_1.0.1             \n [57] S4Arrays_1.6.0              hms_1.1.3                  \n [59] colorspace_2.1-1            filelock_1.0.3             \n [61] spatstat.data_3.1-2         magrittr_2.0.3             \n [63] readr_2.1.5                 later_1.3.2                \n [65] viridis_0.6.5               ggtree_3.14.0              \n [67] lattice_0.22-6              spatstat.geom_3.3-3        \n [69] XML_3.99-0.17               scuttle_1.16.0             \n [71] ggupset_0.4.0               class_7.3-22               \n [73] svgPanZoom_0.3.4            pillar_1.9.0               \n [75] nlme_3.1-166                iterators_1.0.14           \n [77] EBImage_4.48.0              compiler_4.4.1             \n [79] beachmat_2.22.0             stringi_1.8.4              \n [81] sf_1.0-19                   tensor_1.5                 \n [83] minqa_1.2.8                 ClassifyR_3.10.0           \n [85] plyr_1.8.9                  crayon_1.5.3               \n [87] abind_1.4-8                 gridGraphics_0.5-1         \n [89] locfit_1.5-9.10             sp_2.1-4                   \n [91] graphlayouts_1.2.0          bit_4.5.0                  \n [93] terra_1.7-83                sandwich_3.1-1             \n [95] codetools_0.2-20            multcomp_1.4-26            \n [97] e1071_1.7-16                GetoptLong_1.0.5           \n [99] plotly_4.10.4               mime_0.12                  \n[101] MultiAssayExperiment_1.32.0 splines_4.4.1              \n[103] circlize_0.4.16             Rcpp_1.0.13-1              \n[105] knitr_1.49                  blob_1.2.4                 \n[107] utf8_1.2.4                  clue_0.3-66                \n[109] BiocVersion_3.20.0          lme4_1.1-35.5              \n[111] fs_1.6.5                    nnls_1.6                   \n[113] ggplotify_0.1.2             ggsignif_0.6.4             \n[115] Matrix_1.7-1                scam_1.2-17                \n[117] statmod_1.5.0               tzdb_0.4.0                 \n[119] svglite_2.1.3               tweenr_2.0.3               \n[121] pkgconfig_2.0.3             pheatmap_1.0.12            \n[123] tools_4.4.1                 cachem_1.1.0               \n[125] RSQLite_2.3.7               viridisLite_0.4.2          \n[127] DBI_1.2.3                   numDeriv_2016.8-1.1        \n[129] fastmap_1.2.0               rmarkdown_2.29             \n[131] scales_1.3.0                grid_4.4.1                 \n[133] shinydashboard_0.7.2        broom_1.0.7                \n[135] patchwork_1.3.0             BiocManager_1.30.25        \n[137] carData_3.0-5               farver_2.1.2               \n[139] tidygraph_1.3.1             mgcv_1.9-1                 \n[141] yaml_2.3.10                 ggthemes_5.1.0             \n[143] cli_3.6.3                   purrr_1.0.2                \n[145] hopach_2.66.0               lifecycle_1.0.4            \n[147] mvtnorm_1.3-2               backports_1.5.0            \n[149] BiocParallel_1.40.0         cytolib_2.18.0             \n[151] gtable_0.3.6                rjson_0.2.23               \n[153] parallel_4.4.1              ape_5.8                    \n[155] limma_3.62.1                jsonlite_1.8.9             \n[157] edgeR_4.4.0                 bitops_1.0-9               \n[159] bit64_4.5.2                 Rtsne_0.17                 \n[161] FlowSOM_2.14.0              yulab.utils_0.1.8          \n[163] spatstat.utils_3.1-1        BiocNeighbors_2.0.0        \n[165] ranger_0.17.0               flowCore_2.18.0            \n[167] bdsmatrix_1.3-7             spatstat.univar_3.1-1      \n[169] lazyeval_0.2.2              shiny_1.9.1                \n[171] ConsensusClusterPlus_1.70.0 htmltools_0.5.8.1          \n[173] diffcyt_1.26.0              rappdirs_0.3.3             \n[175] distances_0.1.11            glue_1.8.0                 \n[177] XVector_0.46.0              RCurl_1.98-1.16            \n[179] treeio_1.30.0               classInt_0.4-10            \n[181] coxme_2.2-22                jpeg_0.1-10                \n[183] gridExtra_2.3               boot_1.3-31                \n[185] igraph_2.1.1                R6_2.5.1                   \n[187] tidyr_1.3.1                 ggiraph_0.8.10             \n[189] labeling_0.4.3              ggh4x_0.2.8                \n[191] cluster_2.1.6               Rhdf5lib_1.28.0            \n[193] aplot_0.2.3                 nloptr_2.1.1               \n[195] DelayedArray_0.32.0         tidyselect_1.2.1           \n[197] vipor_0.4.7                 ggforce_0.4.2              \n[199] raster_3.6-30               car_3.1-3                  \n[201] AnnotationDbi_1.68.0        munsell_0.5.1              \n[203] KernSmooth_2.23-24          data.table_1.16.2          \n[205] htmlwidgets_1.6.4           ComplexHeatmap_2.22.0      \n[207] RColorBrewer_1.1-3          rlang_1.1.4                \n[209] spatstat.sparse_3.1-0       spatstat.explore_3.3-3     \n[211] lmerTest_3.1-3              uuid_1.2-1                 \n[213] colorRamps_2.3.4            ggnewscale_0.5.0           \n[215] fansi_1.0.6                 beeswarm_0.4.0",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Cell localisation</span>"
    ]
  },
  {
    "objectID": "05-cellular_niches.html",
    "href": "05-cellular_niches.html",
    "title": "5  Spatial domains",
    "section": "",
    "text": "5.1 Why look at spatial domains?\nBeyond spatial relationships between cell types, imaging datasets also contain another source of rich information - spatial domains. To give an idea of what spatial domains might visually look like, we’ve provided an image on the right, where we can clearly map out our healthy epithelial tissue spatial domain on the left of the image, and our immune and tumour domains on the right of the image.\nHowever, spatial domains tend to be highly dependent on the biological question being answered. For example, when your primary tissue of interest are solid tumours, spatial domain analysis can provide insights into proportion of tumour domain vs immune domains, or how tumour domains differ between progressive and non-progressive cancers. Alternatively, if your primary tissue of interest is diabetes, spatial domains can provide insights into marker or cell type differences in your pancreatic islets.\nIn this section, we’ll be exploring the use of lisaClust on two different datasets to help inform\n# load required packages\nlibrary(lisaClust)\nlibrary(spicyR)\nlibrary(ggplot2)\nlibrary(SingleCellExperiment)\nlibrary(SpatialDatasets)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Spatial domains</span>"
    ]
  },
  {
    "objectID": "05-cellular_niches.html#lisaclust",
    "href": "05-cellular_niches.html#lisaclust",
    "title": "5  Spatial domains",
    "section": "5.2 lisaClust",
    "text": "5.2 lisaClust\nClustering local indicators of spatial association (LISA) functions is a methodology for identifying consistent spatial organisation of multiple cell-types in an unsupervised way. This can be used to enable the characterization of interactions between multiple cell-types simultaneously and can complement traditional pairwise analysis. In our implementation our LISA curves are a localised summary of an L-function from a Poisson point process model. Our framework lisaClust can be used to provide a high-level summary of cell-type colocalization in high-parameter spatial cytometry data, facilitating the identification of distinct tissue compartments or identification of complex cellular microenvironments.\n\n\n5.2.1 How lisaClust works\nThe workflow that lisaClust uses to identify regions of tissue with similar localisation patterns of cells contains multiple key steps. First, cells are treated as objects and assigned coordinates in an x-y space. Second, distances between all cells are calculated and then, by modeling the cells as a multi-type Poisson point process, the distances are used to calculate local indicators of spatial association (LISA). These LISA curves summarize the spatial association between each cell and a specific cell type over a range of radii, r. The LISA curves are calculated for each cell and cell type and then clustered to assign a region label for each cell.\n\n\n5.2.2 Case study: Keren\nWe will start by reading in the data from the SpatialDatasets package as a SingleCellExperiment object. Here the data is in a format consistent with that outputted by CellProfiler.\n\nkerenSPE &lt;- SpatialDatasets::spe_Keren_2018()\n\nsee ?SpatialDatasets and browseVignettes('SpatialDatasets') for documentation\n\n\nloading from cache\n\n\n\n5.2.2.1 Generate LISA curves\nThis data includes annotation of the cell-types of each cell. Hence, we can move directly to performing k-means clustering on the local indicators of spatial association (LISA) functions using the lisaClust function, remembering to specify the imageID, cellType, and spatialCoords columns in colData. For the purpose of demonstration, we will be using only images 5 and 6 of the kerenSPE dataset.\n\nkerenSPE &lt;- kerenSPE[,kerenSPE$imageID %in% c(\"5\", \"6\")]\n\nkerenSPE &lt;- lisaClust(kerenSPE,\n  k = 5\n)\n\nGenerating local L-curves.\n\n\nThese regions are stored in colData and can be extracted.\n\ncolData(kerenSPE)[, c(\"imageID\", \"region\")] |&gt;\n  head(20)\n\nDataFrame with 20 rows and 2 columns\n          imageID      region\n      &lt;character&gt; &lt;character&gt;\n21154           5    region_2\n21155           5    region_2\n21156           5    region_2\n21157           5    region_5\n21158           5    region_5\n...           ...         ...\n21169           5    region_5\n21170           5    region_5\n21171           5    region_3\n21172           5    region_5\n21173           5    region_3\n\n\n\n\n5.2.2.2 Examine cell type enrichment\nlisaClust also provides a convenient function, regionMap, for examining which cell types are located in which regions. In this example, we use this to check which cell types appear more frequently in each region than expected by chance.\nHere, we clearly see that healthy epithelial and mesenchymal tissue are highly concentrated in region 1, immune cells are concentrated in regions 2 and 4, whilst tumour cells are concentrated in region 3.\nWe can further segregate these cells by increasing the number of clusters, i.e., increasing the parameter k = in the lisaClust() function. For the purposes of demonstration, let’s take a look at the hatchingPlot of these regions.\n\nregionMap(kerenSPE,\n  type = \"bubble\"\n)\n\n\n\n\n\n\n\n\n\n\n5.2.2.3 Plot identified regions\nFinally, we can use hatchingPlot to construct a ggplot object where the regions are marked by different hatching patterns. This allows us to visualize the 5 regions and 17 cell-types simultaneously.\n\nhatchingPlot(kerenSPE, nbp = 300)\n\nConcave windows are temperamental. Try choosing values of window.length &gt; and &lt; 1 if you have problems.\n\n\nWarning in split.default(x = seq_len(nrow(x)), f = f, drop = drop, ...): data\nlength is not a multiple of split variable\nWarning in split.default(x = seq_len(nrow(x)), f = f, drop = drop, ...): data\nlength is not a multiple of split variable",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Spatial domains</span>"
    ]
  },
  {
    "objectID": "05-cellular_niches.html#sessioninfo",
    "href": "05-cellular_niches.html#sessioninfo",
    "title": "5  Spatial domains",
    "section": "5.3 sessionInfo",
    "text": "5.3 sessionInfo\n\nsessionInfo()\n\nR version 4.4.1 (2024-06-14)\nPlatform: x86_64-pc-linux-gnu\nRunning under: Debian GNU/Linux 12 (bookworm)\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 \nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.21.so;  LAPACK version 3.11.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Australia/Sydney\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] SpatialDatasets_1.4.0       SpatialExperiment_1.16.0   \n [3] ExperimentHub_2.14.0        AnnotationHub_3.14.0       \n [5] BiocFileCache_2.14.0        dbplyr_2.5.0               \n [7] SingleCellExperiment_1.28.1 SummarizedExperiment_1.36.0\n [9] Biobase_2.66.0              GenomicRanges_1.58.0       \n[11] GenomeInfoDb_1.42.0         IRanges_2.40.0             \n[13] S4Vectors_0.44.0            BiocGenerics_0.52.0        \n[15] MatrixGenerics_1.18.0       matrixStats_1.4.1          \n[17] ggplot2_3.5.1               spicyR_1.18.0              \n[19] lisaClust_1.14.4           \n\nloaded via a namespace (and not attached):\n  [1] RColorBrewer_1.1-3          rstudioapi_0.17.1          \n  [3] jsonlite_1.8.9              MultiAssayExperiment_1.32.0\n  [5] magrittr_2.0.3              spatstat.utils_3.1-1       \n  [7] magick_2.8.5                farver_2.1.2               \n  [9] nloptr_2.1.1                rmarkdown_2.29             \n [11] zlibbioc_1.52.0             vctrs_0.6.5                \n [13] memoise_2.0.1               minqa_1.2.8                \n [15] spatstat.explore_3.3-3      rstatix_0.7.2              \n [17] htmltools_0.5.8.1           S4Arrays_1.6.0             \n [19] curl_6.0.1                  broom_1.0.7                \n [21] SparseArray_1.6.0           Formula_1.2-5              \n [23] htmlwidgets_1.6.4           plyr_1.8.9                 \n [25] cachem_1.1.0                mime_0.12                  \n [27] lifecycle_1.0.4             pkgconfig_2.0.3            \n [29] Matrix_1.7-1                R6_2.5.1                   \n [31] fastmap_1.2.0               GenomeInfoDbData_1.2.13    \n [33] digest_0.6.37               numDeriv_2016.8-1.1        \n [35] colorspace_2.1-1            AnnotationDbi_1.68.0       \n [37] tensor_1.5                  RSQLite_2.3.7              \n [39] ggpubr_0.6.0                labeling_0.4.3             \n [41] filelock_1.0.3              fansi_1.0.6                \n [43] spatstat.sparse_3.1-0       httr_1.4.7                 \n [45] polyclip_1.10-7             abind_1.4-8                \n [47] mgcv_1.9-1                  compiler_4.4.1             \n [49] bit64_4.5.2                 withr_3.0.2                \n [51] backports_1.5.0             BiocParallel_1.40.0        \n [53] carData_3.0-5               DBI_1.2.3                  \n [55] ggupset_0.4.0               ggforce_0.4.2              \n [57] coxme_2.2-22                ggsignif_0.6.4             \n [59] MASS_7.3-61                 concaveman_1.1.0           \n [61] rappdirs_0.3.3              DelayedArray_0.32.0        \n [63] rjson_0.2.23                tools_4.4.1                \n [65] goftest_1.2-3               glue_1.8.0                 \n [67] nlme_3.1-166                grid_4.4.1                 \n [69] ClassifyR_3.10.0            reshape2_1.4.4             \n [71] generics_0.1.3              gtable_0.3.6               \n [73] spatstat.data_3.1-2         class_7.3-22               \n [75] tidyr_1.3.1                 data.table_1.16.2          \n [77] car_3.1-3                   utf8_1.2.4                 \n [79] XVector_0.46.0              spatstat.geom_3.3-3        \n [81] BiocVersion_3.20.0          pillar_1.9.0               \n [83] stringr_1.5.1               splines_4.4.1              \n [85] dplyr_1.1.4                 tweenr_2.0.3               \n [87] lattice_0.22-6              survival_3.7-0             \n [89] bit_4.5.0                   deldir_2.0-4               \n [91] tidyselect_1.2.1            Biostrings_2.74.0          \n [93] knitr_1.49                  V8_6.0.0                   \n [95] xfun_0.49                   pheatmap_1.0.12            \n [97] fftwtools_0.9-11            scam_1.2-17                \n [99] stringi_1.8.4               UCSC.utils_1.2.0           \n[101] yaml_2.3.10                 boot_1.3-31                \n[103] evaluate_1.0.1              codetools_0.2-20           \n[105] tibble_3.2.1                BiocManager_1.30.25        \n[107] cli_3.6.3                   munsell_0.5.1              \n[109] Rcpp_1.0.13-1               spatstat.random_3.3-2      \n[111] png_0.1-8                   bdsmatrix_1.3-7            \n[113] spatstat.univar_3.1-1       parallel_4.4.1             \n[115] ggh4x_0.2.8                 blob_1.2.4                 \n[117] lme4_1.1-35.5               ggthemes_5.1.0             \n[119] lmerTest_3.1-3              scales_1.3.0               \n[121] purrr_1.0.2                 crayon_1.5.3               \n[123] rlang_1.1.4                 KEGGREST_1.46.0",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Spatial domains</span>"
    ]
  },
  {
    "objectID": "06-changes_in_marker_expression.html",
    "href": "06-changes_in_marker_expression.html",
    "title": "6  Marker expression",
    "section": "",
    "text": "6.1 Statial: Marker means\nOne of the easiest things to quantify in terms of markers is a marker mean. For a given image, we assess the total marker mean across all cells within an image, and compare across disease states. We can do this on an image level, a cell type level, a region level, and a cell type within regions level. For example, if your question is: “How does the expression of CD163 in infiltrating macrophages within the tumour spatial domain differ across my 2 treatment groups?”, you’ll want to look at the marker mean of macrophages within specifically the tumour domain.\nStatial provides functionality to identify the average marker expression of a given cell type in a given region, using the getMarkerMeans function. Similar to the analysis above, these features can also be used for survival analysis.\ncellTypeRegionMeans &lt;- getMarkerMeans(kerenSPE,\n  imageID = \"imageID\",\n  cellType = \"cellType\",\n  region = \"region\"\n)\n\nsurvivalResults &lt;- colTest(cellTypeRegionMeans[names(kerenSurv), ], kerenSurv, type = \"survival\")\n\nhead(survivalResults)\n\n                                    coef se.coef    pval adjPval\nB7H3__CD4_T_cell__region_2         270.0   76.00 0.00038    0.43\nCD163__CD4_T_cell__region_2         67.0   19.00 0.00038    0.43\nFoxP3__CD4_T_cell__region_2         25.0    7.20 0.00052    0.43\nSi__Unidentified__region_4          -3.1    0.89 0.00053    0.43\nCD56__CD4_T_cell__region_2          28.0    8.10 0.00067    0.43\nKeratin6__Keratin_Tumour__region_1   1.6    0.47 0.00073    0.43\n                                                              cluster\nB7H3__CD4_T_cell__region_2                 B7H3__CD4_T_cell__region_2\nCD163__CD4_T_cell__region_2               CD163__CD4_T_cell__region_2\nFoxP3__CD4_T_cell__region_2               FoxP3__CD4_T_cell__region_2\nSi__Unidentified__region_4                 Si__Unidentified__region_4\nCD56__CD4_T_cell__region_2                 CD56__CD4_T_cell__region_2\nKeratin6__Keratin_Tumour__region_1 Keratin6__Keratin_Tumour__region_1",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Marker expression</span>"
    ]
  },
  {
    "objectID": "06-changes_in_marker_expression.html#spatiomark-identifying-continuous-changes-in-cell-state",
    "href": "06-changes_in_marker_expression.html#spatiomark-identifying-continuous-changes-in-cell-state",
    "title": "6  Marker expression",
    "section": "6.2 SpatioMark: Identifying continuous changes in cell state",
    "text": "6.2 SpatioMark: Identifying continuous changes in cell state\nChanges in cell states can be analytically framed as the change in abundance of a gene or protein within a particular cell type. We can use marker expression to identify and quantify evidence of cell interactions that catalyse cell state changes. This approach measures how protein markers in a cell change with spatial proximity and abundance to other cell types. The methods utilised here will thereby provide a framework to explore how the dynamic behaviour of cells are altered by the agents they are surrounded by.\n\n6.2.1 Continuous cell state changes within a single image\nThe first step in analysing these changes is to calculate the spatial proximity (getDistances) and abundance (getAbundances) of each cell to every cell type. These values will then be stored in the reducedDims slot of the SingleCellExperiment object under the names distances and abundances respectively.\n\nkerenSPE &lt;- getDistances(kerenSPE,\n  maxDist = 200,\n  nCores = 1\n)\n\nkerenSPE &lt;- getAbundances(kerenSPE,\n  r = 200,\n  nCores = 1\n)\n\nFirst, let’s examine the same effect observed earlier with Kontextual - the localisation between p53-positive keratin/tumour cells and macrophages in the context of total keratin/tumour cells for image 6 of the Keren et al. dataset.\nStatial provides two main functions to assess this relationship - calcStateChanges and plotStateChanges. We can use calcStateChanges to examine the relationship between 2 cell types for 1 marker in a specific image. In this case, we’re examining the relationship between keratin/tumour cells (from = Keratin_Tumour) and macrophages (to = \"Macrophages\") for the marker p53 (marker = \"p53\") in image = \"6\". We can appreciate that the fdr statistic for this relationship is significant, with a negative tvalue, indicating that the expression of p53 in keratin/tumour cells decreases as distance from macrophages increases.\n\nstateChanges &lt;- calcStateChanges(\n  cells = kerenSPE,\n  type = \"distances\",\n  image = \"6\",\n  from = \"Keratin_Tumour\",\n  to = \"Macrophages\",\n  marker = \"p53\",\n  nCores = 1\n)\n\nstateChanges\n\n  imageID primaryCellType otherCellType marker         coef      tval\n1       6  Keratin_Tumour   Macrophages    p53 -0.001402178 -7.010113\n          pval          fdr\n1 2.868257e-12 2.868257e-12\n\n\nStatial also provides a convenient function for visualising this interaction - plotStateChanges. Here, again we can specify image = 6 and our main cell types of interest, keratin/tumour cells and macrophages, and our marker p53, in the same format as calcStateChanges.\nThrough this analysis, we can observe that keratin/tumour cells closer to a group of macrophages tend to have higher expression of p53, as observed in the first graph. This relationship is quantified with the second graph, showing an overall decrease of p53 expression in keratin/tumour cells as distance to macrophages increase.\nThese results allow us to essentially arrive at the same result as Kontextual, which calculated a localisation between p53+ keratin/tumour cells and macrophages in the wider context of keratin/tumour cells.\n\np &lt;- plotStateChanges(\n  cells = kerenSPE,\n  type = \"distances\",\n  image = \"6\",\n  from = \"Keratin_Tumour\",\n  to = \"Macrophages\",\n  marker = \"p53\",\n  size = 1,\n  shape = 19,\n  interactive = FALSE,\n  plotModelFit = FALSE,\n  method = \"lm\"\n)\n\np\n\n$image\n\n\n\n\n\n\n\n\n\n\n$scatter\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\n6.2.2 Continuous cell state changes across all images\nBeyond looking at single cell-to-cell interactions for a single image, we can also look at all interactions across all images. The calcStateChanges function provided by Statial can be expanded for this exact purpose - by not specifying cell types, a marker, or an image, calcStateChanges will examine the most significant correlations between distance and marker expression across the entire dataset. Here, we’ve filtered out the most significant interactions to only include those found within image 6 of the Keren et al. dataset.\n\nstateChanges &lt;- calcStateChanges(\n  cells = kerenSPE,\n  type = \"distances\",\n  nCores = 1,\n  minCells = 100\n)\n\nstateChanges |&gt;\n  filter(imageID == 6) |&gt;\n  head(n = 10)\n\n   imageID primaryCellType otherCellType       marker         coef      tval\n1        6  Keratin_Tumour  Unidentified           Na  0.004218419  25.03039\n2        6  Keratin_Tumour   Macrophages  HLA_Class_1 -0.003823497 -24.69629\n3        6  Keratin_Tumour    CD4_T_cell  HLA_Class_1 -0.003582774 -23.87797\n4        6  Keratin_Tumour  Unidentified Beta.catenin  0.005893120  23.41953\n5        6  Keratin_Tumour    CD8_T_cell  HLA_Class_1 -0.003154544 -23.13804\n6        6  Keratin_Tumour    DC_or_Mono  HLA_Class_1 -0.003353834 -22.98944\n7        6  Keratin_Tumour      dn_T_CD3  HLA_Class_1 -0.003123446 -22.63197\n8        6  Keratin_Tumour        Tumour  HLA_Class_1  0.003684079  21.94265\n9        6  Keratin_Tumour    CD4_T_cell           Fe -0.003457338 -21.43550\n10       6  Keratin_Tumour    CD4_T_cell   phospho.S6 -0.002892457 -20.50767\n            pval           fdr\n1  6.971648e-127 3.382534e-123\n2  7.814253e-124 3.430271e-120\n3  1.745242e-116 5.362839e-113\n4  1.917245e-112 5.523165e-109\n5  5.444541e-110 1.434014e-106\n6  1.053130e-108 2.696743e-105\n7  1.237988e-105 2.889213e-102\n8  8.188258e-100  1.640945e-96\n9   1.287478e-95  2.260688e-92\n10  3.928912e-88  5.748996e-85\n\n\nIn image 6, the majority of the top 10 most significant interactions occur between keratin/tumour cells and an immune population, and many of these interactions appear to involve the HLA class I ligand.\nWe can examine some of these interactions further with the plotStateChanges function. Taking a closer examination of the relationship between macrophages and keratin/tumour HLA class I expression, the plot below shows us a clear visual correlation - as macrophage density increases, keratin/tumour cells increase their expression HLA class I.\nBiologically, HLA Class I is a ligand which exists on all nucleated cells, tasked with presenting internal cell antigens for recognition by the immune system, marking aberrant cells for destruction by either CD8+ T cells or NK cells.\n\np &lt;- plotStateChanges(\n  cells = kerenSPE,\n  type = \"distances\",\n  image = \"6\",\n  from = \"Keratin_Tumour\",\n  to = \"Macrophages\",\n  marker = \"HLA_Class_1\",\n  size = 1,\n  shape = 19,\n  interactive = FALSE,\n  plotModelFit = FALSE,\n  method = \"lm\"\n)\n\np\n\n$image\n\n\n\n\n\n\n\n\n\n\n$scatter\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 1359 rows containing non-finite outside the scale range\n(`stat_smooth()`).\n\n\nWarning: Removed 1359 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nNext, let’s take a look at the top 10 most significant results across all images.\n\nstateChanges |&gt; head(n = 10)\n\n       imageID primaryCellType otherCellType     marker         coef\n69468       37     Endothelial        Tumour       Lag3 -0.001621517\n153135      11     Neutrophils            NK       CD56 -0.059936866\n16402       35      CD4_T_cell        B_cell       CD20 -0.029185750\n16498       35      CD4_T_cell    DC_or_Mono       CD20  0.019125946\n4891        35          B_cell    DC_or_Mono phospho.S6  0.005282065\n16507       35      CD4_T_cell    DC_or_Mono phospho.S6  0.004033218\n4885        35          B_cell    DC_or_Mono     HLA.DR  0.011120703\n5043        35          B_cell  Other_Immune          P  0.011182182\n16354       35      CD4_T_cell      dn_T_CD3       CD20  0.016349492\n4888        35          B_cell    DC_or_Mono     H3K9ac  0.005096632\n                tval          pval           fdr\n69468  -4.916884e+14  0.000000e+00  0.000000e+00\n153135 -2.172437e+15  0.000000e+00  0.000000e+00\n16402  -4.057355e+01 7.019343e-282 4.313854e-277\n16498   4.053436e+01 1.891267e-281 8.717324e-277\n4891    4.041385e+01 5.306590e-278 1.956752e-273\n16507   3.472882e+01 4.519947e-219 1.388904e-214\n4885    3.415344e+01 8.401034e-212 2.212712e-207\n5043    3.414375e+01 1.056403e-211 2.434613e-207\n16354   3.391901e+01 1.219488e-210 2.498188e-206\n4888    3.399856e+01 3.266533e-210 6.022506e-206\n\n\nImmediately, we can appreciate that a couple of these interactions are not biologically plausible. One of the most significant interactions occurs between B cells and CD4 T cells in image 35, where CD4 T cells are found to increase in CD20 expression when in close proximity to B cells. Biologically, CD20 is a highly specific ligand for B cells, and under healthy circumstances are usually not expressed in T cells.\nCould this potentially be an artefact of calcStateChanges? We can examine the image through the plotStateChanges function, where we indeed observe a strong increase in CD20 expression in T cells nearby B cell populations.\n\np &lt;- plotStateChanges(\n  cells = kerenSPE,\n  type = \"distances\",\n  image = \"35\",\n  from = \"CD4_T_cell\",\n  to = \"B_cell\",\n  marker = \"CD20\",\n  size = 1,\n  shape = 19,\n  interactive = FALSE,\n  plotModelFit = FALSE,\n  method = \"lm\"\n)\n\np\n\n$image\n\n\n\n\n\n\n\n\n\n\n$scatter\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 26 rows containing missing values or values outside the scale range\n(`geom_smooth()`).\n\n\n\n\n\n\n\n\n\nSo why are T cells expressing CD20? This brings us to a key problem of cell segmentation - contamination.\n\n\n6.2.3 Contamination (Lateral marker spill over)\nContamination, or lateral marker spill over is an issue that results in a cell’s marker expressions being wrongly attributed to another adjacent cell. This issue arises from incorrect segmentation where components of one cell are wrongly determined as belonging to another cell. Alternatively, this issue can arise when antibodies used to tag and measure marker expressions don’t latch on properly to a cell of interest, thereby resulting in residual markers being wrongly assigned as belonging to a cell near the intended target cell. It is important that we either correct or account for this incorrect attribution of markers in our modelling process. This is critical in understanding whether significant cell-cell interactions detected are an artefact of technical measurement errors driven by spill over or are real biological changes that represent a shift in a cell’s state.\nTo circumvent this problem, Statial provides a function that predicts the probability that a cell is any particular cell type - calcContamination. calcContamination returns a dataframe of probabilities demarcating the chance of a cell being any particular cell type. This dataframe is stored under contaminations in the reducedDim slot of the SingleCellExperiment object. It also provides the rfMainCellProb column, which provides the probability that a cell is indeed the cell type it has been designated. E.g. For a cell designated as CD8, rfMainCellProb could give a 80% chance that the cell is indeed CD8, due to contamination.\nWe can then introduce these probabilities as covariates into our linear model by setting contamination = TRUE as a parameter in our calcStateChanges function. However, this is not a perfect solution for the issue of contamination. As we can see, despite factoring in contamination into our linear model, the correlation between B cell density and CD20 expression in CD4 T cells remains one of the most significant interactions in our model.\n\nkerenSPE &lt;- calcContamination(kerenSPE)\n\nGrowing trees.. Progress: 30%. Estimated remaining time: 1 minute, 14 seconds.\nGrowing trees.. Progress: 61%. Estimated remaining time: 40 seconds.\nGrowing trees.. Progress: 92%. Estimated remaining time: 8 seconds.\n\nstateChangesCorrected &lt;- calcStateChanges(\n  cells = kerenSPE,\n  type = \"distances\",\n  nCores = 1,\n  minCells = 100,\n  contamination = TRUE\n)\n\nstateChangesCorrected |&gt; head(n = 20)\n\n       imageID primaryCellType otherCellType      marker          coef\n69468       37     Endothelial        Tumour        Lag3 -0.0016215172\n153135      11     Neutrophils            NK        CD56 -0.0599368661\n16402       35      CD4_T_cell        B_cell        CD20 -0.0249544057\n16498       35      CD4_T_cell    DC_or_Mono        CD20  0.0161515811\n16354       35      CD4_T_cell      dn_T_CD3        CD20  0.0138627995\n4891        35          B_cell    DC_or_Mono  phospho.S6  0.0043116217\n16507       35      CD4_T_cell    DC_or_Mono  phospho.S6  0.0036184512\n16357       35      CD4_T_cell      dn_T_CD3      HLA.DR  0.0104062272\n89188        3  Keratin_Tumour            DC          Ca -0.0138856202\n3697        28          B_cell            NK          Na -0.0045200220\n82222       20  Keratin_Tumour        Tumour HLA_Class_1  0.0029391854\n4741        35          B_cell      dn_T_CD3      HLA.DR  0.0088601913\n4885        35          B_cell    DC_or_Mono      HLA.DR  0.0088250768\n82985       21  Keratin_Tumour            DC Pan.Keratin -0.0059476295\n16491       35      CD4_T_cell    DC_or_Mono      CSF.1R  0.0085353317\n83998       23  Keratin_Tumour  Unidentified HLA_Class_1  0.0030202408\n16363       35      CD4_T_cell      dn_T_CD3  phospho.S6  0.0029594713\n99073        6  Keratin_Tumour  Unidentified          Na  0.0042156170\n85957       26  Keratin_Tumour    CD8_T_cell      HLA.DR -0.0004644983\n82177       20  Keratin_Tumour        Tumour          Na  0.0025359057\n                tval          pval           fdr\n69468  -5.424909e+14  0.000000e+00  0.000000e+00\n153135 -1.627379e+15  0.000000e+00  0.000000e+00\n16402  -3.501198e+01 8.006624e-222 4.920605e-217\n16498   3.445307e+01 5.478139e-216 2.525011e-211\n16354   3.022437e+01 3.788809e-173 1.397086e-168\n4891    3.007855e+01 7.247047e-171 2.226897e-166\n16507   2.996623e+01 1.285192e-170 3.385013e-166\n16357   2.926008e+01 9.437302e-164 2.174944e-159\n89188  -2.933926e+01 2.669818e-160 5.469271e-156\n3697   -2.918337e+01 5.998233e-159 1.105894e-154\n82222   2.569988e+01 3.191928e-133 5.349962e-129\n4741    2.550775e+01 2.646829e-128 4.066632e-124\n4885    2.535842e+01 5.573271e-127 7.904185e-123\n82985  -2.465347e+01 2.534357e-126 3.337568e-122\n16491   2.507647e+01 5.924492e-125 7.281990e-121\n83998   2.476286e+01 8.269720e-125 9.529302e-121\n16363   2.497101e+01 5.067702e-124 5.496071e-120\n99073   2.468791e+01 1.036322e-123 1.061482e-119\n85957  -2.441339e+01 3.801165e-123 3.688531e-119\n82177   2.436358e+01 6.047850e-121 5.575211e-117\n\n\nHowever, this does not mean factoring in contamination into our linear model was ineffective.\nWhilst our correction attempts do not rectify every relationship which arises due to contamination, we show that a significant portion of these relationships are rectified. We can show this by plotting a ROC curve of true positives against false positives. In general, cell type specific markers such as CD4, CD8, and CD20 should not change in cells they are not specific to. Therefore, relationships detected to be significant involving these cell type markers are likely false positives and will be treated as such for the purposes of evaluation. Meanwhile, cell state markers are predominantly likely to be true positives.\nPlotting the relationship between false positives and true positives, we’d expect the contamination correction to be greatest in the relationships with the top 100 lowest p values, where we indeed see more true positives than false positives with contamination correction.\n\ncellTypeMarkers &lt;- c(\"CD3\", \"CD4\", \"CD8\", \"CD56\", \"CD11c\", \"CD68\", \"CD45\", \"CD20\")\n\nvalues &lt;- c(\"blue\", \"red\")\nnames(values) &lt;- c(\"None\", \"Corrected\")\n\ndf &lt;- rbind(\n  data.frame(TP = cumsum(stateChanges$marker %in% cellTypeMarkers), FP = cumsum(!stateChanges$marker %in% cellTypeMarkers), type = \"None\"),\n  data.frame(TP = cumsum(stateChangesCorrected$marker %in% cellTypeMarkers), FP = cumsum(!stateChangesCorrected$marker %in% cellTypeMarkers), type = \"Corrected\")\n)\n\nggplot(df, aes(x = TP, y = FP, colour = type)) +\n  geom_line() +\n  labs(y = \"Cell state marker\", x = \"Cell type marker\") +\n  scale_colour_manual(values = values)\n\n\n\n\n\n\n\n\nHere, we zoom in on the ROC curve where the top 100 lowest p values occur, where we indeed see more true positives than false positives with contamination correction.\n\nggplot(df, aes(x = TP, y = FP, colour = type)) +\n  geom_line() +\n  xlim(0, 100) +\n  ylim(0, 1000) +\n  labs(y = \"Cell state marker\", x = \"Cell type marker\") +\n  scale_colour_manual(values = values)\n\nWarning: Removed 371472 rows containing missing values or values outside the scale range\n(`geom_line()`).\n\n\n\n\n\n\n\n\n\n\n\n6.2.4 Associate continuous state changes with survival outcomes\nSimiliar to Kontextual, we can run a similar survival analysis using our state changes results. Here, prepMatrix extracts the coefficients, or the coef column of stateChanges by default. To use the t values instead, specify column = \"tval\" in the prepMatrix function.\n\n# Preparing features for Statial\nstateMat &lt;- prepMatrix(stateChanges)\n\n# Ensuring rownames of stateMat match up with rownames of the survival vector\nstateMat &lt;- stateMat[names(kerenSurv), ]\n\n# Remove some very small values\nstateMat &lt;- stateMat[, colMeans(abs(stateMat) &gt; 0.0001) &gt; .8]\n\nsurvivalResults &lt;- colTest(stateMat, kerenSurv, type = \"survival\")\n\nhead(survivalResults)\n\n                                         coef se.coef   pval adjPval\nKeratin_Tumour__Mono_or_Neu__Pan.Keratin -280      89 0.0018    0.63\nMacrophages__Keratin_Tumour__HLA_Class_1  220      75 0.0034    0.63\nKeratin_Tumour__CD8_T_cell__Keratin6     -220      77 0.0036    0.63\nMacrophages__Other_Immune__HLA_Class_1   -480     170 0.0057    0.75\nKeratin_Tumour__Mesenchymal__dsDNA       -810     310 0.0094    0.80\nKeratin_Tumour__Unidentified__H3K27me3    490     190 0.0100    0.80\n                                                                          cluster\nKeratin_Tumour__Mono_or_Neu__Pan.Keratin Keratin_Tumour__Mono_or_Neu__Pan.Keratin\nMacrophages__Keratin_Tumour__HLA_Class_1 Macrophages__Keratin_Tumour__HLA_Class_1\nKeratin_Tumour__CD8_T_cell__Keratin6         Keratin_Tumour__CD8_T_cell__Keratin6\nMacrophages__Other_Immune__HLA_Class_1     Macrophages__Other_Immune__HLA_Class_1\nKeratin_Tumour__Mesenchymal__dsDNA             Keratin_Tumour__Mesenchymal__dsDNA\nKeratin_Tumour__Unidentified__H3K27me3     Keratin_Tumour__Unidentified__H3K27me3\n\n\nFor our state changes results, Keratin_Tumour__CD4_Cell__Keratin6 is the most significant pairwise relationship which contributes to patient survival. That is, the relationship between HLA class I expression in keratin/tumour cells and their spatial proximity to mesenchymal cells. As there is a negative coeffcient associated with this relationship, which tells us that higher HLA class I expression in keratin/tumour cells nearby mesenchymal cell populations lead to poorer survival outcomes for patients.\n\n# Selecting the most significant relationship\nsurvRelationship &lt;- stateMat[[\"Keratin_Tumour__Mono_or_Neu__Pan.Keratin\"]]\nsurvRelationship &lt;- ifelse(survRelationship &gt; median(survRelationship), \"Higher expression in close cells\", \"Lower expression in close cells\")\n\n# Plotting Kaplan-Meier curve\nsurvfit2(kerenSurv ~ survRelationship) |&gt;\n  ggsurvfit() +\n  add_pvalue() +\n  ggtitle(\"Keratin_Tumour__Mono_or_Neu__Pan.Keratin\")",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Marker expression</span>"
    ]
  },
  {
    "objectID": "06-changes_in_marker_expression.html#scfeatures-morans-i",
    "href": "06-changes_in_marker_expression.html#scfeatures-morans-i",
    "title": "6  Marker expression",
    "section": "6.3 scFeatures: Moran’s I",
    "text": "6.3 scFeatures: Moran’s I",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Marker expression</span>"
    ]
  },
  {
    "objectID": "06-changes_in_marker_expression.html#sessioninfo",
    "href": "06-changes_in_marker_expression.html#sessioninfo",
    "title": "6  Marker expression",
    "section": "6.4 sessionInfo",
    "text": "6.4 sessionInfo\n\nsessionInfo()\n\nR version 4.4.1 (2024-06-14)\nPlatform: x86_64-pc-linux-gnu\nRunning under: Debian GNU/Linux 12 (bookworm)\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 \nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.21.so;  LAPACK version 3.11.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Australia/Sydney\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] SpatialDatasets_1.4.0       SpatialExperiment_1.16.0   \n [3] ExperimentHub_2.14.0        AnnotationHub_3.14.0       \n [5] BiocFileCache_2.14.0        dbplyr_2.5.0               \n [7] Statial_1.7.4               testthat_3.2.1.1           \n [9] treekoR_1.14.0              tibble_3.2.1               \n[11] ggsurvfit_1.1.0             ggplot2_3.5.1              \n[13] SingleCellExperiment_1.28.1 dplyr_1.1.4                \n[15] lisaClust_1.14.4            ClassifyR_3.10.0           \n[17] survival_3.7-0              BiocParallel_1.40.0        \n[19] MultiAssayExperiment_1.32.0 SummarizedExperiment_1.36.0\n[21] Biobase_2.66.0              GenomicRanges_1.58.0       \n[23] GenomeInfoDb_1.42.0         IRanges_2.40.0             \n[25] MatrixGenerics_1.18.0       matrixStats_1.4.1          \n[27] S4Vectors_0.44.0            BiocGenerics_0.52.0        \n[29] generics_0.1.3              spicyR_1.18.0              \n\nloaded via a namespace (and not attached):\n  [1] fs_1.6.5                    spatstat.sparse_3.1-0      \n  [3] devtools_2.4.5              httr_1.4.7                 \n  [5] hopach_2.66.0               RColorBrewer_1.1-3         \n  [7] doParallel_1.0.17           numDeriv_2016.8-1.1        \n  [9] profvis_0.4.0               tools_4.4.1                \n [11] backports_1.5.0             utf8_1.2.4                 \n [13] R6_2.5.1                    lazyeval_0.2.2             \n [15] mgcv_1.9-1                  GetoptLong_1.0.5           \n [17] urlchecker_1.0.1            withr_3.0.2                \n [19] coxme_2.2-22                cli_3.6.3                  \n [21] spatstat.explore_3.3-3      sandwich_3.1-1             \n [23] labeling_0.4.3              mvtnorm_1.3-2              \n [25] spatstat.data_3.1-2         systemfonts_1.1.0          \n [27] yulab.utils_0.1.8           ggupset_0.4.0              \n [29] colorRamps_2.3.4            sessioninfo_1.2.2          \n [31] limma_3.62.1                RSQLite_2.3.7              \n [33] flowCore_2.18.0             rstudioapi_0.17.1          \n [35] gridGraphics_0.5-1          shape_1.4.6.1              \n [37] spatstat.random_3.3-2       car_3.1-3                  \n [39] scam_1.2-17                 Matrix_1.7-1               \n [41] RProtoBufLib_2.18.0         fansi_1.0.6                \n [43] abind_1.4-8                 lifecycle_1.0.4            \n [45] yaml_2.3.10                 multcomp_1.4-26            \n [47] edgeR_4.4.0                 carData_3.0-5              \n [49] SparseArray_1.6.0           Rtsne_0.17                 \n [51] blob_1.2.4                  grid_4.4.1                 \n [53] promises_1.3.0              crayon_1.5.3               \n [55] bdsmatrix_1.3-7             miniUI_0.1.1.1             \n [57] lattice_0.22-6              KEGGREST_1.46.0            \n [59] magick_2.8.5                pillar_1.9.0               \n [61] knitr_1.49                  ComplexHeatmap_2.22.0      \n [63] rjson_0.2.23                boot_1.3-31                \n [65] codetools_0.2-20            glue_1.8.0                 \n [67] ggiraph_0.8.10              ggfun_0.1.7                \n [69] spatstat.univar_3.1-1       data.table_1.16.2          \n [71] remotes_2.5.0               vctrs_0.6.5                \n [73] png_0.1-8                   treeio_1.30.0              \n [75] gtable_0.3.6                cachem_1.1.0               \n [77] xfun_0.49                   S4Arrays_1.6.0             \n [79] mime_0.12                   ConsensusClusterPlus_1.70.0\n [81] pheatmap_1.0.12             iterators_1.0.14           \n [83] cytolib_2.18.0              statmod_1.5.0              \n [85] ellipsis_0.3.2              TH.data_1.1-2              \n [87] nlme_3.1-166                usethis_3.0.0              \n [89] ggtree_3.14.0               bit64_4.5.2                \n [91] filelock_1.0.3              rprojroot_2.0.4            \n [93] DBI_1.2.3                   colorspace_2.1-1           \n [95] tidyselect_1.2.1            curl_6.0.1                 \n [97] bit_4.5.0                   compiler_4.4.1             \n [99] diffcyt_1.26.0              desc_1.4.3                 \n[101] DelayedArray_0.32.0         plotly_4.10.4              \n[103] scales_1.3.0                rappdirs_0.3.3             \n[105] stringr_1.5.1               digest_0.6.37              \n[107] goftest_1.2-3               fftwtools_0.9-11           \n[109] spatstat.utils_3.1-1        minqa_1.2.8                \n[111] rmarkdown_2.29              XVector_0.46.0             \n[113] htmltools_0.5.8.1           pkgconfig_2.0.3            \n[115] lme4_1.1-35.5               fastmap_1.2.0              \n[117] rlang_1.1.4                 GlobalOptions_0.1.2        \n[119] htmlwidgets_1.6.4           ggthemes_5.1.0             \n[121] UCSC.utils_1.2.0            shiny_1.9.1                \n[123] ggh4x_0.2.8                 farver_2.1.2               \n[125] zoo_1.8-12                  jsonlite_1.8.9             \n[127] magrittr_2.0.3              Formula_1.2-5              \n[129] GenomeInfoDbData_1.2.13     ggplotify_0.1.2            \n[131] patchwork_1.3.0             munsell_0.5.1              \n[133] Rcpp_1.0.13-1               ape_5.8                    \n[135] ggnewscale_0.5.0            stringi_1.8.4              \n[137] brio_1.1.5                  zlibbioc_1.52.0            \n[139] MASS_7.3-61                 plyr_1.8.9                 \n[141] pkgbuild_1.4.5              parallel_4.4.1             \n[143] deldir_2.0-4                Biostrings_2.74.0          \n[145] splines_4.4.1               tensor_1.5                 \n[147] circlize_0.4.16             locfit_1.5-9.10            \n[149] igraph_2.1.1                ggpubr_0.6.0               \n[151] uuid_1.2-1                  ranger_0.17.0              \n[153] spatstat.geom_3.3-3         ggsignif_0.6.4             \n[155] reshape2_1.4.4              pkgload_1.4.0              \n[157] BiocVersion_3.20.0          XML_3.99-0.17              \n[159] evaluate_1.0.1              BiocManager_1.30.25        \n[161] nloptr_2.1.1                foreach_1.5.2              \n[163] tweenr_2.0.3                httpuv_1.6.15              \n[165] tidyr_1.3.1                 purrr_1.0.2                \n[167] polyclip_1.10-7             clue_0.3-66                \n[169] ggforce_0.4.2               broom_1.0.7                \n[171] xtable_1.8-4                tidytree_0.4.6             \n[173] rstatix_0.7.2               later_1.3.2                \n[175] viridisLite_0.4.2           class_7.3-22               \n[177] lmerTest_3.1-3              aplot_0.2.3                \n[179] AnnotationDbi_1.68.0        memoise_2.0.1              \n[181] FlowSOM_2.14.0              cluster_2.1.6              \n[183] concaveman_1.1.0",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Marker expression</span>"
    ]
  },
  {
    "objectID": "07-classification.html",
    "href": "07-classification.html",
    "title": "7  Classification",
    "section": "",
    "text": "7.1 Why classify?\nSteps:\nWhen it comes to biological datasets, the end goal is either mechanistic or translational. For example, if we had a mechanistic end goal, we might want to find what genes are differentially expressed between two conditions, and further aim to characterise the pathways which lead to this differential expression. Alternatively, if the end goal is translational, we might want to use a biological dataset that can be relatively cheaply obtained (e.g. IMC) to predict whether a patient’s disease will progress or not progress (e.g. metastasize in cancer).\nRegardless of the end goal, classification is an important end-point for any biological dataset, as it provides us information on:\nClassifyR simplifies the process of classification, and provides quick and simple ways to analyse datasets and determine how well biological datasets can be classified into disease states using particular feature generation techniques. In this chapter, we will provide a guide on how to use ClassifyR on biological datasets, and typical workflows for classification.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Classification</span>"
    ]
  },
  {
    "objectID": "07-classification.html#why-classify",
    "href": "07-classification.html#why-classify",
    "title": "7  Classification",
    "section": "",
    "text": "Important features\nPredictability of the full dataset, or a subset of the dataset",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Classification</span>"
    ]
  },
  {
    "objectID": "07-classification.html#cross-validation",
    "href": "07-classification.html#cross-validation",
    "title": "7  Classification",
    "section": "7.2 Cross validation",
    "text": "7.2 Cross validation\nCross validation is an essential part of any classification process, and is necessary to robustly determine how well your model has performed. ClassifyR makes this extremely easy to implement with the crossValidate function.\n\nlibrary(ClassifyR)\nlibrary(lisaClust)\n\nBPPARAM &lt;- simpleSeg:::generateBPParam(cores = 40)\n\nUsing all the features we’ve generated in the previous chapters, we can build a list of features matrices.\n\nkerenSPE &lt;- SpatialDatasets::spe_Keren_2018()\n\nsee ?SpatialDatasets and browseVignettes('SpatialDatasets') for documentation\n\n\nloading from cache",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Classification</span>"
    ]
  },
  {
    "objectID": "08-case_study1.html",
    "href": "08-case_study1.html",
    "title": "8  Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)",
    "section": "",
    "text": "8.1 Load libraries\nlibrary(cytomapper)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(simpleSeg)\nlibrary(FuseSOM)\nlibrary(ggpubr)\nlibrary(scater)\nlibrary(spicyR)\nlibrary(ClassifyR)\nlibrary(lisaClust)\nlibrary(Statial)\nlibrary(tidySingleCellExperiment)\nlibrary(SpatialExperiment)\nlibrary(SpatialDatasets)",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)</span>"
    ]
  },
  {
    "objectID": "08-case_study1.html#global-parameters",
    "href": "08-case_study1.html#global-parameters",
    "title": "8  Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)",
    "section": "8.2 Global parameters",
    "text": "8.2 Global parameters\nIt is convenient to set the number of cores for running code in parallel. Please choose a number that is appropriate for your resources. Set the use_mc flag to TRUE if you would like to use parallel processing for the rest of the vignette. A minimum of 2 cores is suggested since running this workflow is rather computationally intensive.\n\nuse_mc &lt;- TRUE\n\nif (use_mc) {\n  nCores &lt;- max(parallel::detectCores()/2, 1)\n} else {\n  nCores &lt;- 2\n}\nBPPARAM &lt;- simpleSeg:::generateBPParam(nCores)\n\ntheme_set(theme_classic())",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)</span>"
    ]
  },
  {
    "objectID": "08-case_study1.html#context",
    "href": "08-case_study1.html#context",
    "title": "8  Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)",
    "section": "8.3 Context",
    "text": "8.3 Context\nIn the following we will re-analyse some IMC data (Ferguson et al, 2022) profiling the spatial landscape of head and neck cutaneous squamous cell carcinomas (HNcSCC), the second most common type of skin cancer. The majority of HNcSCC can be treated with surgery and good local control, but a subset of large tumours infiltrate subcutaneous tissue and are considered high risk for local recurrence and metastases. The key conclusion of this manuscript (amongst others) is that spatial information about cells and the immune environment can be used to predict primary tumour progression or metastases in patients. We will use our spicy workflow to reach a similar conclusion.\nThe R code for this analysis is available on github https://github.com/SydneyBioX/spicyWorkflow.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)</span>"
    ]
  },
  {
    "objectID": "08-case_study1.html#read-in-images",
    "href": "08-case_study1.html#read-in-images",
    "title": "8  Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)",
    "section": "8.4 Read in images",
    "text": "8.4 Read in images\nOnce the spicyWorkflow package is installed, these images will be located within the spicyWorkflow folder where the spicyWorkflow package is installed, under inst/extdata/images. Here we use loadImages() from the cytomapper package to load all the tiff images into a CytoImageList object and store the images as h5 file on-disk in a temporary directory using the h5FilesPath = HDF5Array::getHDF5DumpDir() parameter.\nWe will also assign the metadata columns of the CytoImageList object using the mcols() function.\n\npathToImages &lt;- SpatialDatasets::Ferguson_Images()\n\nsee ?SpatialDatasets and browseVignettes('SpatialDatasets') for documentation\n\n\nloading from cache\n\ntmp &lt;- tempfile()\nunzip(pathToImages, exdir = tmp)\n\n# Store images in a CytoImageList on_disk as h5 files to save memory.\nimages &lt;- cytomapper::loadImages(\n  tmp,\n  single_channel = TRUE,\n  on_disk = TRUE,\n  h5FilesPath = HDF5Array::getHDF5DumpDir(),\n  BPPARAM = BPPARAM\n)\n\nmcols(images) &lt;- S4Vectors::DataFrame(imageID = names(images))\n\n\n8.4.1 Clean channel names\nAs we’re reading the image channels directly from the names of the TIFF image, often these channel names will need to be cleaned for ease of downstream processing.\nThe channel names can be accessed from the CytoImageList object using the channelNames() function.\n\ncn &lt;- channelNames(images) # Read in channel names\nhead(cn)\n\n[1] \"139La_139La_panCK.ome\"      \"141Pr_141Pr_CD20.ome\"      \n[3] \"142Nd_142Nd_HH3.ome\"        \"143Nd_143Nd_CD45RA.ome\"    \n[5] \"146Nd_146Nd_CD8a.ome\"       \"147Sm_147Sm_podoplanin.ome\"\n\ncn &lt;- sub(\".*_\", \"\", cn) # Remove preceding letters\ncn &lt;- sub(\".ome\", \"\", cn) # Remove the .ome\nhead(cn)\n\n[1] \"panCK\"      \"CD20\"       \"HH3\"        \"CD45RA\"     \"CD8a\"      \n[6] \"podoplanin\"\n\nchannelNames(images) &lt;- cn # Reassign channel names\n\n\n\n8.4.2 Clean image names\nSimilarly, the image names will be taken from the folder name containing the individual TIFF images for each channel. These will often also need to be cleaned.\n\nhead(names(images))\n\n[1] \"ROI001_ROI 01_F3_SP16-001550_1E\" \"ROI002_ROI 02_F4_SP16-001550_1E\"\n[3] \"ROI003_ROI 03_F5_SP16-001550_1E\" \"ROI005_ROI 05_G4_SP17-002069_1F\"\n[5] \"ROI006_ROI 06_G5_SP17-002069_1F\" \"ROI007_ROI 07_G6_SP17-005715_1B\"\n\nnam &lt;- sapply(strsplit(names(images), \"_\"), `[`, 3)\nhead(nam)\n\n[1] \"F3\" \"F4\" \"F5\" \"G4\" \"G5\" \"G6\"\n\nnames(images) &lt;- nam # Reassigning image names\nmcols(images)[[\"imageID\"]] &lt;- nam # Reassigning image names",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)</span>"
    ]
  },
  {
    "objectID": "08-case_study1.html#simpleseg-segment-the-cells-in-the-images",
    "href": "08-case_study1.html#simpleseg-segment-the-cells-in-the-images",
    "title": "8  Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)",
    "section": "8.5 SimpleSeg: Segment the cells in the images",
    "text": "8.5 SimpleSeg: Segment the cells in the images\nOur simpleSeg R package on https://github.com/SydneyBioX/simpleSeg provides a series of functions to generate simple segmentation masks of images. These functions leverage the functionality of the EBImage package on Bioconductor. For more flexibility when performing your segmentation in R we recommend learning to use the EBimage package. A key strength of the simpleSeg package is that we have coded multiple ways to perform some simple segmentation operations as well as incorporating multiple automatic procedures to optimise some key parameters when these aren’t specified.\n\n8.5.1 Run simpleSeg\nIf your images are stored in a list or CytoImageList they can be segmented with a simple call to simpleSeg(). To summarise, simpleSeg() is an R implementation of a simple segmentation technique which traces out the nuclei using a specified channel using nucleus then dilates around the traced nuclei by a specified amount using discSize. The nucleus can be traced out using either one specified channel, or by using the principal components of all channels most correlated to the specified nuclear channel by setting pca = TRUE.\nIn the particular example below, we have asked simpleSeg to do the following:\nBy setting nucleus = c(\"HH3\"), we’ve asked simpleSeg to trace out the nuclei signal in the images using the HH3 channel. By setting pca = TRUE, simpleSeg segments out the nuclei mask using a principal component analysis of all channels and using the principal components most aligned with the nuclei channel, in this case, HH3. By setting cellBody = \"dilate\", simpleSeg uses a dilation strategy of segmentation, expanding out from the nucleus by a specified discSize. By setting discSize = 3, simpleSeg dilates out from the nucleus by 3 pixels. By setting sizeSelection = 20, simpleSeg ensures that only cells with a size greater than 20 pixels will be used. By setting transform = \"sqrt\", simpleSeg square root transforms each of the channels prior to segmentation. By setting tissue = c(\"panCK\", \"CD45\", \"HH3\"), we specify a tissue mask which simpleSeg uses, filtering out all background noise outside the tissue mask. This is important as these are tumour cores, wand hence circular, so we’d want to ignore background noise which happens outside of the tumour core.\nThere are many other parameters that can be specified in simpleSeg (smooth, watershed, tolerance, and ext), and we encourage the user to select the best parameters which suit their biological context.\n\nmasks &lt;- simpleSeg(images,\n                   nucleus = c(\"HH3\"),\n                   pca = TRUE,\n                   cellBody = \"dilate\",\n                   discSize = 3,\n                   sizeSelection = 20,\n                   transform = \"sqrt\",\n                   tissue = c(\"panCK\", \"CD45\", \"HH3\"),\n                   cores = nCores\n                   )\n\n\n\n8.5.2 Visualise separation\nThe display and colorLabels functions in EBImage make it very easy to examine the performance of the cell segmentation. The great thing about display is that if used in an interactive session it is very easy to zoom in and out of the image.\n\nEBImage::display(colorLabels(masks[[1]]))\n\n\n\n\n\n\n\n\n\n\n8.5.3 Visualise outlines\nThe plotPixels function in cytomapper makes it easy to overlay the mask on top of the nucleus intensity marker to see how well our segmentation process has performed. Here we can see that the segmentation appears to be performing reasonably.\nIf you see over or under-segmentation of your images, discSize is a key parameter in simpleSeg() for optimising the size of the dilation disc after segmenting out the nuclei.\n\nplotPixels(image = images[\"F3\"], \n           mask = masks[\"F3\"],\n           img_id = \"imageID\", \n           colour_by = c(\"HH3\"), \n           display = \"single\",\n           colour = list(HH3 = c(\"black\",\"blue\")),\n           legend = NULL,\n           bcg = list(\n             HH3 = c(1, 1, 2)\n           ))\n\n\n\n\n\n\n\n\nIf you wish to visualise multiple markers instead of just the HH3 marker and see how the segmentation mask performs, this can also be done. Here, we can see that our segmentation mask has done a good job of capturing the CD31 signal, but perhaps not such a good job of capturing the FXIIIA signal, which often lies outside of our dilated nuclear mask. This could suggest that we might need to increase the discSize of our dilation.\n\nplotPixels(image = images[\"F3\"], \n           mask = masks[\"F3\"],\n           img_id = \"imageID\", \n           colour_by = c(\"HH3\", \"CD31\", \"FX111A\"), \n           display = \"single\",\n           colour = list(HH3 = c(\"black\",\"blue\"),\n                         CD31 = c(\"black\", \"red\"),\n                         FX111A = c(\"black\", \"green\") ),\n           legend = NULL,\n           bcg = list(\n             HH3 = c(1, 1, 2),\n             CD31 = c(0, 1, 2),\n             FX111A = c(0, 1, 1.5)\n           ))",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)</span>"
    ]
  },
  {
    "objectID": "08-case_study1.html#summarise-cell-features.",
    "href": "08-case_study1.html#summarise-cell-features.",
    "title": "8  Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)",
    "section": "8.6 Summarise cell features.",
    "text": "8.6 Summarise cell features.\nIn order to characterise the phenotypes of each of the segmented cells, measureObjects() from cytomapper will calculate the average intensity of each channel within each cell as well as a few morphological features. By default, the measureObjects() function will return a SingleCellExperiment object, where the channel intensities are stored in the counts assay and the spatial location of each cell is stored in colData in the m.cx and m.cy columns.\nHowever, you can also specify measureObjects() to return a SpatialExperiment object by specifying return_as = \"spe\". As a SpatialExperiment object, the spatial location of each cell is stored in the spatialCoords slot, as m.cx and m.cy, which simplifies plotting. In this demonstration, we will return a SpatialExperiment object.\n\n# Summarise the expression of each marker in each cell\ncells &lt;- cytomapper::measureObjects(masks,\n                                    images,\n                                    img_id = \"imageID\",\n                                    return_as = \"spe\",\n                                    BPPARAM = BPPARAM)\n\nspatialCoordsNames(cells) &lt;- c(\"x\", \"y\")",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)</span>"
    ]
  },
  {
    "objectID": "08-case_study1.html#load-the-clinical-data",
    "href": "08-case_study1.html#load-the-clinical-data",
    "title": "8  Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)",
    "section": "8.7 Load the clinical data",
    "text": "8.7 Load the clinical data\nTo associate features in our image with disease progression, it is important to read in information which links image identifiers to their progression status. We will do this here, making sure that our imageID match.\n\n8.7.1 Read the clinical data\n\nclinical &lt;- read.csv(\n  system.file(\n    \"extdata/clinicalData_TMA1_2021_AF.csv\",\n    package = \"spicyWorkflow\"\n  )\n)\n\nrownames(clinical) &lt;- clinical$imageID\nclinical &lt;- clinical[names(images), ]\n\n\n\n8.7.2 Put the clinical data into the colData of SingleCellExperiment\n\ncolData(cells) &lt;- cbind(colData(cells), clinical[cells$imageID, ])\n\n\nsave(cells, file = \"spe_Ferguson_2022.rda\")\n\nIn case you already have your SCE object, you may only be interested in our downstream workflow. For the sake of convenience, we’ve provided capability to directly load in the SpatialExperiment (SPE) object that we’ve generated.\n\nload(system.file(\"extdata/cells.rda\", package = \"spicyWorkflow\"))",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)</span>"
    ]
  },
  {
    "objectID": "08-case_study1.html#normalise-the-data",
    "href": "08-case_study1.html#normalise-the-data",
    "title": "8  Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)",
    "section": "8.8 Normalise the data",
    "text": "8.8 Normalise the data\nWe should check to see if the marker intensities of each cell require some form of transformation or normalisation. The reason we do this is two-fold:\n1) The intensities of images are often highly skewed, preventing any meaningful downstream analysis.\n2) The intensities across different images are often different, meaning that what is considered “positive” can be different across images.\nBy transforming and normalising the data, we aim to reduce these two effects. Here we extract the intensities from the counts assay. Looking at CD3 which should be expressed in the majority of the T cells, the intensities are clearly very skewed, and it is difficult to see what is considered a CD3- cell, and what is a CD3+ cell.\n\n# Plot densities of CD3 for each image.\ncells |&gt; \n  join_features(features = rownames(cells), shape = \"wide\", assay = \"counts\") |&gt; \n  ggplot(aes(x = CD3, colour = imageID)) + \n  geom_density() + \n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n8.8.1 Dimension reduction and visualisation\nAs our data is stored in a SpatialExperiment we can also use scater to perform and visualise our data in a lower dimension to look for batch effects in our images. We can see that before normalisation, our UMAP shows a clear batch effect between images.\n\n# Usually we specify a subset of the original markers which are informative to separating out distinct cell types for the UMAP and clustering.\nct_markers &lt;- c(\"podoplanin\", \"CD13\", \"CD31\",\n                \"panCK\", \"CD3\", \"CD4\", \"CD8a\",\n                \"CD20\", \"CD68\", \"CD16\", \"CD14\", \"HLADR\", \"CD66a\")\n\n# ct_markers &lt;- c(\"podoplanin\", \"CD13\", \"CD31\",\n#                 \"panCK\", \"CD3\", \"CD4\", \"CD8a\",\n#                 \"CD20\", \"CD68\", \"CD14\", \"CD16\",\n#                 \"CD66a\")\n\nset.seed(51773)\n# Perform dimension reduction using UMAP.\ncells &lt;- scater::runUMAP(\n  cells,\n  subset_row = ct_markers,\n  exprs_values = \"counts\"\n)\n\n# Select a subset of images to plot.\nsomeImages &lt;- unique(cells$imageID)[c(1, 5, 10, 20, 30, 40)]\n\n# UMAP by imageID.\nscater::plotReducedDim(\n  cells[, cells$imageID %in% someImages],\n  dimred = \"UMAP\",\n  colour_by = \"imageID\"\n)\n\n\n\n\n\n\n\n\nWe can transform and normalise our data using the normalizeCells function. In the normalizeCells() function, we specify the following parameters. transformation is an optional argument which specifies the function to be applied to the data. We do not apply an arcsinh transformation here, as we already apply a square root transform in the simpleSeg() function. method = c(\"trim99\", \"mean\", PC1\") is an optional argument which specifies the normalisation method/s to be performed. Here, we: 1) Trim the 99th percentile 2) Divide by the mean 3) Remove the 1st principal component assayIn = \"counts\" is a required argument which specifies what the assay you’ll be taking the intensity data from is named. In our context, this is called counts.\nThis modified data is then stored in the norm assay by default. We can see that this normalised data appears more bimodal, not perfectly, but likely to a sufficient degree for clustering, as we can at least observe a clear CD3+ peak at 1.00, and a CD3- peak at around 0.3.\n\n# Leave out the nuclei markers from our normalisation process. \nuseMarkers &lt;- rownames(cells)[!rownames(cells) %in% c(\"DNA1\", \"DNA2\", \"HH3\")]\n\n# Transform and normalise the marker expression of each cell type.\ncells &lt;- normalizeCells(cells,\n                        markers = useMarkers,\n                        transformation = NULL,\n                        method = c(\"trim99\", \"mean\", \"PC1\"),\n                        assayIn = \"counts\",\n                        cores = nCores\n)\n\n# Plot densities of CD3 for each image\ncells |&gt; \n  join_features(features = rownames(cells), shape = \"wide\", assay = \"norm\") |&gt; \n  ggplot(aes(x = CD3, colour = imageID)) + \n  geom_density() + \n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\nWe can also appreciate through the UMAP a reduction of the batch effect we initially saw.\n\nset.seed(51773)\n# Perform dimension reduction using UMAP.\ncells &lt;- scater::runUMAP(\n  cells,\n  subset_row = ct_markers,\n  exprs_values = \"norm\",\n  name = \"normUMAP\"\n)\n\nsomeImages &lt;- unique(cells$imageID)[c(1, 5, 10, 20, 30, 40)]\n\n# UMAP by imageID.\nscater::plotReducedDim(\n  cells[, cells$imageID %in% someImages],\n  dimred = \"normUMAP\",\n  colour_by = \"imageID\"\n)",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)</span>"
    ]
  },
  {
    "objectID": "08-case_study1.html#fusesom-cluster-cells-into-cell-types",
    "href": "08-case_study1.html#fusesom-cluster-cells-into-cell-types",
    "title": "8  Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)",
    "section": "8.9 FuseSOM: Cluster cells into cell types",
    "text": "8.9 FuseSOM: Cluster cells into cell types\nWe can appreciate from the UMAP that there is a division of clusters, most likely representing different cell types. We next aim to empirically distinguish each cluster using our FuseSOM package for clustering.\nOur FuseSOM R package can be found on bioconductor at https://www.bioconductor.org/packages/release/bioc/html/FuseSOM.html, and provides a pipeline for the clustering of highly multiplexed in situ imaging cytometry assays. This pipeline uses the Self Organising Map architecture coupled with Multiview hierarchical clustering and provides functions for the estimation of the number of clusters.\nHere we cluster using the runFuseSOM function. We specify the number of clusters to identify to be numClusters = 10. We also specify a set of cell-type specific markers to use, as we want our clusters to be distinct based off cell type markers, rather than markers which might pick up a transitioning cell state.\n\n8.9.1 Perform the clustering\n\n# Set seed.\nset.seed(51773)\n\n# Generate SOM and cluster cells into 10 groups\ncells &lt;- runFuseSOM(\n  cells,\n  markers = ct_markers,\n  assay = \"norm\",\n  numClusters = 10\n)\n\nYou have provided a dataset of class SpatialExperiment\n\n\nEverything looks good. Now running the FuseSOM algorithm\n\n\nNow Generating the Self Organizing Map Grid\n\n\nOptimal Grid Size is: 8\n\n\nNow Running the Self Organizing Map Model\n\n\nNow Clustering the Prototypes\n\n\nLoading required namespace: fastcluster\n\n\nNow Mapping Clusters to the Original Data\n\n\nThe Prototypes have been Clustered and Mapped Successfully\n\n\nThe FuseSOM algorithm has completed successfully\n\n\nWe can also observe how reasonable our choice of k = 10 was, using the estimateNumCluster() and optiPlot() functions. Here we examine the Gap method, but others such as Silhouette and Within Cluster Distance are also available. We can see that there are elbow points in the gap statistic at k = 7, k = 10, and k = 11. We’ve specified k = 10, striking a good balance between the number of clusters and the gap statistic.\n\ncells &lt;- estimateNumCluster(cells, kSeq = 2:30)\n\nYou have provided a dataset of class: SpatialExperiment\n\n\nNow Computing the Number of Clusters using Discriminant Analysis\n\n\nNow Computing The Number Of Clusters Using Distance Analysis\n\noptiPlot(cells, method = \"gap\")\n\nYou have provided a dataset of class: SpatialExperiment\n\n\n\n\n\n\n\n\n\n\n\n8.9.2 Attempt to interpret the phenotype of each cluster\nWe can begin the process of understanding what each of these cell clusters are by using the plotGroupedHeatmap function from scater. At the least, here we can see we capture all the major immune populations that we expect to see, including the CD4 and CD8 T cells, the CD20+ B cells, the CD68+ myeloid populations, the CD66+ granulocytes, the podoplanin+ epithelial cells, and the panCK+ tumour cells.\n\n# Visualise marker expression in each cluster.\nscater::plotGroupedHeatmap(\n  cells,\n  features = ct_markers,\n  group = \"clusters\",\n  exprs_values = \"norm\",\n  center = TRUE,\n  scale = TRUE,\n  zlim = c(-3, 3),\n  cluster_rows = FALSE,\n  block = \"clusters\"\n)\n\n\n\n\n\n\n\n\nGiven domain-specific knowledge of the tumour-immune landscape, we can go ahead and annotate these clusters as cell types given their expression profiles.\n\ncells &lt;- cells |&gt;\n  mutate(cellType = case_when(\n    clusters == \"cluster_1\" ~ \"GC\", # Granulocytes\n    clusters == \"cluster_2\" ~ \"MC\", # Myeloid cells\n    clusters == \"cluster_3\" ~ \"SC\", # Squamous cells\n    clusters == \"cluster_4\" ~ \"EP\", # Epithelial cells\n    clusters == \"cluster_5\" ~ \"SC\", # Squamous cells\n    clusters == \"cluster_6\" ~ \"TC_CD4\", # CD4 T cells\n    clusters == \"cluster_7\" ~ \"BC\", # B cells\n    clusters == \"cluster_8\" ~ \"EC\", # Endothelial cells\n    clusters == \"cluster_9\" ~ \"TC_CD8\", # CD8 T cells\n    clusters == \"cluster_10\" ~ \"DC\" # Dendritic cells\n  ))\n\nNew names:\nNew names:\n• `UMAP1` -&gt; `UMAP1...1`\n• `UMAP2` -&gt; `UMAP2...2`\n• `UMAP1` -&gt; `UMAP1...3`\n• `UMAP2` -&gt; `UMAP2...4`\n\n\nWe might also be interested in how these cell types are distributed on the images themselves. Here we examine the distribution of clusters on image F3, noting the healthy epithelial and endothelial structures surrounded by tumour cells.\n\nreducedDim(cells, \"spatialCoords\") &lt;- spatialCoords(cells)\n\ncells |&gt; \n  filter(imageID == \"F3\") |&gt; \n  plotReducedDim(\"spatialCoords\", colour_by = \"cellType\")\n\nNew names:\n• `UMAP1` -&gt; `UMAP1...1`\n• `UMAP2` -&gt; `UMAP2...2`\n• `UMAP1` -&gt; `UMAP1...3`\n• `UMAP2` -&gt; `UMAP2...4`\n\n\n\n\n\n\n\n\n\n\n\n8.9.3 Check cell type frequencies\nWe find it always useful to check the number of cells in each cluster. Here we can see that cluster 10 contains lots of (most likely tumour - high expression of panCK and non-consistent expression of other markers) cells and cluster 4 contains very few cells.\n\n# Check cell type frequencies.\ncells$cellType |&gt;\n  table() |&gt;\n  sort()\n\n\n    DC     BC     MC     GC TC_CD8 TC_CD4     EC     EP     SC \n  2411   4322   5283   7993   8534  11753  14159  14170  87288 \n\n\nWe can also use the UMAP we computed earlier to visualise our data in a lower dimension and see how well our annotated cell types cluster out.\n\n# UMAP by cell type\nscater::plotReducedDim(\n  cells[, cells$imageID %in% someImages],\n  dimred = \"normUMAP\",\n  colour_by = \"cellType\"\n)\n\n\n\n\n\n\n\n\n\n\n8.9.4 Testing for association between the proportion of each cell type and progressor status\nWe recommend using a package such as diffcyt for testing for changes in abundance of cell types. However, the colTest function allows us to quickly test for associations between the proportions of the cell types and progression status using either Wilcoxon rank sum tests or t-tests. Here we see a p-value less than 0.05, but this does not equate to a small FDR.\n\n# Perform simple student's t-tests on the columns of the proportion matrix.\ntestProp &lt;- colTest(cells, \n                    condition = \"group\", \n                    feature = \"cellType\",\n                    type = \"ttest\")\n\nhead(testProp)\n\n       mean in group NP mean in group P tval.t  pval adjPval cluster\nTC_CD8            0.056           0.033   2.70 0.011   0.099  TC_CD8\nMC                0.033           0.040  -1.70 0.099   0.400      MC\nEC                0.098           0.085   1.50 0.160   0.400      EC\nBC                0.026           0.016   1.30 0.190   0.400      BC\nSC                0.560           0.590  -1.30 0.220   0.400      SC\nTC_CD4            0.074           0.084  -0.94 0.360   0.540  TC_CD4\n\n\nLet’s examine one of these clusters using our getProp() function from spicyR, which conveniently transforms our proportions into a feature matrix of images by cell type, enabling convenient downstream classification or analysis.\nNext, let’s visualise how different the proportions are\nboxplot.\n\nprop &lt;- getProp(cells, feature = \"cellType\")\nprop[1:5, 1:5]\n\n           BC         DC         EC         EP          GC\nA2 0.01501502 0.00000000 0.09129129 0.04684685 0.031831832\nA3 0.01854193 0.00000000 0.09334176 0.01769912 0.001474926\nA4 0.01196581 0.00322887 0.07901235 0.02792023 0.003988604\nA5 0.02135513 0.03190087 0.07882942 0.15344055 0.140522014\nA6 0.01783492 0.01824969 0.08710079 0.14765657 0.125259229\n\n\nIt appears that the CD8 T cells are the most differentially abundant cell type across our progressors and non-progressors. A boxplot visualisation of CD8 T cell proportion clearly shows that progressors have a lower proportion of CD8 T cells in the tumour core.\n\nclusterToUse &lt;- rownames(testProp)[1]\n\nprop |&gt;\n  select(all_of(clusterToUse)) |&gt;\n  tibble::rownames_to_column(\"imageID\") |&gt;\n  left_join(clinical, by = \"imageID\") |&gt;\n  ggplot(aes(x = group, y = .data[[clusterToUse]], fill = group)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\nNB: If you have already clustered and annotated your cells, you may only be interested in our downstream analysis capabilities, looking into identifying localisation (spicyR), cell regions (lisaClust), and cell-cell interactions (SpatioMark & Kontextual). Therefore, for the sake of convenience, we’ve provided capability to directly load in the SpatialExperiment (SPE) object that we’ve generated up to this point, complete with clusters and normalised intensities.\n\nload(system.file(\"extdata/computed_cells.rda\", package = \"spicyWorkflow\"))",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)</span>"
    ]
  },
  {
    "objectID": "08-case_study1.html#spicyr-test-spatial-relationships",
    "href": "08-case_study1.html#spicyr-test-spatial-relationships",
    "title": "8  Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)",
    "section": "8.10 spicyR: Test spatial relationships",
    "text": "8.10 spicyR: Test spatial relationships\nOur spicyR package is available on bioconductor on https://www.bioconductor.org/packages/devel/bioc/html/spicyR.html and provides a series of functions to aid in the analysis of both immunofluorescence and imaging mass cytometry data as well as other assays that can deeply phenotype individual cells and their spatial location. Here we use the spicy() function to test for changes in the spatial relationships between pair-wise combinations of cells.\nPut simply, spicyR uses the L-function to determine localisation or dispersion between cell types. The L-function is an arbitrary measure of “closeness” between points, with greater values suggesting increased localisation, and lower values suggesting dispersion.\nHere, we quantify spatial relationships using a combination of 10 radii from 10 to 100 by specifying Rs = 1:10*10 and mildly account for some global tissue structure using sigma = 50. Further information on how to optimise these parameters can be found in the vignette and the spicyR paper.\n\nspicyTest &lt;- spicy(cells,\n                   condition = \"group\",\n                   cellTypeCol = \"cellType\",\n                   imageIDCol = \"imageID\",\n                   Rs = 1:10*10,\n                   sigma = 50,\n                   BPPARAM = BPPARAM)\n\nCoercing condition into factor. Using group = NP as base comparison group. If\nthis is not the desired base group, please convert cells$group into a factor\nand change the order of levels(cells$group) so that the base group is at index\n1.\n\ntopPairs(spicyTest, n = 10)\n\n            intercept coefficient    p.value adj.pvalue   from     to\nBC__EC     -1.1346644    8.304020 0.03391529  0.6931721     BC     EC\nEC__BC     -1.5909700    7.919971 0.04134661  0.6931721     EC     BC\nGC__TC_CD4 -7.6316673   11.005639 0.05047096  0.6931721     GC TC_CD4\nTC_CD4__GC -7.5406782   11.077602 0.05709461  0.6931721 TC_CD4     GC\nTC_CD4__EP -0.7117393    4.853317 0.07261120  0.6931721 TC_CD4     EP\nEP__TC_CD4 -0.7070918    4.820661 0.07510118  0.6931721     EP TC_CD4\nEP__TC_CD8 -3.1445464    5.779536 0.08047994  0.6931721     EP TC_CD8\nTC_CD8__EP -2.9313474    5.688420 0.09522058  0.6931721 TC_CD8     EP\nTC_CD4__EC  3.1984391    4.366122 0.09716499  0.6931721 TC_CD4     EC\nEC__TC_CD4  3.1052061    4.263971 0.10461424  0.6931721     EC TC_CD4\n\n\nWe can visualise these tests using signifPlot where we observe that cell type pairs appear to become less attractive (or avoid more) in the progression sample.\n\n# Visualise which relationships are changing the most.\nsignifPlot(\n  spicyTest,\n  breaks = c(-1.5, 1.5, 0.5)\n)\n\n\n\n\n\n\n\n\nspicyR also has functionality for plotting out individual pairwise relationships. We can first try look into whether the SC tumour cell type localises with the GC granular cell type, and whether this localisation affects progression vs non-progression of the tumour.\n\nspicyBoxPlot(spicyTest, \n             from = \"SC\", \n             to = \"GC\")\n\nWarning: Removed 1 row containing non-finite outside the scale range\n(`stat_boxplot()`).\n\n\n\n\n\n\n\n\n\nAlternatively, we can look at the most differentially localised relationship between progressors and non-progressors by specifying rank = 1.\n\nspicyBoxPlot(spicyTest, \n             rank = 1)",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)</span>"
    ]
  },
  {
    "objectID": "08-case_study1.html#lisaclust-find-cellular-neighbourhoods",
    "href": "08-case_study1.html#lisaclust-find-cellular-neighbourhoods",
    "title": "8  Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)",
    "section": "8.11 lisaClust: Find cellular neighbourhoods",
    "text": "8.11 lisaClust: Find cellular neighbourhoods\nOur lisaClust package (https://www.bioconductor.org/packages/devel/bioc/html/lisaClust.html)[https://www.bioconductor.org/packages/devel/bioc/html/lisaClust.html] provides a series of functions to identify and visualise regions of tissue where spatial associations between cell-types is similar. This package can be used to provide a high-level summary of cell-type co-localisation in multiplexed imaging data that has been segmented at a single-cell resolution. Here we use the lisaClust function to clusters cells into 5 regions with distinct spatial ordering.\n\nset.seed(51773)\n\n# Cluster cells into spatial regions with similar composition.\ncells &lt;- lisaClust(\n  cells,\n  k = 4,\n  sigma = 50,\n  cellType = \"cellType\",\n  BPPARAM = BPPARAM\n)\n\nGenerating local L-curves.\n\n\n\n8.11.1 Region - cell type enrichment heatmap\nWe can try to interpret which spatial orderings the regions are quantifying using the regionMap function. This plots the frequency of each cell type in a region relative to what you would expect by chance. We can see here that our regions have neatly separated according to biological milieu, with region 1 and 2 representing our immune cell regions, region 3 representing our tumour cells, and region 4 representing our healthy epithelial and endothelial cells.\n\n# Visualise the enrichment of each cell type in each region\nregionMap(cells, cellType = \"cellType\", limit = c(0.2, 2))\n\n\n\n\n\n\n\n\n\n\n8.11.2 Visualise regions\nBy default, these identified regions are stored in the regions column in the colData of our object. We can quickly examine the spatial arrangement of these regions using ggplot on image F3, where we can see the same division of immune, healthy, and tumour tissue that we identified in our regionMap.\n\ncells |&gt; \n  filter(imageID == \"F3\") |&gt; \n  plotReducedDim(\"spatialCoords\", colour_by = \"region\")\n\n\n\n\n\n\n\n\nWhile much slower, we have also implemented a function for overlaying the region information as a hatching pattern so that the information can be viewed simultaneously with the cell type calls.\n\n# Use hatching to visualise regions and cell types.\nhatchingPlot(\n  cells,\n  useImages = \"F3\",\n  cellType = \"cellType\",\n  nbp = 300\n)\n\nConcave windows are temperamental. Try choosing values of window.length &gt; and &lt; 1 if you have problems.\n\n\n\n\n\n\n\n\n\n\n\n8.11.3 Test for association with progression\nSimilar to cell type proportions, we can quickly use the colTest function to test for associations between the proportions of cells in each region and progression status by specifying feature = \"region\".\n\n# Test if the proportion of each region is associated\n# with progression status.\ntestRegion &lt;- colTest(\n  cells,\n  feature = \"region\",\n  condition = \"group\",\n  type = \"ttest\"\n)\n\ntestRegion\n\n         mean in group NP mean in group P tval.t  pval adjPval  cluster\nregion_1            0.022          0.0079   1.90 0.066    0.20 region_1\nregion_3            0.092          0.1300  -1.70 0.100    0.20 region_3\nregion_4            0.340          0.3300   0.63 0.530    0.71 region_4\nregion_2            0.540          0.5400   0.20 0.840    0.84 region_2",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)</span>"
    ]
  },
  {
    "objectID": "08-case_study1.html#statial-identify-changes-in-cell-state.",
    "href": "08-case_study1.html#statial-identify-changes-in-cell-state.",
    "title": "8  Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)",
    "section": "8.12 Statial: Identify changes in cell state.",
    "text": "8.12 Statial: Identify changes in cell state.\nOur Statial package (https://www.bioconductor.org/packages/release/bioc/html/Statial.html) provides a suite of functions (Kontextual) for robust quantification of cell type localisation which are invariant to changes in tissue structure. In addition, we provide a suite of functions (SpatioMark) for uncovering continuous changes in marker expression associated with varying levels of localisation.\n\n8.12.1 SpatioMark: Continuous changes in marker expression associated with varying levels of localisation.\nThe first step in analysing these changes is to calculate the spatial proximity (getDistances) of each cell to every cell type. These values will then be stored in the reducedDims slot of the SingleCellExperiment object under the names distances. SpatioMark also provides functionality to look into proximal cell abundance using the getAbundance() function, which is further explored within the Statial package vignette.\n\ncells$m.cx &lt;- spatialCoords(cells)[,\"x\"]\ncells$m.cy &lt;- spatialCoords(cells)[,\"y\"]\n\ncells &lt;- getDistances(cells,\n  maxDist = 200,\n  nCores = nCores,\n  cellType = \"cellType\",\n  spatialCoords = c(\"m.cx\", \"m.cy\")\n)\n\nWe can then visualise an example image, specified with image = \"F3\" and a particular marker interaction with cell type localisation. To visualise these changes, we specify two cell types with the from and to parameters, and a marker with the marker parameter (cell-cell-marker interactions). Here, we specify the changes in the marker podoplanin in SC tumour cells as its localisation to EP epithelial cells increases or decreases, where we can observe that podoplanin decreases in tumour cells as its distance to the central cluster of epithelial cells increases.\n\np &lt;- plotStateChanges(\n  cells = cells,\n  cellType = \"cellType\",\n  spatialCoords = c(\"m.cx\", \"m.cy\"),\n  type = \"distances\",\n  image = \"F3\",\n  from = \"SC\",\n  to = \"EP\",\n  marker = \"podoplanin\",\n  size = 1,\n  shape = 19,\n  interactive = FALSE,\n  plotModelFit = FALSE,\n  method = \"lm\"\n)\n\np\n\n$image\n\n\n\n\n\n\n\n\n\n\n$scatter\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nSpatioMark aims to holistically uncover all such significant relationships by looking at all interactions across all images. The calcStateChanges function provided by Statial can be expanded for this exact purpose - by not specifying cell types, a marker, or an image, calcStateChanges will examine the most significant correlations between distance and marker expression across the entire dataset.\n\nstate_dist &lt;- calcStateChanges(\n  cells = cells,\n  cellType = \"cellType\",\n  type = \"distances\",\n  assay = 2,\n  nCores = nCores,\n  minCells = 100\n)\n\nhead(state_dist[state_dist$imageID == \"F3\",], n = 10)\n\n      imageID primaryCellType otherCellType     marker          coef      tval\n51990      F3              SC            EP podoplanin -0.0006911103 -16.90036\n23703      F3              EP            GC      CXCR3  0.0012103305  15.04988\n23704      F3              EP            GC     pSTAT3  0.0012299816  14.79933\n51978      F3              SC            GC       PDL2  0.0008802428  13.12601\n23669      F3              EP            MC       CCR7  0.0011476888  13.32900\n23595      F3              EP        TC_CD8      CXCR3  0.0016741880  12.95156\n51981      F3              SC            GC       ICOS  0.0005186181  11.75830\n23696      F3              EP            GC      CADM1  0.0011398625  12.18028\n11426      F3              EC            GC       CD31  0.0010070252  12.40866\n23650      F3              EP            EC       TIM3  0.0033539928  12.05028\n              pval          fdr\n51990 4.203881e-59 9.004712e-57\n23703 8.041089e-41 8.191646e-39\n23704 8.916789e-40 8.712976e-38\n51978 1.839014e-37 1.637728e-35\n23669 9.360248e-34 6.863845e-32\n23595 3.025912e-32 2.085497e-30\n51981 1.113579e-30 7.070268e-29\n23696 3.239532e-29 1.903862e-27\n11426 4.839241e-29 2.825645e-27\n23650 1.030900e-28 5.930114e-27\n\n\nThe results from our SpatioMark outputs can be converted from a data.frame to a matrix, using the prepMatrix() function. Note, the choice of extracting either the t-statistic or the coefficient of the linear regression can be specified using the column = \"tval\" parameter, with the coefficient being the default extracted parameter. We can see that with SpatioMark, we get some features which are significant after adjusting for FDR.\n\n# Preparing outcome vector\noutcome &lt;- cells$group[!duplicated(cells$imageID)]\nnames(outcome) &lt;- cells$imageID[!duplicated(cells$imageID)]\n\n# Preparing features for Statial\ndistMat &lt;- prepMatrix(state_dist)\n\ndistMat &lt;- distMat[names(outcome), ]\n\n# Remove some very small values\ndistMat &lt;- distMat[, colMeans(abs(distMat) &gt; 0.0001) &gt; .8]\n\nsurvivalResults &lt;- colTest(distMat, outcome, type = \"ttest\")\n\nhead(survivalResults)\n\n                  mean in group NP mean in group P tval.t    pval adjPval\nEC__EC__CD13              -0.00240        -9.6e-04   -3.6 0.00086    0.27\nSC__SC__VISTA             -0.00470        -1.7e-03   -3.3 0.00190    0.27\nSC__TC_CD4__CXCR3         -0.00015         8.8e-04   -3.4 0.00230    0.27\nSC__EP__Ki67              -0.00037        -7.3e-05   -3.2 0.00260    0.27\nEC__SC__CD68               0.00029        -3.9e-04    3.2 0.00300    0.27\nSC__BC__DNA1               0.02600        -1.4e-01    3.0 0.00480    0.27\n                            cluster\nEC__EC__CD13           EC__EC__CD13\nSC__SC__VISTA         SC__SC__VISTA\nSC__TC_CD4__CXCR3 SC__TC_CD4__CXCR3\nSC__EP__Ki67           SC__EP__Ki67\nEC__SC__CD68           EC__SC__CD68\nSC__BC__DNA1           SC__BC__DNA1\n\n\n\n\n8.12.2 Kontextual: Robust quantification of cell type localisation which is invariant to changes in tissue structure\nKontextual is a method to evaluate the localisation relationship between two cell types in an image. Kontextual builds on the L-function by contextualising the relationship between two cell types in reference to the typical spatial behaviour of a \\(3^{rd}\\) cell type/population. By taking this approach, Kontextual is invariant to changes in the window of the image as well as tissue structures which may be present.\nThe definitions of cell types and cell states are somewhat ambiguous, cell types imply well defined groups of cells that serve different roles from one another, on the other hand cell states imply that cells are a dynamic entity which cannot be discretised, and thus exist in a continuum. For the purposes of using Kontextual we treat cell states as identified clusters of cells, where larger clusters represent a “parent” cell population, and finer sub-clusters representing a “child” cell population. For example a CD4 T cell may be considered a child to a larger parent population of Immune cells. Kontextual thus aims to see how a child population of cells deviate from the spatial behaviour of their parent population, and how that influences the localisation between the child cell state and another cell state.\n\n8.12.2.1 Cell type hierarchy\nA key input for Kontextual is an annotation of cell type hierarchies. We will need these to organise all the cells present into cell state populations or clusters, e.g. all the different B cell types are put in a vector called bcells.\nHere, we use the treeKor bioconductor package treekoR to define these hierarchies in a data driven way.\n\nfergusonTree &lt;- treekoR::getClusterTree(t(assay(cells, \"norm\")),\n                                        cells$cellType,\n                                        hierarchy_method=\"hopach\")\n\nparent1 &lt;- c(\"TC_CD8\", \"TC_CD4\", \"DC\")\nparent2 &lt;- c(\"BC\", \"GC\")\nparent3 &lt;- c(parent1, parent2)\n\nparent4 &lt;- c(\"MC\", \"EP\", \"SC\")\nparent5 &lt;- c(parent4, \"EC\")\n\nall = c(parent1, parent2, parent3, parent4, parent5)\n\ntreeDf = Statial::parentCombinations(all, parent1, parent2, parent3, parent4, parent5)\n\nfergusonTree$clust_tree |&gt; plot()\n\n\n\n\n\n\n\n\nKontextual accepts a SingleCellExperiment object, a single image, or list of images from a SingleCellExperiment object, which gets passed into the cells argument. Here, we’ve specified Kontextual to perform calculations on all pairwise combinations for every cluster using the parentCombinations() function to create the treeDf dataframe which we’ve specified in the parentDf parameter. The argument r will specify the radius which the cell relationship will be evaluated on. Kontextual supports parallel processing, the number of cores can be specified using the cores argument. Kontextual can take a single value or multiple values for each argument and will test all combinations of the arguments specified.\nWe can calculate all pairwise relationships across all images for a single radius.\n\nkontext &lt;- Kontextual(\n  cells = cells,\n  cellType = \"cellType\",\n  spatialCoords = c(\"m.cx\", \"m.cy\"),\n  parentDf = treeDf,\n  r = 50,\n  cores = nCores\n)\n\nAgain, we can use the same colTest() to quickly test for associations between the Kontextual values and progression status using either Wilcoxon rank sum tests or t-tests. Similar to SpatioMark, we can specify using either the original L-function by specifying column = \"original\" in our prepMatrix() function.\n\n# Converting Kontextual result into data matrix\nkontextMat &lt;- prepMatrix(kontext)\n\n# Replace NAs with 0\nkontextMat[is.na(kontextMat)] &lt;- 0\n\nsurvivalResults &lt;- spicyR::colTest(kontextMat, outcome, type = \"ttest\")\n\nhead(survivalResults)\n\n                    mean in group NP mean in group P tval.t    pval adjPval\nSC__BC__parent2                  4.9           -3.80    3.9 0.00039   0.053\nSC__GC__parent3                 -3.7            2.60   -3.4 0.00140   0.095\nSC__TC_CD4__parent3              2.9            0.24    2.7 0.00920   0.420\nTC_CD4__EC__parent5              4.0           10.00   -2.5 0.01700   0.520\nBC__TC_CD8__parent3             -5.5            3.10   -2.2 0.03100   0.520\nSC__BC__parent3                  1.1           -3.80    2.2 0.03300   0.520\n                                cluster\nSC__BC__parent2         SC__BC__parent2\nSC__GC__parent3         SC__GC__parent3\nSC__TC_CD4__parent3 SC__TC_CD4__parent3\nTC_CD4__EC__parent5 TC_CD4__EC__parent5\nBC__TC_CD8__parent3 BC__TC_CD8__parent3\nSC__BC__parent3         SC__BC__parent3",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)</span>"
    ]
  },
  {
    "objectID": "08-case_study1.html#classifyr-classification",
    "href": "08-case_study1.html#classifyr-classification",
    "title": "8  Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)",
    "section": "8.13 ClassifyR: Classification",
    "text": "8.13 ClassifyR: Classification\nOur ClassifyR package, https://github.com/SydneyBioX/ClassifyR, formalises a convenient framework for evaluating classification in R. We provide functionality to easily include four key modelling stages; Data transformation, feature selection, classifier training and prediction; into a cross-validation loop. Here we use the crossValidate function to perform 100 repeats of 5-fold cross-validation to evaluate the performance of a random forest applied to five quantifications of our IMC data; 1) Cell type proportions 2) Cell type localisation from spicyR 3) Region proportions from lisaClust 4) Cell type localisation in reference to a parent cell type from Kontextual 5) Cell changes in response to proximal changes from SpatioMark\n\n# Create list to store data.frames\ndata &lt;- list()\n\n# Add proportions of each cell type in each image\ndata[[\"Proportions\"]] &lt;- getProp(cells, \"cellType\")\n\n# Add pair-wise associations\nspicyMat &lt;- bind(spicyTest)\nspicyMat[is.na(spicyMat)] &lt;- 0\nspicyMat &lt;- spicyMat |&gt;\n  select(!condition) |&gt;\n  tibble::column_to_rownames(\"imageID\")\n\ndata[[\"SpicyR\"]] &lt;- spicyMat\n\n# Add proportions of each region in each image\n# to the list of dataframes.\ndata[[\"LisaClust\"]] &lt;- getProp(cells, \"region\")\n\n\n# Add SpatioMark features\ndata[[\"SpatioMark\"]] &lt;- distMat\n\n# Add Kontextual features\ndata[[\"Kontextual\"]] &lt;- kontextMat\n\n\n# Set seed\nset.seed(51773)\n\n# Perform cross-validation of a random forest model\n# with 100 repeats of 5-fold cross-validation.\ncv &lt;- crossValidate(\n  measurements = data,\n  outcome = outcome,\n  classifier = \"randomForest\",\n  nFolds = 5,\n  nRepeats = 50,\n  nCores = nCores\n)\n\n\n8.13.1 Visualise cross-validated prediction performance\nHere we use the performancePlot function to assess the AUC from each repeat of the 5-fold cross-validation. We see that the lisaClust regions appear to capture information which is predictive of progression status of the patients.\n\n# Calculate AUC for each cross-validation repeat and plot.\nperformancePlot(\n  cv,\n  metric = \"AUC\",\n  characteristicsList = list(x = \"Assay Name\"),\n  orderingList = list(\"Assay Name\" = c(\"Proportions\", \"SpicyR\", \"LisaClust\", \"Kontextual\", \"SpatioMark\"))\n)\n\nWarning in .local(results, ...): AUC not found in all elements of results.\nCalculating it now.\n\n\n\n\n\n\n\n\n\nWe can also visualise which features were good at classifying which patients using the sampleMetricMap() function from ClassifyR.\n\nsamplesMetricMap(cv)\n\nWarning in .local(results, ...): Sample Accuracy not found in all elements of\nresults. Calculating it now.\n\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_tile()`).\n\n\n\n\n\n\n\n\n\nTableGrob (2 x 1) \"arrange\": 2 grobs\n  z     cells    name                 grob\n1 1 (2-2,1-1) arrange       gtable[layout]\n2 2 (1-1,1-1) arrange text[GRID.text.1936]",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)</span>"
    ]
  },
  {
    "objectID": "08-case_study1.html#summary",
    "href": "08-case_study1.html#summary",
    "title": "8  Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)",
    "section": "8.14 Summary",
    "text": "8.14 Summary\nHere we have used a pipeline of our spatial analysis R packages to demonstrate an easy way to segment, cluster, normalise, quantify and classify high dimensional in situ cytometry data all within R.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)</span>"
    ]
  },
  {
    "objectID": "08-case_study1.html#sessioninfo",
    "href": "08-case_study1.html#sessioninfo",
    "title": "8  Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)",
    "section": "8.15 sessionInfo",
    "text": "8.15 sessionInfo\n\nsessionInfo()\n\nR version 4.4.1 (2024-06-14)\nPlatform: x86_64-pc-linux-gnu\nRunning under: Debian GNU/Linux 12 (bookworm)\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 \nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.21.so;  LAPACK version 3.11.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Australia/Sydney\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] SpatialDatasets_1.4.0           ExperimentHub_2.14.0           \n [3] AnnotationHub_3.14.0            BiocFileCache_2.14.0           \n [5] dbplyr_2.5.0                    SpatialExperiment_1.16.0       \n [7] ttservice_0.4.1                 tidyr_1.3.1                    \n [9] tidySingleCellExperiment_1.16.0 Statial_1.8.0                  \n[11] lisaClust_1.14.4                ClassifyR_3.10.0               \n[13] survival_3.7-0                  BiocParallel_1.40.0            \n[15] MultiAssayExperiment_1.32.0     generics_0.1.3                 \n[17] spicyR_1.18.0                   scater_1.34.0                  \n[19] scuttle_1.16.0                  ggpubr_0.6.0                   \n[21] FuseSOM_1.8.0                   simpleSeg_1.8.0                \n[23] ggplot2_3.5.1                   dplyr_1.1.4                    \n[25] cytomapper_1.18.0               SingleCellExperiment_1.28.1    \n[27] SummarizedExperiment_1.36.0     Biobase_2.66.0                 \n[29] GenomicRanges_1.58.0            GenomeInfoDb_1.42.0            \n[31] IRanges_2.40.0                  S4Vectors_0.44.0               \n[33] BiocGenerics_0.52.0             MatrixGenerics_1.18.0          \n[35] matrixStats_1.4.1               EBImage_4.48.0                 \n\nloaded via a namespace (and not attached):\n  [1] tiff_0.1-12                 FCPS_1.3.4                 \n  [3] nnet_7.3-19                 goftest_1.2-3              \n  [5] Biostrings_2.74.0           HDF5Array_1.34.0           \n  [7] TH.data_1.1-2               vctrs_0.6.5                \n  [9] spatstat.random_3.3-2       digest_0.6.37              \n [11] png_0.1-8                   shape_1.4.6.1              \n [13] proxy_0.4-27                ggrepel_0.9.6              \n [15] deldir_2.0-4                permute_0.9-7              \n [17] magick_2.8.5                MASS_7.3-61                \n [19] reshape2_1.4.4              httpuv_1.6.15              \n [21] foreach_1.5.2               withr_3.0.2                \n [23] ggfun_0.1.7                 psych_2.4.6.26             \n [25] xfun_0.49                   ellipsis_0.3.2             \n [27] memoise_2.0.1               ggbeeswarm_0.7.2           \n [29] RProtoBufLib_2.18.0         diptest_0.77-1             \n [31] princurve_2.1.6             systemfonts_1.1.0          \n [33] tidytree_0.4.6              zoo_1.8-12                 \n [35] GlobalOptions_0.1.2         V8_6.0.0                   \n [37] DEoptimR_1.1-3              Formula_1.2-5              \n [39] prabclus_2.3-4              KEGGREST_1.46.0            \n [41] promises_1.3.0              httr_1.4.7                 \n [43] rstatix_0.7.2               rhdf5filters_1.18.0        \n [45] fpc_2.2-13                  rhdf5_2.50.0               \n [47] rstudioapi_0.17.1           UCSC.utils_1.2.0           \n [49] concaveman_1.1.0            curl_6.0.1                 \n [51] zlibbioc_1.52.0             ScaledMatrix_1.14.0        \n [53] analogue_0.17-7             polyclip_1.10-7            \n [55] GenomeInfoDbData_1.2.13     SparseArray_1.6.0          \n [57] fftwtools_0.9-11            xtable_1.8-4               \n [59] stringr_1.5.1               doParallel_1.0.17          \n [61] evaluate_1.0.1              S4Arrays_1.6.0             \n [63] irlba_2.3.5.1               colorspace_2.1-1           \n [65] filelock_1.0.3              spatstat.data_3.1-2        \n [67] flexmix_2.3-19              magrittr_2.0.3             \n [69] ggtree_3.14.0               later_1.3.2                \n [71] viridis_0.6.5               modeltools_0.2-23          \n [73] lattice_0.22-6              genefilter_1.88.0          \n [75] spatstat.geom_3.3-3         robustbase_0.99-4-1        \n [77] XML_3.99-0.17               cowplot_1.1.3              \n [79] RcppAnnoy_0.0.22            ggupset_0.4.0              \n [81] class_7.3-22                svgPanZoom_0.3.4           \n [83] pillar_1.9.0                nlme_3.1-166               \n [85] iterators_1.0.14            compiler_4.4.1             \n [87] beachmat_2.22.0             stringi_1.8.4              \n [89] tensor_1.5                  minqa_1.2.8                \n [91] plyr_1.8.9                  treekoR_1.14.0             \n [93] crayon_1.5.3                abind_1.4-8                \n [95] gridGraphics_0.5-1          locfit_1.5-9.10            \n [97] sp_2.1-4                    bit_4.5.0                  \n [99] terra_1.7-83                sandwich_3.1-1             \n[101] multcomp_1.4-26             fastcluster_1.2.6          \n[103] codetools_0.2-20            BiocSingular_1.22.0        \n[105] coop_0.6-3                  GetoptLong_1.0.5           \n[107] plotly_4.10.4               mime_0.12                  \n[109] splines_4.4.1               circlize_0.4.16            \n[111] Rcpp_1.0.13-1               profileModel_0.6.1         \n[113] knitr_1.49                  blob_1.2.4                 \n[115] utf8_1.2.4                  clue_0.3-66                \n[117] BiocVersion_3.20.0          lme4_1.1-35.5              \n[119] fs_1.6.5                    nnls_1.6                   \n[121] ggsignif_0.6.4              ggplotify_0.1.2            \n[123] tibble_3.2.1                Matrix_1.7-1               \n[125] scam_1.2-17                 statmod_1.5.0              \n[127] svglite_2.1.3               tweenr_2.0.3               \n[129] pkgconfig_2.0.3             pheatmap_1.0.12            \n[131] tools_4.4.1                 cachem_1.1.0               \n[133] RSQLite_2.3.7               viridisLite_0.4.2          \n[135] DBI_1.2.3                   numDeriv_2016.8-1.1        \n[137] fastmap_1.2.0               rmarkdown_2.29             \n[139] scales_1.3.0                grid_4.4.1                 \n[141] shinydashboard_0.7.2        broom_1.0.7                \n[143] patchwork_1.3.0             brglm_0.7.2                \n[145] BiocManager_1.30.25         carData_3.0-5              \n[147] farver_2.1.2                mgcv_1.9-1                 \n[149] yaml_2.3.10                 ggthemes_5.1.0             \n[151] cli_3.6.3                   purrr_1.0.2                \n[153] hopach_2.66.0               lifecycle_1.0.4            \n[155] uwot_0.2.2                  mvtnorm_1.3-2              \n[157] kernlab_0.9-33              backports_1.5.0            \n[159] annotate_1.84.0             cytolib_2.18.0             \n[161] gtable_0.3.6                rjson_0.2.23               \n[163] parallel_4.4.1              ape_5.8                    \n[165] limma_3.62.1                edgeR_4.4.0                \n[167] jsonlite_1.8.9              bitops_1.0-9               \n[169] bit64_4.5.2                 Rtsne_0.17                 \n[171] FlowSOM_2.14.0              yulab.utils_0.1.8          \n[173] vegan_2.6-8                 spatstat.utils_3.1-1       \n[175] BiocNeighbors_2.0.0         ranger_0.17.0              \n[177] flowCore_2.18.0             bdsmatrix_1.3-7            \n[179] spatstat.univar_3.1-1       lazyeval_0.2.2             \n[181] ConsensusClusterPlus_1.70.0 shiny_1.9.1                \n[183] htmltools_0.5.8.1           diffcyt_1.26.0             \n[185] rappdirs_0.3.3              glue_1.8.0                 \n[187] XVector_0.46.0              RCurl_1.98-1.16            \n[189] treeio_1.30.0               mclust_6.1.1               \n[191] mnormt_2.1.1                coxme_2.2-22               \n[193] jpeg_0.1-10                 gridExtra_2.3              \n[195] boot_1.3-31                 igraph_2.1.1               \n[197] R6_2.5.1                    ggiraph_0.8.10             \n[199] labeling_0.4.3              ggh4x_0.2.8                \n[201] cluster_2.1.6               Rhdf5lib_1.28.0            \n[203] aplot_0.2.3                 nloptr_2.1.1               \n[205] DelayedArray_0.32.0         tidyselect_1.2.1           \n[207] vipor_0.4.7                 ggforce_0.4.2              \n[209] raster_3.6-30               car_3.1-3                  \n[211] AnnotationDbi_1.68.0        rsvd_1.0.5                 \n[213] munsell_0.5.1               DataVisualizations_1.3.2   \n[215] data.table_1.16.2           htmlwidgets_1.6.4          \n[217] ComplexHeatmap_2.22.0       RColorBrewer_1.1-3         \n[219] rlang_1.1.4                 spatstat.sparse_3.1-0      \n[221] spatstat.explore_3.3-3      colorRamps_2.3.4           \n[223] lmerTest_3.1-3              uuid_1.2-1                 \n[225] ggnewscale_0.5.0            fansi_1.0.6                \n[227] beeswarm_0.4.0",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)</span>"
    ]
  }
]