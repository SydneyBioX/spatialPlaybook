[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Spatial analysis playbook",
    "section": "",
    "text": "Introduction",
    "crumbs": [
      "Overview",
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#welcome",
    "href": "index.html#welcome",
    "title": "Spatial analysis playbook",
    "section": "Welcome!",
    "text": "Welcome!\n\nRecent advances in highly multiplexed cell imaging technologies—such as PhenoCycler, IMC, CosMx, Xenium, and MERFISH—have fundamentally transformed our ability to study complex cellular relationships within tissues. While traditional immunohistochemistry protocols were limited to visualising cells based on just two or three surface proteins, these cutting-edge technologies can now characterise cells using over 50 proteins or thousands of RNA molecules in situ. This breakthrough enables precise classification of cell subtypes and offers an unprecedented view of cellular heterogeneity in tissue environments.\nThese technological advancements have driven the development of novel analytical approaches, essential for fully leveraging the potential of these new imaging methods. On this website, we demonstrate how packages in scdney can provide fresh insights into complex biological systems and diseases.\nThis guide presents a comprehensive workflow for analysing spatial omics data, featuring examples sorted by different imaging technologies. The workflow described here contains 7 major stages:\n\nCell segmentation and pre-processing\nQuality control and normalisation\nCell clustering/annotation\nQuantifying co-localisation between cell types\nIdentifying spatial domains\nMeasuring changes in marker expression\nClassification of patients to clinical outcomes\n\nWe encourage focusing on the biological questions these methods can address rather than the specific technologies used.",
    "crumbs": [
      "Overview",
      "Introduction"
    ]
  },
  {
    "objectID": "packages.html",
    "href": "packages.html",
    "title": "\n1  Packages\n",
    "section": "",
    "text": "1.1 MoleculeExperiment\nMoleculeExperiment contains functions to create and work with objects from the new MoleculeExperiment class. We introduce this class for analysing molecule-based spatial transcriptomics data (e.g., Xenium by 10X, Cosmx SMI by Nanostring, and Merscope by Vizgen). This allows researchers to analyse spatial transcriptomics data at the molecule level, and to have standardised data formats accross vendors.\nPeters Couto B, Robertson N, Patrick E, Ghazanfar S (2024). MoleculeExperiment: Prioritising a molecule-level storage of Spatial Transcriptomics Data. R package version 1.6.0.",
    "crumbs": [
      "Overview",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "packages.html#simpleseg",
    "href": "packages.html#simpleseg",
    "title": "\n1  Packages\n",
    "section": "\n1.2 simpleSeg",
    "text": "1.2 simpleSeg\n\nImage segmentation is the process of identifying the borders of individual objects (in this case cells) within an image. This allows for the features of cells such as marker expression and morphology to be extracted, stored and analysed. simpleSeg provides functionality for user friendly, watershed based segmentation on multiplexed cellular images in R based on the intensity of user specified protein marker channels. simpleSeg can also be used for the normalization of single cell data obtained from multiple images.\n\n\nCanete N, Nicholls A, Patrick E (2024). simpleSeg: A package to perform simple cell segmentation. R package version 1.8.0.",
    "crumbs": [
      "Overview",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "packages.html#scmerge",
    "href": "packages.html#scmerge",
    "title": "\n1  Packages\n",
    "section": "\n1.3 scMerge",
    "text": "1.3 scMerge\n\nLike all gene expression data, single-cell data suffers from batch effects and other unwanted variations that makes accurate biological interpretations difficult. The scMerge method leverages factor analysis, stably expressed genes (SEGs) and (pseudo-) replicates to remove unwanted variations and merge multiple single-cell data. This package contains all the necessary functions in the scMerge pipeline, including the identification of SEGs, replication-identification methods, and merging of single-cell data.\n\n\nLin Y, Ghazanfar S, Wang K, Gagnon-Bartsch J, Lo K, Su X, Han Z, Ormerod J, Speed T, Yang P, Yang J (2019). “scMerge leverages factor analysis, stable expression, and pseudoreplication to merge multiple single-cell RNA-seq datasets.” Proceedings of the National Academy of Sciences. doi:10.1073/pnas.1820006116.",
    "crumbs": [
      "Overview",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "packages.html#fusesom",
    "href": "packages.html#fusesom",
    "title": "\n1  Packages\n",
    "section": "\n1.4 FuseSOM",
    "text": "1.4 FuseSOM\n\nA correlation-based multiview self-organizing map for the characterization of cell types in highly multiplexed in situ imaging cytometry assays (FuseSOM) is a tool for unsupervised clustering. FuseSOM is robust and achieves high accuracy by combining a Self Organizing Map architecture and a Multiview integration of correlation based metrics. This allows FuseSOM to cluster highly multiplexed in situ imaging cytometry assays.\n\n&lt;0-length citation&gt;",
    "crumbs": [
      "Overview",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "packages.html#treekor",
    "href": "packages.html#treekor",
    "title": "\n1  Packages\n",
    "section": "\n1.5 treekoR",
    "text": "1.5 treekoR\n\ntreekoR is a novel framework that aims to utilise the hierarchical nature of single cell cytometry data to find robust and interpretable associations between cell subsets and patient clinical end points. These associations are aimed to recapitulate the nested proportions prevalent in workflows inovlving manual gating, which are often overlooked in workflows using automatic clustering to identify cell populations. We developed treekoR to: Derive a hierarchical tree structure of cell clusters; quantify a cell types as a proportion relative to all cells in a sample (%total), and, as the proportion relative to a parent population (%parent); perform significance testing using the calculated proportions; and provide an interactive html visualisation to help highlight key results.\n\n\nChan A (2024). treekoR: Cytometry Cluster Hierarchy and Cellular-to-phenotype Associations. R package version 1.14.0.",
    "crumbs": [
      "Overview",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "packages.html#scfeatures",
    "href": "packages.html#scfeatures",
    "title": "\n1  Packages\n",
    "section": "\n1.6 scFeatures",
    "text": "1.6 scFeatures\n\nscFeatures constructs multi-view representations of single-cell and spatial data. scFeatures is a tool that generates multi-view representations of single-cell and spatial data through the construction of a total of 17 feature types. These features can then be used for a variety of analyses using other software in Biocondutor.\n\n\nCao,Y., Lin,Y., Patrick,E., Yang,P., Yang,J.Y.H. & (2022). “scFeatures: multi-view representations of single-cell and spatial data for disease outcome prediction.” Bioinformatics, 38(20), 4745-4753. ISSN 1367-4803, doi:10.1093/bioinformatics/btac590.",
    "crumbs": [
      "Overview",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "packages.html#schot",
    "href": "packages.html#schot",
    "title": "\n1  Packages\n",
    "section": "\n1.7 scHOT",
    "text": "1.7 scHOT\n\nSingle cell Higher Order Testing (scHOT) is an R package that facilitates testing changes in higher order structure of gene expression along either a developmental trajectory or across space. scHOT is general and modular in nature, can be run in multiple data contexts such as along a continuous trajectory, between discrete groups, and over spatial orientations; as well as accommodate any higher order measurement such as variability or correlation. scHOT meaningfully adds to first order effect testing, such as differential expression, and provides a framework for interrogating higher order interactions from single cell data.\n\n\nGhazanfar S, Lin Y (2024). scHOT: single-cell higher order testing. R package version 1.18.0.",
    "crumbs": [
      "Overview",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "packages.html#spicyr",
    "href": "packages.html#spicyr",
    "title": "\n1  Packages\n",
    "section": "\n1.8 spicyR",
    "text": "1.8 spicyR\n\nThe spicyR package provides a framework for performing inference on changes in spatial relationships between pairs of cell types for cell-resolution spatial omics technologies. spicyR consists of three primary steps: (i) summarizing the degree of spatial localization between pairs of cell types for each image; (ii) modelling the variability in localization summary statistics as a function of cell counts and (iii) testing for changes in spatial localizations associated with a response variable.\n\n\nCanete N, Iyengar S, Ormerod J, Baharlou H, Harman A, Patrick E (2022). “spicyR: spatial analysis of in situ cytometry data in R.” Bioinformatics, 38(11), 3099–3105. doi:10.1093/bioinformatics/btac268.",
    "crumbs": [
      "Overview",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "packages.html#statial",
    "href": "packages.html#statial",
    "title": "\n1  Packages\n",
    "section": "\n1.9 Statial",
    "text": "1.9 Statial\n\nStatial is a suite of functions for identifying changes in cell state. The functionality provided by Statial provides robust quantification of cell type localisation which are invariant to changes in tissue structure. In addition to this Statial uncovers changes in marker expression associated with varying levels of localisation. These features can be used to explore how the structure and function of different cell types may be altered by the agents they are surrounded with.\n\n\nAmeen F, Robertson N, Lin D, Ghazanfar S, Patrick E (2024). “Kontextual: Reframing analysis of spatial omics data reveals consistent cell relationships across images.” bioRxiv. doi:10.1101/2024.09.03.611109.",
    "crumbs": [
      "Overview",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "packages.html#lisaclust",
    "href": "packages.html#lisaclust",
    "title": "\n1  Packages\n",
    "section": "\n1.10 lisaClust",
    "text": "1.10 lisaClust\n\nlisaClust provides a series of functions to identify and visualise regions of tissue where spatial associations between cell-types is similar. This package can be used to provide a high-level summary of cell-type colocalization in multiplexed imaging data that has been segmented at a single-cell resolution.\n\n\nPatrick E, Canete N (2024). lisaClust: lisaClust: Clustering of Local Indicators of Spatial Association. R package version 1.14.4.",
    "crumbs": [
      "Overview",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "packages.html#classifyr",
    "href": "packages.html#classifyr",
    "title": "\n1  Packages\n",
    "section": "\n1.11 ClassifyR",
    "text": "1.11 ClassifyR\n\nThe software formalises a framework for classification and survival model evaluation in R. There are four stages; Data transformation, feature selection, model training, and prediction. The requirements of variable types and variable order are fixed, but specialised variables for functions can also be provided. The framework is wrapped in a driver loop that reproducibly carries out a number of cross-validation schemes. Functions for differential mean, differential variability, and differential distribution are included. Additional functions may be developed by the user, by creating an interface to the framework.\n\n\nStrbenac D, Mann GJ, Ormerod JT, Yang JYH (2015). “ClassifyR: an R package for performance assessment of classification with applications to transcriptomics.” Bioinformatics, 31(11), 1851-1853.",
    "crumbs": [
      "Overview",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "datasets.html",
    "href": "datasets.html",
    "title": "2  Datasets",
    "section": "",
    "text": "2.1 Spatial Proteomics",
    "crumbs": [
      "Overview",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datasets</span>"
    ]
  },
  {
    "objectID": "datasets.html#spatial-proteomics",
    "href": "datasets.html#spatial-proteomics",
    "title": "2  Datasets",
    "section": "",
    "text": "2.1.1 IMC\nImaging Mass Cytometry (IMC) is a high-resolution, multiplexed imaging technique that combines laser ablation with mass cytometry to visualize metal-tagged antibodies in tissue sections or cell samples. Using a pulsed laser, IMC systematically ablates the sample, releasing metal isotopes that are then analysed by time-of-flight mass spectrometry. This allows for the simultaneous detection of 40+ biomarkers at subcellular resolution, typically around 1 µm, without the spectral overlap issues found in fluorescence-based imaging.\n\n2.1.1.1 Head and neck cutaneous squamous cell carcinoma (Ferguson 2022)\nSquamous cell carcinoma (SCC) is the second most common skin cancer, with high-risk head and neck SCC (HNcSCC) being aggressive and prone to recurrence or metastasis, particularly in immunosuppressed patients. This study used IMC to profile the tumour microenvironment of 31 patients to identify cellular interactions that were associated with tumour progression. A panel of 36 markers was used, and patients were classified into one of two categories: non-progressors (NP) for those that were negative for metastases and progressors (P) that were positive for metastases. The study identified early immune responses that were crucial in controlling tumour progression and improving patient prognosis.\n Ferguson et al. (2022). High-Dimensional and Spatial Analysis Reveals Immune Landscape–Dependent Progression in Cutaneous Squamous Cell Carcinoma. Clinical Cancer Research, 28(21), 4677-4688. (DOI)\n\n\n2.1.1.2 Type 1 diabetes progression (Damond 2019)\nType 1 diabetes (T1D) results from the autoimmune destruction of insulin-producing β cells. This study analysed pancreatic tissue obtained from 12 patients at 3 different stages of diabetes: non-diabetic, early onset, and long-term using a 35-plex antibody panel. Analysis revealed key cellular movements that preceded the destruction of insulin-producing β cells, highlighting potential targets for future therapies and treatments.\n Damond et al. (2019). A Map of Human Type 1 Diabetes Progression by Imaging Mass Cytometry. Cell Metabolism, 29(3), 755-768.e5. (DOI)\n\n\n\n2.1.2 MIBI-TOF\nMIBI-TOF (multiplexed ion beam imaging by time-of-flight) is an imaging technique that uses bright ion sources and orthogonal time-of-flight mass spectrometry to image metal-tagged antibodies at subcellular resolution in clinical tissue sections. It is capable of imaging approximately 40 labelled antibodies, providing a highly detailed and multiplexed view of tissue architecture and protein expression. MIBI-TOF can capture image fields of around 1 mm² with exceptional spatial resolution, reaching down to 260 nm.\n\n2.1.2.1 Ductal carcinoma in situ (Risom 2022)\nDuctal carcinoma in situ (DCIS) is a pre-invasive lesion considered a precursor to invasive breast cancer (IBC). This study utilized MIBI-TOF with a 37-plex antibody panel to analyze spatial relationships within the Washington University Resource Archival Human Breast Tissue (RAHBT) cohort. The findings identified key drivers of IBC relapse and emphasized the critical role of the tumour microenvironment in influencing disease progression.\n Risom et al. (2022). Transition to invasive breast cancer is associated with progressive changes in the structure and composition of tumor stroma. Cell, 185(2), 299-310.e18 (DOI) \n\n\n2.1.2.2 Triple Negative Breast Cancer (Keren 2018)\nThis study profiles 36 proteins in tissue samples from 41 patients with triple-negative breast cancer (a particularly aggressive form of cancer) using MIBI-TOF. The dataset captures high-resolution, spatially resolved data on 17 distinct cell populations, immune composition, checkpoint protein expression, and tumor-immune interactions. Patients were classified into three categories based on the type of tumour: cold (no immune cell infiltration), compartmentalised (immune cells spatially separated from tumor cells), and mixed (immune cells mixed with tumor cells).\n Keren et al. (2018). A Structured Tumor-Immune Microenvironment in Triple Negative Breast Cancer Revealed by Multiplexed Ion Beam Imaging. Cell, 174(6), 1373-1387.e1319. (DOI) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn the following section, we provide a quick guide to help you get started with performing spatial analysis.",
    "crumbs": [
      "Overview",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datasets</span>"
    ]
  },
  {
    "objectID": "getting_started.html",
    "href": "getting_started.html",
    "title": "\n3  Getting Started\n",
    "section": "",
    "text": "3.1 What technologies is our software applicable to?\nOur suite of packages is geared towards analysing single-cell resolution assays, and the workflow described here focuses on single-cell resolution assays that have spatial context, i.e., each of the cells has an x-y coordinate. Technologies that generate this type of data include Imaging Mass Cytometry, MIBI-TOF, Xenium, CosMx, and MERFISH.\nPlease check out our scdney suite of packages for how to analyse many different types of single cell resolution assays.",
    "crumbs": [
      "Overview",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "getting_started.html#using-our-packages",
    "href": "getting_started.html#using-our-packages",
    "title": "\n3  Getting Started\n",
    "section": "\n3.2 Using our packages",
    "text": "3.2 Using our packages\nIt is important to know that our packages are interoperable with many other awesome packages out there. We highly recommend that you reflect on your needs or what you would like to find in your data, and then choose the analytical methods that will be most appropriate for your data.\nTo get started with our packages, we recommend that you read the descriptions of our packages on the Software page. Clicking on the beautiful hex stickers will take you to the package vignettes that will explain their functionality in depth.\nWe also recommend that you browse our analysis examples in the case studies chapter. Here, you will find the application of combinations of our packages to answer multi-component questions on a diverse range of spatially-resolved single-cell assays. While reading this, keep the specific assay in mind for context, but also recognize that most of the demonstrated analytical approaches can be applied to a wide range of assays.",
    "crumbs": [
      "Overview",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "getting_started.html#spatialexperiment",
    "href": "getting_started.html#spatialexperiment",
    "title": "\n3  Getting Started\n",
    "section": "\n3.3 SpatialExperiment",
    "text": "3.3 SpatialExperiment\nIn keeping with interoperability, we use the SpatialExperiment object from the SpatialExperiment package as the central linking framework across many of the packages.\n\nlibrary(readxl)\nlibrary(Seurat)\n\n\n3.3.1 Creating a SpatialExperiment object\n\nThe vignette for the SpatialExperiment package explains how to turn a matrix or data.frame into a SpatialExperiment.\nIf you have a .csv file or a .xlsx file, this can be read into R using read_csv() and read_xlsx() from the readxl package and converted into a matrix or data.frame. You could also use read.csv() or read.delim() in base R.\nIf you have a Seurat object, you can convert this to a SingleCellExperiment using the as.SingleCellExperiment() function or back again using as.Seurat().\nA SpatialExperiment object is very similar to a SingleCellExperiment but with spatial coordinates stored in the spatialCoords() slot. Many people analyse spatial data using a SingleCellExperiment object with the spatial coordinates stored in colData. Most of our packages are accepting of this approach.\nFor visualisations, we recommend duplicating your spatialCoords() in the reducedDim() slot and in the colData.\n\n3.3.2 Installing packages\nTo get started with the workflow, you can install the following Bioconductor packages:\n\nif (!require(\"BiocManager\", quietly = TRUE))\n  install.packages(\"BiocManager\")\nBiocManager::install(version = \"3.20\")\n\n# Bioconductor packages\nBiocManager::install(c(\"SingleCellExperiment\",\n                       \"SpatialExperiment\",\n                       \"tidySingleCellExperiment\",\n                       \"SpatialDatasets\",\n                       \"cytomapper\",\n                       \"EBImage\",\n                       \"simpleSeg\",\n                       \"scater\",\n                       \"FuseSOM\",\n                       \"STexampleData\",\n                       \"scuttle\",\n                       \"scClassify\",\n                       \"spicyR\",\n                       \"Statial\",\n                       \"imcRtools\",\n                       \"treekoR\",\n                       \"lisaClust\",\n                       \"ClassifyR\"))\n\n\n# other packages\ninstall.packages(c(\"dplyr\",\n                   \"ggplot2\",\n                   \"MLmetrics\",\n                   \"survival\",\n                   \"tibble\",\n                   \"ggsurvfit\",\n                   \"ggpubr\"))\n\nWe can now move on to the first stage of the spatial analysis pipeline.",
    "crumbs": [
      "Overview",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "01-processing.html",
    "href": "01-processing.html",
    "title": "\n4  Cell segmentation and pre-processing\n",
    "section": "",
    "text": "4.1 Reading in data with cytomapper\nWe will be using the Ferguson 2022 dataset to demonstrate how to perform pre-processing and cell segmentation. This dataset can be accessed through the SpatialDatasets package and is available in the form of single-channel TIFF images. In single-channel images, each pixel represents intensity values for a single marker. The loadImages function from the cytomapper package can be used to load all the TIFF images into a CytoImageList object and store the images as an h5 file on-disk in a temporary directory using the h5FilesPath = HDF5Array::getHDF5DumpDir() parameter.\nWe will also assign the metadata columns of the CytoImageList object using the mcols function.\npathToZip &lt;- SpatialDatasets::Ferguson_Images()\npathToImages &lt;- \"data/processing/images\"\nunzip(pathToZip, exdir = \"data/processing/images\")\n\n# store images in a CytoImageList on_disk as h5 files to save memory\nimages &lt;- cytomapper::loadImages(\n  pathToImages,\n  single_channel = TRUE,\n  on_disk = TRUE,\n  h5FilesPath = HDF5Array::getHDF5DumpDir(),\n  BPPARAM = BPPARAM\n)\n\n# assign metadata columns\nmcols(images) &lt;- S4Vectors::DataFrame(imageID = names(images))\nTime for this code chunk to run with 5.5 cores: 156.64 seconds\nWhen reading the image channels directly from the names of the TIFF images, they will often need to be cleaned for ease of downstream processing. The channel names can be accessed from the CytoImageList object using the channelNames function.\nchannelNames(images) &lt;- channelNames(images) |&gt;\n                          # remove preceding letters\n                          sub(pattern = \".*_\", replacement = \"\", x = _) |&gt; \n                          # remove the .ome\n                          sub(pattern = \".ome\", replacement = \"\", x = _)\nSimilarly, the image names will be taken from the folder name containing the individual TIFF images for each channel. These will often also need to be cleaned.\n# cleaning image names to obtain image IDs\nsplit_names &lt;- function(x) {\n  sapply(strsplit(x, \"_\"), `[`, 3)\n}\n\nnames(images) &lt;- names(images) |&gt; split_names()\nmcols(images) &lt;- S4Vectors::DataFrame(imageID = names(images))",
    "crumbs": [
      "Processing",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Cell segmentation and pre-processing</span>"
    ]
  },
  {
    "objectID": "01-processing.html#cell-segmentation-with-simpleseg",
    "href": "01-processing.html#cell-segmentation-with-simpleseg",
    "title": "\n4  Cell segmentation and pre-processing\n",
    "section": "\n4.2 Cell segmentation with simpleSeg",
    "text": "4.2 Cell segmentation with simpleSeg\nFor the sake of simplicity and efficiency, we will be subsetting our images down to 10 images.\n\nimages &lt;- images[1:10]\n\nNext, we can perform our segmentation. The simpleSeg package on Bioconductor provides functionality for user friendly, watershed based segmentation on multiplexed cellular images based on the intensity of user-specified protein marker channels. The main function, simpleSeg, can be used to perform a simple cell segmentation process that traces out the nuclei using a specified channel.\nIn the particular example below, we have asked simpleSeg to do the following:\n\n\nnucleus = c(\"HH3\"): trace out the nuclei signal in the images using the HH3 channel.\n\npca = TRUE: segment out the nuclei mask using principal component analysis of all channels and using the principal components most aligned with the nuclei channel (in this case, HH3).\n\ncellBody = \"dilate\": use a dilation strategy of segmentation, expanding out from the nucleus by a specified discSize. In this case, discSize = 3, which means simpleSeg dilates out from the nucleus by 3 pixels.\n\nsizeSelection = 20: ensure that only cells with a size greater than 20 pixels will be used.\n\ntransform = \"sqrt\": perform square root transformation on each of the channels prior to segmentation.\n\ntissue = c(\"panCK\", \"CD45\", \"HH3\"): use the specified tissue mask to filter out all background noise outside the tissue mask. This allows us to ignore background noise which happens outside of the tumour core.\n\nThere are many other parameters that can be specified in simpleSeg (smooth, watershed, tolerance, and ext), and we encourage the user to select the parameters which best suit their biological context.\n\nmasks &lt;- simpleSeg(images,\n                   nucleus = c(\"HH3\"),\n                   pca = TRUE,\n                   cellBody = \"dilate\",\n                   discSize = 3,\n                   sizeSelection = 20,\n                   transform = \"sqrt\",\n                   tissue = c(\"panCK\", \"CD45\", \"HH3\"),\n                   cores = nCores)\nTime for this code chunk to run with 5.5 cores: 53.68 seconds\n\n\n4.2.1 Visualise separation\nWe can examine the performance of the cell segmentation using the display and colorLabels functions from the EBImage package. If used in an interactive session, display allows you to zoom in and out of the image.\n\n# display image F3\nEBImage::display(colorLabels(masks[[1]]))\n\n\n\n\n\n\n\n\n4.2.2 Visualise outlines\nThe plotPixels function from the cytomapper package makes it easy to overlay the mask on top of the nucleus intensity marker to see how well our segmentation process has performed.\n\nplotPixels(image = images[\"F3\"], \n           mask = masks[\"F3\"],\n           img_id = \"imageID\", \n           colour_by = c(\"HH3\"), \n           display = \"single\",\n           colour = list(HH3 = c(\"black\",\"blue\")),\n           legend = NULL,\n           bcg = list(\n             HH3 = c(1, 1, 2)\n           ))\n\n\n\n\n\n\n\nHere, we can see that the segmentation appears to be performing reasonably.\nIf you see over or under-segmentation of your images, discSize is a key parameter in the simpleSeg function for optimising the size of the dilation disc after segmenting out the nuclei.\nWe can also visualise multiple markers at once instead of just the HH3 marker to see how the segmentation mask performs.\n\nplotPixels(image = images[\"F3\"], \n           mask = masks[\"F3\"],\n           img_id = \"imageID\", \n           colour_by = c(\"HH3\", \"CD31\", \"FX111A\"), \n           display = \"single\",\n           colour = list(HH3 = c(\"black\",\"blue\"),\n                         CD31 = c(\"black\", \"red\"),\n                         FX111A = c(\"black\", \"green\")),\n           legend = NULL,\n           bcg = list(\n             HH3 = c(1, 1, 2),\n             CD31 = c(0, 1, 2),\n             FX111A = c(0, 1, 1.5)\n           ))\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nWhat to look for and change to obtain an ideal segmentation\n\nDoes the segmentation capture the full nucleus? If not, perhaps you need to try a different transformation to improve the thresholding of the nuclei marker. You could also try using pca = TRUE which will borrow information across the markers to help find the nuclei.\nHow much of the cell body is the segmentation missing? Try increasing the dilation around the nucleus by setting discSize = 7.\nAre the segmentations capturing neighbouring cells? Try decreasing the dilation to limit lateral spillover of marker signal by setting discSize = 2.\n\n\n\nHere, we can see that our segmentation mask has done a good job of capturing the CD31 signal, but perhaps not such a good job of capturing the FXIIIA signal, which often lies outside of our dilated nuclear mask. This suggests that we might need to increase the discSize or other parameters of simpleSeg.\nIn particular, the cellBody and watershed parameters can strongly influence the way cells are segmented using simpleSeg. We have provided further details on how the user may specify cell body identification and watershedding in the tables below.\nAs simpleSeg is a nuclei-based dilation method, it suffers from tissues where cells might be multi-nucleated, or where cells have non-circular or elliptical morphologies. For tissues where you might expect these cells, it may be preferable to choose a different segmentation method.\n\n4.2.2.1 cellBody Parameters\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n“distance”\nPerforms watershedding on a distance map of the thresholded nuclei signal. With a pixels distance being defined as the distance from the closest background signal.\n\n\n“intensity”\nPerforms watershedding using the intensity of the nuclei marker.\n\n\n“combine”\nCombines the previous two methods by multiplying the distance map by the nuclei marker intensity.\n\n\n\n4.2.2.2 watershed Parameters\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n“dilation”\nDilates the nuclei by an amount defined by the user. The size of the dilatation in pixels may be specified with the discDize argument.\n\n\n“discModel”\nUses all the markers to predict the presence of dilated ‘discs’ around the nuclei. The model therefore learns which markers are typically present in the cell cytoplasm and generates a mask based on this.\n\n\n“marker”\nThe user may specify one or multiple dedicated cytoplasm markers to predict the cytoplasm. This can be done using cellBody = \"marker name\"/\"index\"\n\n\n“None”\nThe nuclei mask is returned directly.",
    "crumbs": [
      "Processing",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Cell segmentation and pre-processing</span>"
    ]
  },
  {
    "objectID": "01-processing.html#summarise-cell-features",
    "href": "01-processing.html#summarise-cell-features",
    "title": "\n4  Cell segmentation and pre-processing\n",
    "section": "\n4.3 Summarise cell features",
    "text": "4.3 Summarise cell features\nWe can use the measureObjects from cytomapper to calculate the average intensity of each channel within each cell, as well as other morphological features. By default, measureObjects will return a SingleCellExperiment object, where the channel intensities are stored in the counts assay and the spatial location of each cell is stored in colData in the m.cx and m.cy columns.\nHowever, you can also specify measureObjects to return a SpatialExperiment object by specifying return_as = \"spe\". In a SpatialExperiment object, the spatial location of each cell is stored in the spatialCoords slot as m.cx and m.cy, which simplifies plotting. In this demonstration, we will return a SpatialExperiment object.\n\n# summarise the expression of each marker in each cell\ncells &lt;- cytomapper::measureObjects(masks,\n                                    images,\n                                    img_id = \"imageID\",\n                                    return_as = \"spe\",\n                                    BPPARAM = BPPARAM)\n\nspatialCoordsNames(cells) &lt;- c(\"x\", \"y\")\n\ncells\n\nclass: SpatialExperiment \ndim: 36 37953 \nmetadata(0):\nassays(1): counts\nrownames(36): panCK CD20 ... DNA1 DNA2\nrowData names(0):\ncolnames: NULL\ncolData names(8): imageID object_id ... sample_id objectNum\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\nspatialCoords names(2) : x y\nimgData names(1): sample_id\n\nTime for this code chunk to run with 5.5 cores: 48.93 seconds\n\nSo far, we have processed our raw TIFF images, performed cell segmentation to isolate individual cells, and then stored our data as a SpatialExperiment object. We can now move on to quality control, data transformation, and normalisation to address batch effects.",
    "crumbs": [
      "Processing",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Cell segmentation and pre-processing</span>"
    ]
  },
  {
    "objectID": "01-processing.html#sessioninfo",
    "href": "01-processing.html#sessioninfo",
    "title": "\n4  Cell segmentation and pre-processing\n",
    "section": "\n4.4 sessionInfo",
    "text": "4.4 sessionInfo\n\nsessionInfo()\n\nR version 4.4.1 (2024-06-14)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Sonoma 14.4.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Australia/Sydney\ntzcode source: internal\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] SpatialDatasets_1.4.0       SpatialExperiment_1.16.0   \n [3] ExperimentHub_2.14.0        AnnotationHub_3.14.0       \n [5] BiocFileCache_2.14.0        dbplyr_2.5.0               \n [7] simpleSeg_1.8.0             ggplot2_3.5.1              \n [9] cytomapper_1.18.0           SingleCellExperiment_1.28.1\n[11] SummarizedExperiment_1.36.0 Biobase_2.66.0             \n[13] GenomicRanges_1.58.0        GenomeInfoDb_1.42.0        \n[15] IRanges_2.40.0              S4Vectors_0.44.0           \n[17] BiocGenerics_0.52.0         MatrixGenerics_1.18.0      \n[19] matrixStats_1.4.1           EBImage_4.48.0             \n\nloaded via a namespace (and not attached):\n  [1] DBI_1.2.3               bitops_1.0-9            deldir_2.0-4           \n  [4] gridExtra_2.3           rlang_1.1.4             magrittr_2.0.3         \n  [7] svgPanZoom_0.3.4        shinydashboard_0.7.2    RSQLite_2.3.8          \n [10] compiler_4.4.1          spatstat.geom_3.3-4     png_0.1-8              \n [13] systemfonts_1.1.0       fftwtools_0.9-11        vctrs_0.6.5            \n [16] pkgconfig_2.0.3         crayon_1.5.3            fastmap_1.2.0          \n [19] magick_2.8.5            XVector_0.46.0          utf8_1.2.4             \n [22] promises_1.3.2          rmarkdown_2.29          UCSC.utils_1.2.0       \n [25] ggbeeswarm_0.7.2        purrr_1.0.2             bit_4.5.0              \n [28] xfun_0.49               cachem_1.1.0            zlibbioc_1.52.0        \n [31] jsonlite_1.8.9          blob_1.2.4              later_1.4.1            \n [34] rhdf5filters_1.18.0     DelayedArray_0.32.0     spatstat.utils_3.1-1   \n [37] Rhdf5lib_1.28.0         BiocParallel_1.40.0     jpeg_0.1-10            \n [40] tiff_0.1-12             terra_1.7-78            parallel_4.4.1         \n [43] R6_2.5.1                RColorBrewer_1.1-3      spatstat.data_3.1-4    \n [46] spatstat.univar_3.1-1   Rcpp_1.0.13-1           knitr_1.49             \n [49] httpuv_1.6.15           Matrix_1.7-1            nnls_1.6               \n [52] tidyselect_1.2.1        yaml_2.3.10             rstudioapi_0.17.1      \n [55] abind_1.4-8             viridis_0.6.5           codetools_0.2-20       \n [58] curl_6.0.1              lattice_0.22-6          tibble_3.2.1           \n [61] KEGGREST_1.46.0         shiny_1.9.1             withr_3.0.2            \n [64] evaluate_1.0.1          polyclip_1.10-7         Biostrings_2.74.0      \n [67] filelock_1.0.3          BiocManager_1.30.25     pillar_1.9.0           \n [70] generics_0.1.3          sp_2.1-4                RCurl_1.98-1.16        \n [73] BiocVersion_3.20.0      munsell_0.5.1           scales_1.3.0           \n [76] xtable_1.8-4            glue_1.8.0              tools_4.4.1            \n [79] locfit_1.5-9.10         rhdf5_2.50.0            grid_4.4.1             \n [82] AnnotationDbi_1.68.0    colorspace_2.1-1        GenomeInfoDbData_1.2.13\n [85] raster_3.6-30           beeswarm_0.4.0          HDF5Array_1.34.0       \n [88] vipor_0.4.7             cli_3.6.3               rappdirs_0.3.3         \n [91] fansi_1.0.6             S4Arrays_1.6.0          viridisLite_0.4.2      \n [94] svglite_2.1.3           dplyr_1.1.4             gtable_0.3.6           \n [97] digest_0.6.37           SparseArray_1.6.0       rjson_0.2.23           \n[100] htmlwidgets_1.6.4       memoise_2.0.1           htmltools_0.5.8.1      \n[103] lifecycle_1.0.4         httr_1.4.7              mime_0.12              \n[106] bit64_4.5.2",
    "crumbs": [
      "Processing",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Cell segmentation and pre-processing</span>"
    ]
  },
  {
    "objectID": "02-quality_control.html",
    "href": "02-quality_control.html",
    "title": "\n5  Quality Control\n",
    "section": "",
    "text": "5.1 simpleSeg: Do my images have a batch effect?\nFirst, let’s load in the images we previously segmented out in the last section. The SpatialDatasets package conveniently provides the segmented out images for the Ferguson 2022 dataset.\n# load in segmented data\nfergusonSPE &lt;- SpatialDatasets::spe_Ferguson_2022()\nNext, we can check if the marker intensities of each cell require some form of transformation or normalisation. The reason we do this is two-fold:\nBy transforming and normalising the data, we aim to reduce these two effects. Below, we extract the marker intensities from the counts assay and take a closer look at the CD3 marker, which should be expressed in the majority of T cells.\n# plot densities of CD3 for each image\nfergusonSPE |&gt; \n  join_features(features = rownames(fergusonSPE), shape = \"wide\", assay = \"counts\") |&gt; \n  ggplot(aes(x = CD3, colour = imageID)) + \n  geom_density() + \n  theme(legend.position = \"none\")\nHere, we can see that the intensities are very clearly skewed, and it is difficult to distinguish a CD3- cell from a CD3+ cell. Further, we can clearly see some image-level batch effects, where across images, the intensity peaks differ drastically.\nAnother method of visualising batch effects is using a dimensionality reduction technique and visualising how the images separate out on a 2D plot. If no batch effect is expected, we should see the images largely overlap with each other.\nset.seed(51773)\n\n# specify a subset of informative markers for UMAP and clustering\nct_markers &lt;- c(\"podoplanin\", \"CD13\", \"CD31\",\n                \"panCK\", \"CD3\", \"CD4\", \"CD8a\",\n                \"CD20\", \"CD68\", \"CD16\", \"CD14\", \n                \"HLADR\", \"CD66a\")\n\n# perform dimension reduction using UMAP\nfergusonSPE &lt;- scater::runUMAP(\n  fergusonSPE,\n  subset_row = ct_markers,\n  exprs_values = \"counts\"\n)\n\n# select a subset of images to plot\nsomeImages &lt;- unique(fergusonSPE$imageID)[c(1, 5, 10, 20, 30, 40)]\n\n# UMAP by imageID\nscater::plotReducedDim(\n  fergusonSPE[, fergusonSPE$imageID %in% someImages],\n  dimred = \"UMAP\",\n  colour_by = \"imageID\"\n)\n\n\n\n\n\n\nTime for this code chunk to run with 5.5 cores: 47.35 seconds\nThe UMAP also indicates that some level of batch effect exists in our dataset.\nWe can use the normalizeCells function from the simpleSeg package to correct for image-level batch effects. We specify the following parameters:\n# leave out the nuclei markers from our normalisation process\nuseMarkers &lt;- rownames(fergusonSPE)[!rownames(fergusonSPE) %in% c(\"DNA1\", \"DNA2\", \"HH3\")]\n\n# transform and normalise the marker expression of each cell type\nfergusonSPE &lt;- normalizeCells(fergusonSPE,\n                        markers = useMarkers,\n                        transformation = NULL,\n                        method = c(\"trim99\", \"mean\", \"PC1\"),\n                        assayIn = \"counts\",\n                        cores = nCores)\nThis modified data is then stored in the norm assay by default, but can be changed using the assayOut parameter.",
    "crumbs": [
      "Processing",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Quality Control</span>"
    ]
  },
  {
    "objectID": "02-quality_control.html#simpleseg-do-my-images-have-a-batch-effect",
    "href": "02-quality_control.html#simpleseg-do-my-images-have-a-batch-effect",
    "title": "\n5  Quality Control\n",
    "section": "",
    "text": "The intensities of images are often highly skewed, preventing any meaningful downstream analysis.\nThe intensities across different images are often different, meaning that what is considered “positive” can be different across images.\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nWhat we’re looking for\n\nDo the CD3+ and CD3- peaks clearly separate out in the density plot? To ensure that downstream clustering goes smoothly, we want our cell type specific markers to show 2 distinct peaks representing our CD3+ and CD3- cells. If we see 3 or more peaks where we don’t expect, this might be an indicator that further normalisation is required.\nAre our CD3+ and CD3- peaks consistent across our images? We want to make sure that our density plots for CD3 are largely the same across images so that a CD3+ cell in one image is equivalent to a CD3+ cell in another image.\n\n\n\n\n\n\n\n\n\n\ntransformation is an optional argument which specifies the function to be applied to the data. We do not apply an arcsinh transformation here, as we already apply a square root transform in the simpleSeg function.\n\nmethod = c(\"trim99\", \"mean\", PC1\") is an optional argument which specifies the normalisation method(s) to be performed. A comprehensive table of methods is provided below.\n\nassayIn = \"counts\" is a required argument which specifies the name of the assay that contains our intensity data. In our context, this is called counts.\n\n\n\n\n5.1.0.1 method Parameters\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n“mean”\nDivides the marker cellular marker intensities by their mean.\n\n\n“minMax”\nSubtracts the minimum value and scales markers between 0 and 1.\n\n\n“trim99”\nSets the highest 1% of values to the value of the 99th percentile.`\n\n\n“PC1”\nRemoves the 1st principal component) can be performed with one call of the function, in the order specified by the user.\n\n\n\nWe can then plot the same density curve for the CD3 marker using the normalised data.\n\n# plot densities of CD3 for each image\nfergusonSPE |&gt; \n  join_features(features = rownames(fergusonSPE), shape = \"wide\", assay = \"norm\") |&gt; \n  ggplot(aes(x = CD3, colour = imageID)) + \n  geom_density() + \n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nQuestions revisited\n\nDo the CD3+ and CD3- peaks clearly separate out in the density plot? If not, we can try optimising the transformation if the distribution looks heavily skewed.\nAre our CD3+ and CD3- peaks consistent across our images? We can try to be more stringent in our normalisation, such as by removing the 1st PC (method = c(..., \"PC1\")) or scaling the values for all images between 0 and 1 (method = c(..., \"minMax\")).\n\n\n\nHere, we can see that the normalised data appears more bimodal, and we can clearly observe a CD3+ peak at 5.00, and a CD3- peak at around 3.00. Image-level batch effects also appear to have been mitigated.\nWe can also visualise the effect of normalisation on the UMAP, which shows that the images now overlap with each other to a much greater extent.\n\nset.seed(51773)\n\n# perform dimension reduction using UMAP\nfergusonSPE &lt;- scater::runUMAP(\n  fergusonSPE,\n  subset_row = ct_markers,\n  exprs_values = \"norm\",\n  name = \"normUMAP\"\n)\n\nsomeImages &lt;- unique(fergusonSPE$imageID)[c(1, 5, 10, 20, 30, 40)]\n\n# UMAP by imageID\nscater::plotReducedDim(\n  fergusonSPE[, fergusonSPE$imageID %in% someImages],\n  dimred = \"normUMAP\",\n  colour_by = \"imageID\"\n)\n\n\n\n\n\n\nTime for this code chunk to run with 5.5 cores: 46.42 seconds\n\n\n\nNow that we have completed quality control checks and normalised the expression data to address variability and batch effects, we can proceed to the next step: clustering and cell annotation.",
    "crumbs": [
      "Processing",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Quality Control</span>"
    ]
  },
  {
    "objectID": "02-quality_control.html#sessioninfo",
    "href": "02-quality_control.html#sessioninfo",
    "title": "\n5  Quality Control\n",
    "section": "\n5.2 sessionInfo",
    "text": "5.2 sessionInfo\n\nsessionInfo()\n\nR version 4.4.1 (2024-06-14)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Sonoma 14.4.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Australia/Sydney\ntzcode source: internal\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] SpatialDatasets_1.4.0           SpatialExperiment_1.16.0       \n [3] ExperimentHub_2.14.0            AnnotationHub_3.14.0           \n [5] BiocFileCache_2.14.0            dbplyr_2.5.0                   \n [7] scater_1.34.0                   scuttle_1.16.0                 \n [9] simpleSeg_1.8.0                 ggplot2_3.5.1                  \n[11] ttservice_0.4.1                 tidyr_1.3.1                    \n[13] dplyr_1.1.4                     tidySingleCellExperiment_1.16.0\n[15] SingleCellExperiment_1.28.1     SummarizedExperiment_1.36.0    \n[17] Biobase_2.66.0                  GenomicRanges_1.58.0           \n[19] GenomeInfoDb_1.42.0             IRanges_2.40.0                 \n[21] S4Vectors_0.44.0                BiocGenerics_0.52.0            \n[23] MatrixGenerics_1.18.0           matrixStats_1.4.1              \n\nloaded via a namespace (and not attached):\n  [1] RColorBrewer_1.1-3      rstudioapi_0.17.1       jsonlite_1.8.9         \n  [4] magrittr_2.0.3          spatstat.utils_3.1-1    ggbeeswarm_0.7.2       \n  [7] magick_2.8.5            farver_2.1.2            rmarkdown_2.29         \n [10] zlibbioc_1.52.0         vctrs_0.6.5             memoise_2.0.1          \n [13] RCurl_1.98-1.16         terra_1.7-78            svgPanZoom_0.3.4       \n [16] htmltools_0.5.8.1       S4Arrays_1.6.0          curl_6.0.1             \n [19] BiocNeighbors_2.0.0     raster_3.6-30           Rhdf5lib_1.28.0        \n [22] SparseArray_1.6.0       rhdf5_2.50.0            htmlwidgets_1.6.4      \n [25] cachem_1.1.0            plotly_4.10.4           mime_0.12              \n [28] lifecycle_1.0.4         pkgconfig_2.0.3         rsvd_1.0.5             \n [31] Matrix_1.7-1            R6_2.5.1                fastmap_1.2.0          \n [34] GenomeInfoDbData_1.2.13 shiny_1.9.1             digest_0.6.37          \n [37] colorspace_2.1-1        AnnotationDbi_1.68.0    irlba_2.3.5.1          \n [40] RSQLite_2.3.8           beachmat_2.22.0         labeling_0.4.3         \n [43] filelock_1.0.3          fansi_1.0.6             nnls_1.6               \n [46] httr_1.4.7              polyclip_1.10-7         abind_1.4-8            \n [49] compiler_4.4.1          bit64_4.5.2             withr_3.0.2            \n [52] tiff_0.1-12             BiocParallel_1.40.0     DBI_1.2.3              \n [55] viridis_0.6.5           HDF5Array_1.34.0        cytomapper_1.18.0      \n [58] rappdirs_0.3.3          DelayedArray_0.32.0     rjson_0.2.23           \n [61] tools_4.4.1             vipor_0.4.7             beeswarm_0.4.0         \n [64] httpuv_1.6.15           glue_1.8.0              EBImage_4.48.0         \n [67] rhdf5filters_1.18.0     promises_1.3.2          grid_4.4.1             \n [70] generics_0.1.3          gtable_0.3.6            spatstat.data_3.1-4    \n [73] data.table_1.16.2       BiocSingular_1.22.0     ScaledMatrix_1.14.0    \n [76] sp_2.1-4                utf8_1.2.4              XVector_0.46.0         \n [79] RcppAnnoy_0.0.22        spatstat.geom_3.3-4     BiocVersion_3.20.0     \n [82] ggrepel_0.9.6           pillar_1.9.0            stringr_1.5.1          \n [85] later_1.4.1             lattice_0.22-6          bit_4.5.0              \n [88] deldir_2.0-4            tidyselect_1.2.1        locfit_1.5-9.10        \n [91] Biostrings_2.74.0       knitr_1.49              gridExtra_2.3          \n [94] svglite_2.1.3           xfun_0.49               shinydashboard_0.7.2   \n [97] stringi_1.8.4           UCSC.utils_1.2.0        fftwtools_0.9-11       \n[100] yaml_2.3.10             lazyeval_0.2.2          evaluate_1.0.1         \n[103] codetools_0.2-20        tibble_3.2.1            BiocManager_1.30.25    \n[106] cli_3.6.3               uwot_0.2.2              xtable_1.8-4           \n[109] systemfonts_1.1.0       munsell_0.5.1           Rcpp_1.0.13-1          \n[112] png_0.1-8               spatstat.univar_3.1-1   parallel_4.4.1         \n[115] ellipsis_0.3.2          blob_1.2.4              jpeg_0.1-10            \n[118] bitops_1.0-9            viridisLite_0.4.2       scales_1.3.0           \n[121] purrr_1.0.2             crayon_1.5.3            rlang_1.1.4            \n[124] cowplot_1.1.3           KEGGREST_1.46.0",
    "crumbs": [
      "Processing",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Quality Control</span>"
    ]
  },
  {
    "objectID": "03a-cell_annotation.html",
    "href": "03a-cell_annotation.html",
    "title": "\n6  Unsupervised clustering for cell annotation\n",
    "section": "",
    "text": "6.1 Clustering vs Annotation\nClustering is an unsupervised method of labelling cells. An algorithm identifies clusters of similar cells based on marker expression patterns, and the resulting clusters need to be manually identified based on biological domain knowledge. Cell annotation is a supervised method which requires a separate, reference dataset. The algorithm uses a reference dataset to assign a cell type label to each cell in the dataset. There are advantages and disadvantages to both. We will first demonstrate the use of our packages to perform both clustering and annotation, and then discuss how to choose between the two approaches.",
    "crumbs": [
      "Cell annotation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Unsupervised clustering for cell annotation</span>"
    ]
  },
  {
    "objectID": "03a-cell_annotation.html#clustering-with-fusesom",
    "href": "03a-cell_annotation.html#clustering-with-fusesom",
    "title": "\n6  Unsupervised clustering for cell annotation\n",
    "section": "\n6.2 Clustering with FuseSOM",
    "text": "6.2 Clustering with FuseSOM\nFuseSOM is an unsupervised clustering tool for highly multiplexed in situ imaging cytometry assays. It combines a Self Organising Map architecture and a MultiView integration of correlation-based metrics for robustness and high accuracy. It has been streamlined to accept multiple data structures including SingleCellExperiment objects, SpatialExperiment objects, and DataFrames.\n\n\n6.2.1 FuseSOM Matrix Input\nTo demonstrate the functionality of FuseSOM, we will use the Risom 2022 dataset, which profiles the spatial landscape of ductal carcinoma in situ (DCIS). We will be using the markers used in the original study to perform clustering.\n\n# load in the data\ndata(\"risom_dat\")\n\n# define the markers of interest\nrisomMarkers &lt;- c('CD45','SMA','CK7','CK5','VIM','CD31','PanKRT','ECAD',\n                   'Tryptase','MPO','CD20','CD3','CD8','CD4','CD14','CD68','FAP',\n                   'CD36','CD11c','HLADRDPDQ','P63','CD44')\n\n# we will be using the manual_gating_phenotype as the true cell type to gauge \n# performance\nnames(risom_dat)[names(risom_dat) == 'manual_gating_phenotype'] &lt;- 'CellType'\n\nNow that we have loaded the data and defined the markers of interest, we can run the FuseSOM algorithm using the runFuseSOM function. We specify the number of clusters to be 23 based on prior domain knowledge. The output contains the cluster labels as well as the Self Organizing Map model.\n\nrisomRes &lt;- runFuseSOM(data = risom_dat, markers = risomMarkers, \n                        numClusters = 23)\n\nLets look at the distribution of the clusters.\n\n# get the distribution of the clusters\nround(table(risomRes$clusters)/sum(table(risomRes$clusters)), 2)\n\n\n cluster_1 cluster_10 cluster_11 cluster_12 cluster_13 cluster_14 cluster_15 \n      0.32       0.04       0.01       0.02       0.06       0.03       0.02 \ncluster_16 cluster_17 cluster_18 cluster_19  cluster_2 cluster_20 cluster_21 \n      0.03       0.02       0.08       0.02       0.01       0.05       0.01 \ncluster_22 cluster_23  cluster_3  cluster_4  cluster_5  cluster_6  cluster_7 \n      0.05       0.07       0.00       0.01       0.04       0.06       0.02 \n cluster_8  cluster_9 \n      0.01       0.01 \n\n\nIt appears that 32% of cells have been assigned to cluster_1. Next, lets generate a heatmap of the marker expression for each cluster using the markerHeatmap function.\n\nrisomHeat &lt;- FuseSOM::markerHeatmap(data = risom_dat, markers = risomMarkers,\n                            clusters = risomRes$clusters, clusterMarkers = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCommon problems with clustering\n\n\n\nHow do I identify imperfect clustering?\n\nDo our cell-type specific markers clearly separate out by cluster? We expect to see discrete expression of our markers in specific cell types, e.g., CD4 being expressed in T cells exclusively.\nIf we instead see “smearing” of our markers across clusters, where several clusters express high levels of a cell type specific marker such as CD4, it is likely a normalisation issue.\n\n\n\n\n\n\n\n\n\nRemedying imperfect clustering\n\n\n\nThree common issues which cause imperfect clustering have been outlined below:\n\n\nImperfect segmentation: excessive lateral marker spill over can severely impact downstream clustering, as cell type specific markers leak into nearby cells. This should largely be diagnosed in the segmentation step and will need to be fixed by optimising the upstream segmentation algorithm.\n\nImperfect normalization: excessively variable intensities across images could cause issues in the normalization process. This can generally be diagnosed with density plots and box plots for specific markers across images and can be fixed by identifying the exact issue, e.g. extremely high values for a small subset of images, and choosing a normalization strategy to remove/reduce this effect.\n\nImperfect clustering: choosing a k that’s too low or too high could lead to imperfect clustering. This is usually diagnosed by clusters which either express too many markers very highly or express too few markers, and is usually remedied by choosing an ideal k based on an elbow plot described below.\n\n\n\n\n6.2.2 Using FuseSOM to estimate the number of clusters\nWhen the number of expected cell types or clusters is not known beforehand, the estimateNumCluster function can be used to estimate the number of clusters. Two methods have been developed to calculate the number of clusters:\n\nDiscriminant based method:\n\nA method developed in house based on discriminant based maximum clusterability projection pursuit\n\n\nDistance based methods which includes:\n\nThe Gap Statistic\nThe Jump Statistic\nThe Slope Statistic\nThe Within Cluster Dissimilarity Statistic\nThe Silhouette Statistic\n\n\n\nWe run estimateNumCluster and specify method = c(\"Discriminant\", \"Distance\") to use both approaches.\n\n# lets estimate the number of clusters using all the methods\n# original clustering has 23 clusters so we will set kseq from 2:25\n# we pass it the SOM model generated in the previous step\nrisomKest &lt;- estimateNumCluster(data = risomRes$model, kSeq = 2:25, \n                                  method = c(\"Discriminant\", \"Distance\"))\n\nWe can then use this result to determine the best number of clusters for this dataset based on the different metrics.\n\n# what is the best number of clusters determined by the discriminant method?\nrisomKest$Discriminant \n\n[1] 7\n\n\nAccording to the Discriminant method, the optimal number of clusters is 7.\nWe can use the optiPlot() function to generate an elbow plot with the optimal number of clusters for the distance based methods.\n\n\n# we can plot the results using the optiplot function\npSlope &lt;- optiPlot(risomKest, method = 'slope')\npSlope\n\n\n\n\n\n\npJump &lt;- optiPlot(risomKest, method = 'jump')\npJump\n\n\n\n\n\n\npWcd &lt;- optiPlot(risomKest, method = 'wcd')\npWcd\n\n\n\n\n\n\npGap &lt;- optiPlot(risomKest, method = 'gap')\npGap\n\n\n\n\n\n\npSil &lt;- optiPlot(risomKest, method = 'silhouette')\npSil\n\n\n\n\n\n\n\n\nFrom the plots, we see that the Jump statistic almost perfectly captures the correct number of clusters. The Gap statistic is a close second with 15 clusters. All the other methods significantly underestimate the number of clusters.\n\n\n\n\n\n\nEstimating the value of k\n\n\n\n\nHow do we choose our k? We’re generally looking for the k before the point of greatest inflection, or the point beyond which increasing k results in minimal improvement to clustering quality.\nIs there one best choice for k? There can be several options of k if there are several points of inflection. Choose the k which best reflects the number of clusters you expect to get from the tissue. For instance, if you are interested in broader cell populations, you might pick a lower value of k , and if you are interested in identifying subpopulations, you might pick a larger value for k .\n\n\n\n\n6.2.3 FuseSOM with SingleCellExperiment object as input\nThe FuseSOM algorithm is also equipped to take in a SingleCellExperiment object as input. The results of the pipeline will be written to either the metadata or the colData fields.\nFirst, we create a SingleCellExperiment object using the Risom 2022 data.\n\n# create an SCE object using Risom 2022 data\ncolDat &lt;- risom_dat[, setdiff(colnames(risom_dat), risomMarkers)]\nsce &lt;- SingleCellExperiment(assays = list(counts = t(risom_dat[, names(risom_dat) != \"CellType\"])),\n                                 colData = colDat)\n\nsce\n\nclass: SingleCellExperiment \ndim: 22 69672 \nmetadata(0):\nassays(1): counts\nrownames(22): CD45 SMA ... P63 CD44\nrowData names(0):\ncolnames: NULL\ncolData names(1): X\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\n\n\nNext, we pass it to the runFuseSOM function. Here, we can provide the assay in which the data is stored (counts) and specify the column to store the clusters in using clusterCol = \"clusters\". The Self Organizing Map that is generated will be stored in the metadata field.\n\nrisomRessce &lt;- runFuseSOM(sce, markers = risomMarkers, clusterCol = \"clusters\",\n                          assay = 'counts', numClusters = 23, verbose = FALSE)\n\ncolnames(colData(risomRessce))\n\n[1] \"X\"        \"clusters\"\n\nnames(metadata(risomRessce))\n\n[1] \"SOM\"\n\n\nNotice how the there is now a clusters column in the colData and a SOM field in the metadata.\nIf necessary, you can run runFuseSOM with a new cluster number and specify a new clusterCol. If clusterCol contains a new name, the new clusters will be stored in the new column. Otherwise, it will overwrite the the current clusters column. Running FuseSOM on the same object will overwrite the SOM field in the metadata.\nJust like before, we can plot a heatmap of the resulting clusters across all markers.\n\ndata &lt;- risom_dat[, risomMarkers] # get the original data used\nclusters &lt;- colData(risomRessce)$clusters # extract the clusters from the SCE object\n\n# generate the heatmap\nrisomHeatsce &lt;- markerHeatmap(data = risom_dat, markers = risomMarkers,\n                            clusters = clusters, clusterMarkers = TRUE)\n\n\n\n\n\n\n\nOr we can directly plot from the SCE using the scater package.\n\n# Visualise marker expression in each cluster.\nscater::plotGroupedHeatmap(\n  risomRessce,\n  features = risomMarkers,\n  group = \"clusters\",\n  exprs_values = \"counts\",\n  center = TRUE,\n  scale = TRUE,\n  zlim = c(-3, 3),\n  cluster_rows = FALSE,\n  block = \"clusters\"\n)\n\n\n\n\n\n\n\n\n6.2.4 Using FuseSOM to estimate the number of clusters for SingleCellExperiment objects\nJust like before, we will use estimateNumCluster on our Risom SingleCellExperiment object.\n\n# lets estimate the number of clusters using all the methods\n# original clustering has 23 clusters so we will set kseq from 2:25\nrisomRessce &lt;- estimateNumCluster(data = risomRessce, kSeq = 2:25, \n                                  method = c(\"Discriminant\", \"Distance\"))\n\nYou have provided a dataset of class: SingleCellExperiment\n\n\nNow Computing the Number of Clusters using Discriminant Analysis\n\n\nNow Computing The Number Of Clusters Using Distance Analysis\n\nnames(metadata(risomRessce))\n\n[1] \"SOM\"               \"clusterEstimation\"\n\n\nThe metadata now contains a clusterEstimation field which holds the results from the estimateNumCluster function.\nWe can assess the results of cluster estimation as below.\n\n# what is the best number of clusters determined by the discriminant method?\nmetadata(risomRessce)$clusterEstimation$Discriminant \n\n[1] 7\n\n\nAccording to the discrminant method, the optimal number of clusters is 7.\n\n# we can plot the results using the optiplot function\npSlope &lt;- optiPlot(risomRessce, method = 'slope')\npSlope\n\n\n\n\n\n\npJump &lt;- optiPlot(risomRessce, method = 'jump')\npJump\n\n\n\n\n\n\npWcd &lt;- optiPlot(risomRessce, method = 'wcd')\npWcd\n\n\n\n\n\n\npGap &lt;- optiPlot(risomRessce, method = 'gap')\npGap\n\n\n\n\n\n\npSil &lt;- optiPlot(risomRessce, method = 'silhouette')\npSil\n\n\n\n\n\n\n\nAgain, we see that the Jump statistic almost perfectly captures the correct number of clusters with 24 clusters. The Gap method is a close second with 15 clusters. All the other methods significantly underestimate the number of clusters.\nIn the next section, we will demonstrate how our packages can be used to perform supervised cell annotation, and then discuss how to choose between clustering and annotation approaches.",
    "crumbs": [
      "Cell annotation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Unsupervised clustering for cell annotation</span>"
    ]
  },
  {
    "objectID": "03a-cell_annotation.html#sessioninfo",
    "href": "03a-cell_annotation.html#sessioninfo",
    "title": "\n6  Unsupervised clustering for cell annotation\n",
    "section": "\n6.3 sessionInfo",
    "text": "6.3 sessionInfo\n\nsessionInfo()\n\nR version 4.4.1 (2024-06-14)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Sonoma 14.4.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Australia/Sydney\ntzcode source: internal\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] ggplot2_3.5.1               scuttle_1.16.0             \n [3] simpleSeg_1.8.0             MLmetrics_1.1.3            \n [5] STexampleData_1.14.0        SpatialExperiment_1.16.0   \n [7] SingleCellExperiment_1.28.1 SummarizedExperiment_1.36.0\n [9] Biobase_2.66.0              GenomicRanges_1.58.0       \n[11] GenomeInfoDb_1.42.0         IRanges_2.40.0             \n[13] S4Vectors_0.44.0            MatrixGenerics_1.18.0      \n[15] matrixStats_1.4.1           ExperimentHub_2.14.0       \n[17] AnnotationHub_3.14.0        BiocFileCache_2.14.0       \n[19] dbplyr_2.5.0                BiocGenerics_0.52.0        \n[21] FuseSOM_1.8.0              \n\nloaded via a namespace (and not attached):\n  [1] splines_4.4.1            later_1.4.1              bitops_1.0-9            \n  [4] ggplotify_0.1.2          filelock_1.0.3           tibble_3.2.1            \n  [7] svgPanZoom_0.3.4         polyclip_1.10-7          lifecycle_1.0.4         \n [10] rstatix_0.7.2            fastcluster_1.2.6        prabclus_2.3-4          \n [13] lattice_0.22-6           MASS_7.3-61              backports_1.5.0         \n [16] magrittr_2.0.3           rmarkdown_2.29           yaml_2.3.10             \n [19] httpuv_1.6.15            flexmix_2.3-19           sp_2.1-4                \n [22] DBI_1.2.3                RColorBrewer_1.1-3       abind_1.4-8             \n [25] zlibbioc_1.52.0          purrr_1.0.2              RCurl_1.98-1.16         \n [28] nnet_7.3-19              yulab.utils_0.1.8        rappdirs_0.3.3          \n [31] GenomeInfoDbData_1.2.13  ggrepel_0.9.6            irlba_2.3.5.1           \n [34] spatstat.utils_3.1-1     terra_1.7-78             pheatmap_1.0.12         \n [37] vegan_2.6-8              svglite_2.1.3            permute_0.9-7           \n [40] codetools_0.2-20         DelayedArray_0.32.0      tidyselect_1.2.1        \n [43] raster_3.6-30            farver_2.1.2             UCSC.utils_1.2.0        \n [46] ScaledMatrix_1.14.0      viridis_0.6.5            jsonlite_1.8.9          \n [49] BiocNeighbors_2.0.0      Formula_1.2-5            scater_1.34.0           \n [52] systemfonts_1.1.0        tools_4.4.1              Rcpp_1.0.13-1           \n [55] glue_1.8.0               mnormt_2.1.1             gridExtra_2.3           \n [58] SparseArray_1.6.0        xfun_0.49                mgcv_1.9-1              \n [61] EBImage_4.48.0           dplyr_1.1.4              HDF5Array_1.34.0        \n [64] withr_3.0.2              shinydashboard_0.7.2     BiocManager_1.30.25     \n [67] fastmap_1.2.0            rhdf5filters_1.18.0      fansi_1.0.6             \n [70] rsvd_1.0.5               digest_0.6.37            R6_2.5.1                \n [73] mime_0.12                gridGraphics_0.5-1       DataVisualizations_1.3.2\n [76] colorspace_2.1-1         spatstat.data_3.1-4      jpeg_0.1-10             \n [79] RSQLite_2.3.8            diptest_0.77-1           utf8_1.2.4              \n [82] tidyr_1.3.1              generics_0.1.3           robustbase_0.99-4-1     \n [85] class_7.3-22             httr_1.4.7               htmlwidgets_1.6.4       \n [88] S4Arrays_1.6.0           pkgconfig_2.0.3          gtable_0.3.6            \n [91] modeltools_0.2-23        blob_1.2.4               XVector_0.46.0          \n [94] htmltools_0.5.8.1        carData_3.0-5            fftwtools_0.9-11        \n [97] scales_1.3.0             png_0.1-8                spatstat.univar_3.1-1   \n[100] knitr_1.49               rstudioapi_0.17.1        rjson_0.2.23            \n[103] nlme_3.1-166             curl_6.0.1               proxy_0.4-27            \n[106] cachem_1.1.0             rhdf5_2.50.0             stringr_1.5.1           \n[109] BiocVersion_3.20.0       parallel_4.4.1           vipor_0.4.7             \n[112] AnnotationDbi_1.68.0     pillar_1.9.0             grid_4.4.1              \n[115] vctrs_0.6.5              promises_1.3.2           ggpubr_0.6.0            \n[118] BiocSingular_1.22.0      car_3.1-3                beachmat_2.22.0         \n[121] xtable_1.8-4             cluster_2.1.6            princurve_2.1.6         \n[124] beeswarm_0.4.0           evaluate_1.0.1           magick_2.8.5            \n[127] cli_3.6.3                locfit_1.5-9.10          compiler_4.4.1          \n[130] rlang_1.1.4              crayon_1.5.3             analogue_0.17-7         \n[133] ggsignif_0.6.4           labeling_0.4.3           mclust_6.1.1            \n[136] fs_1.6.5                 ggbeeswarm_0.7.2         stringi_1.8.4           \n[139] psych_2.4.6.26           deldir_2.0-4             viridisLite_0.4.2       \n[142] BiocParallel_1.40.0      nnls_1.6                 FCPS_1.3.4              \n[145] cytomapper_1.18.0        munsell_0.5.1            Biostrings_2.74.0       \n[148] tiff_0.1-12              coop_0.6-3               profileModel_0.6.1      \n[151] spatstat.geom_3.3-4      Matrix_1.7-1             bit64_4.5.2             \n[154] Rhdf5lib_1.28.0          fpc_2.2-13               KEGGREST_1.46.0         \n[157] shiny_1.9.1              brglm_0.7.2              kernlab_0.9-33          \n[160] broom_1.0.7              memoise_2.0.1            DEoptimR_1.1-3-1        \n[163] bit_4.5.0",
    "crumbs": [
      "Cell annotation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Unsupervised clustering for cell annotation</span>"
    ]
  },
  {
    "objectID": "03b-cell_annotation.html",
    "href": "03b-cell_annotation.html",
    "title": "\n7  Supervised cell annotation with a reference\n",
    "section": "",
    "text": "8 scClassify: Cell annotation\nscClassify is a supervised multiscale classification framework for single-cell data based on ensemble learning and cell type hierarchies. scClassify first constructs a cell type tree using the reference dataset, and then builds an ensemble weighted kNN classifier at each node. Users can select any combination of six correlation/similarity metrics and five marker selection methods to build the kNN model. This results in up to 30 base classifiers that can be constructed for each node of the cell type tree.\nTo demonstrate the use of scClassify, we will use the Stickels 2021 dataset, which examines mouse brain tissue from the hippocampus and surrounding regions. It is available through the STexampleData package.\nstickelsSPE = STexampleData::SlideSeqV2_mouseHPC()\nstickelsSPE\n\nclass: SpatialExperiment \ndim: 23264 53208 \nmetadata(0):\nassays(1): counts\nrownames(23264): 0610005C13Rik 0610007P14Rik ... n-R5s40 n-R5s95\nrowData names(1): gene_name\ncolnames(53208): AACGTCATAATCGT TACTTTAGCGCAGT ... GACTTTTCTTAAAG\n  GTCAATAAAGGGCG\ncolData names(3): barcode_id sample_id celltype\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\nspatialCoords names(2) : xcoord ycoord\nimgData names(0):\nThe dataset contains 17 unique cell types.\nstickelsSPE$celltype |&gt; unique()\n\n [1] NA                      \"CA3\"                   \"CA1\"                  \n [4] \"Choroid\"               \"Oligodendrocyte\"       \"Denate\"               \n [7] \"Entorihinal\"           \"Ependymal\"             \"Interneuron\"          \n[10] \"Astrocyte\"             \"Neuron.Slc17a6\"        \"Neurogenesis\"         \n[13] \"Mural\"                 \"Endothelial_Stalk\"     \"Polydendrocyte\"       \n[16] \"Endothelial_Tip\"       \"Microglia_Macrophages\" \"Cajal_Retzius\"\nAs scClassify requires log-normalised expression data, we will use normalizeCounts from the scuttle package to transform and normalise our expression data.\n# log normalisation\nnorm_assay = normalizeCounts(stickelsSPE, transform = \"log\", \n                             BPPARAM = BPPARAM)\n\n# store normalised expression data in the \"norm\" slot\nassay(stickelsSPE, \"norm\", withDimnames = FALSE) = norm_assay\nWe will first split the dataset into an 80% training or reference dataset and a 20% testing or query dataset.\nset.seed(51773)\n\n# split into 80% reference and 20% query\nref_idx = sample(seq_len(ncol(stickelsSPE)), size = 0.7 * ncol(stickelsSPE))\nref_spe = stickelsSPE[, ref_idx]\nquery_spe = stickelsSPE[, -ref_idx]\n\n# access expression data as matrix\nref_mat = assay(ref_spe, \"norm\") |&gt; as.matrix()\n\nWarning in asMethod(object): sparse-&gt;dense coercion: allocating vector of size\n6.5 GiB\n\nquery_mat = assay(query_spe, \"norm\") |&gt; as.matrix()\n\nWarning in asMethod(object): sparse-&gt;dense coercion: allocating vector of size\n2.8 GiB",
    "crumbs": [
      "Cell annotation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Supervised cell annotation with a reference</span>"
    ]
  },
  {
    "objectID": "03b-cell_annotation.html#using-scclassify",
    "href": "03b-cell_annotation.html#using-scclassify",
    "title": "\n7  Supervised cell annotation with a reference\n",
    "section": "\n8.1 Using scClassify",
    "text": "8.1 Using scClassify\nscClassify is the main classification function within scClassify. It requires a reference expression matrix (exprsMat_train) and the corresponding vector of cell type labels as input (cellTypes_train). We then specify our query matrix (exprsMat_test) and the corresponding cell type labels (cellTypes_test) in the form of lists. Below, we have also specified the following customisations for building the model -\n\n\ntree = HOPACH: use the HOPACH algorithm to build a cell type hierarchy.\n\nalgorithm = WKNN: use the weighted KNN model\n\nselectFeatures = c(\"limma\"): identify differentially expressed (DE) genes using limma, which will be used as features to build the weighted KNN model. Other options to select features include differentially variable (DV) genes, differentially distributed (DD), bimodally distributed (BI) and differentially expressed proportions.\n\nc(\"pearson\", \"spearman\", \"cosine\"): use Pearson and Spearman correlation to measure similarity between cells. Other options include Kendall’s correlation, cosine distance, Jaccard distance, Manhattan distance, and weighted rank correlation.\n\n\nscClassify_res = scClassify(exprsMat_train = ref_mat,\n                            cellTypes_train = ref_spe$celltype,\n                            exprsMat_test = list(stickels = query_mat),\n                            cellTypes_test = list(stickels = query_spe$celltype),\n                            tree = \"HOPACH\",\n                            algorithm = \"WKNN\",\n                            selectFeatures = c(\"limma\"),\n                            similarity = c(\"pearson\", \"spearman\"),\n                            returnList = FALSE,\n                            parallel = TRUE,\n                            BPPARAM = BPPARAM,\n                            verbose = FALSE)\nTime for this code chunk to run with 5.5 cores: 0 seconds\n\nThe output is a list containing all model building and testing information. The testRes slot contains the results of testing the model on the query dataset, and the trainRes slot contains the model built from the reference dataset.\n\nscClassify_res$trainRes\n\n\nThe predictions for each cell can be accessed through the ensembleRes slot in the testing results.\n\npred_mat = scClassify_res$testRes$human$ensembleRes |&gt; as.data.frame()\nhead(pred_mat)",
    "crumbs": [
      "Cell annotation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Supervised cell annotation with a reference</span>"
    ]
  },
  {
    "objectID": "03b-cell_annotation.html#evaluating-performance",
    "href": "03b-cell_annotation.html#evaluating-performance",
    "title": "\n7  Supervised cell annotation with a reference\n",
    "section": "\n8.2 Evaluating performance",
    "text": "8.2 Evaluating performance\n\n# convert predictions to factor\npred_mat$cellTypes = as.factor(pred_mat$cellTypes)\n\n# ensure both ground truth and predictions have the same levels\ncombined_levels = union(levels(pred_mat$cellTypes), levels(query_spe$celltype))\nlevels(query_spe$celltype) = combined_levels\nlevels(pred_mat$cellTypes) = combined_levels\n\nconf_matrix = confusionMatrix(data = pred_mat$cellTypes,\n                reference = query_spe$celltypes)\n\nconf_matrix$overall\n\n\nrecall = MLmetrics::Recall(y_pred = pred_mat$cellTypes,\n                                 y_true = query_spe$celltype)\nprecision = MLmetrics::Precision(y_pred = pred_mat$cellTypes,\n                                   y_true = query_spe$celltype)\nf1_score = MLmetrics::F1_Score(y_pred = pred_mat$cellTypes,\n                                 y_true = query_spe$celltype)\n\ncat(\"Recall:\", recall, \"\\n\")\ncat(\"Precision:\", precision, \"\\n\")\ncat(\"F1-Score:\", f1_score, \"\\n\")\n\n\nresults = data.frame(trueLabel = query_spe$celltype,\n                     predictedLabel = pred_mat$cellTypes)\n\nresults = dplyr::mutate(results, classification = dplyr::case_when(\n  predictedLabel != trueLabel ~ \"incorrectly classified\",\n  predictedLabel == trueLabel ~ \"correctly classified\",\n  predictedLabel == \"unassigned\" ~ \"incorrectly unassigned\"\n))\n\nggplot(results, aes(x = trueLabel, fill = classification)) + \n  geom_bar(position = \"fill\")",
    "crumbs": [
      "Cell annotation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Supervised cell annotation with a reference</span>"
    ]
  },
  {
    "objectID": "03b-cell_annotation.html#sessioninfo",
    "href": "03b-cell_annotation.html#sessioninfo",
    "title": "\n7  Supervised cell annotation with a reference\n",
    "section": "\n8.3 sessionInfo",
    "text": "8.3 sessionInfo\n\nsessionInfo()\n\nR version 4.4.1 (2024-06-14)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Sonoma 14.4.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Australia/Sydney\ntzcode source: internal\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] caret_6.0-94                lattice_0.22-6             \n [3] scater_1.34.0               ggplot2_3.5.1              \n [5] scuttle_1.16.0              MLmetrics_1.1.3            \n [7] STexampleData_1.14.0        SpatialExperiment_1.16.0   \n [9] SingleCellExperiment_1.28.1 SummarizedExperiment_1.36.0\n[11] Biobase_2.66.0              GenomicRanges_1.58.0       \n[13] GenomeInfoDb_1.42.0         IRanges_2.40.0             \n[15] S4Vectors_0.44.0            MatrixGenerics_1.18.0      \n[17] matrixStats_1.4.1           ExperimentHub_2.14.0       \n[19] AnnotationHub_3.14.0        BiocFileCache_2.14.0       \n[21] dbplyr_2.5.0                BiocGenerics_0.52.0        \n[23] scClassify_1.18.0          \n\nloaded via a namespace (and not attached):\n  [1] segmented_2.1-3           bitops_1.0-9             \n  [3] EBImage_4.48.0            lubridate_1.9.3          \n  [5] httr_1.4.7                hopach_2.66.0            \n  [7] RColorBrewer_1.1-3        tools_4.4.1              \n  [9] utf8_1.2.4                R6_2.5.1                 \n [11] HDF5Array_1.34.0          lazyeval_0.2.2           \n [13] mgcv_1.9-1                rhdf5filters_1.18.0      \n [15] withr_3.0.2               sp_2.1-4                 \n [17] gridExtra_2.3             cli_3.6.3                \n [19] nnls_1.6                  spatstat.data_3.1-4      \n [21] proxy_0.4-27              systemfonts_1.1.0        \n [23] svglite_2.1.3             parallelly_1.39.0        \n [25] limma_3.62.1              rstudioapi_0.17.1        \n [27] RSQLite_2.3.8             simpleSeg_1.8.0          \n [29] generics_0.1.3            dplyr_1.1.4              \n [31] Matrix_1.7-1              ggbeeswarm_0.7.2         \n [33] fansi_1.0.6               abind_1.4-8              \n [35] terra_1.7-78              lifecycle_1.0.4          \n [37] yaml_2.3.10               rhdf5_2.50.0             \n [39] recipes_1.1.0             SparseArray_1.6.0        \n [41] grid_4.4.1                blob_1.2.4               \n [43] promises_1.3.2            crayon_1.5.3             \n [45] shinydashboard_0.7.2      beachmat_2.22.0          \n [47] KEGGREST_1.46.0           magick_2.8.5             \n [49] cytomapper_1.18.0         pillar_1.9.0             \n [51] knitr_1.49                rjson_0.2.23             \n [53] future.apply_1.11.3       codetools_0.2-20         \n [55] glue_1.8.0                spatstat.univar_3.1-1    \n [57] data.table_1.16.2         vctrs_0.6.5              \n [59] png_0.1-8                 gtable_0.3.6             \n [61] kernlab_0.9-33            cachem_1.1.0             \n [63] gower_1.0.1               xfun_0.49                \n [65] S4Arrays_1.6.0            mime_0.12                \n [67] prodlim_2024.06.25        tidygraph_1.3.1          \n [69] survival_3.7-0            timeDate_4041.110        \n [71] iterators_1.0.14          hardhat_1.4.0            \n [73] lava_1.8.0                statmod_1.5.0            \n [75] ipred_0.9-15              nlme_3.1-166             \n [77] bit64_4.5.2               filelock_1.0.3           \n [79] irlba_2.3.5.1             svgPanZoom_0.3.4         \n [81] vipor_0.4.7               rpart_4.1.23             \n [83] colorspace_2.1-1          DBI_1.2.3                \n [85] raster_3.6-30             nnet_7.3-19              \n [87] tidyselect_1.2.1          proxyC_0.4.1             \n [89] bit_4.5.0                 compiler_4.4.1           \n [91] curl_6.0.1                BiocNeighbors_2.0.0      \n [93] DelayedArray_0.32.0       plotly_4.10.4            \n [95] scales_1.3.0              rappdirs_0.3.3           \n [97] tiff_0.1-12               stringr_1.5.1            \n [99] digest_0.6.37             fftwtools_0.9-11         \n[101] spatstat.utils_3.1-1      mixtools_2.0.0           \n[103] rmarkdown_2.29            XVector_0.46.0           \n[105] htmltools_0.5.8.1         pkgconfig_2.0.3          \n[107] jpeg_0.1-10               Cepo_1.12.0              \n[109] sparseMatrixStats_1.18.0  fastmap_1.2.0            \n[111] rlang_1.1.4               htmlwidgets_1.6.4        \n[113] UCSC.utils_1.2.0          shiny_1.9.1              \n[115] DelayedMatrixStats_1.28.0 farver_2.1.2             \n[117] jsonlite_1.8.9            BiocParallel_1.40.0      \n[119] ModelMetrics_1.2.2.2      BiocSingular_1.22.0      \n[121] RCurl_1.98-1.16           magrittr_2.0.3           \n[123] GenomeInfoDbData_1.2.13   patchwork_1.3.0          \n[125] Rhdf5lib_1.28.0           munsell_0.5.1            \n[127] Rcpp_1.0.13-1             viridis_0.6.5            \n[129] stringi_1.8.4             pROC_1.18.5              \n[131] ggraph_2.2.1              zlibbioc_1.52.0          \n[133] MASS_7.3-61               plyr_1.8.9               \n[135] parallel_4.4.1            listenv_0.9.1            \n[137] ggrepel_0.9.6             deldir_2.0-4             \n[139] Biostrings_2.74.0         graphlayouts_1.2.1       \n[141] splines_4.4.1             locfit_1.5-9.10          \n[143] igraph_2.1.1              spatstat.geom_3.3-4      \n[145] reshape2_1.4.4            ScaledMatrix_1.14.0      \n[147] BiocVersion_3.20.0        evaluate_1.0.1           \n[149] BiocManager_1.30.25       foreach_1.5.2            \n[151] tweenr_2.0.3              httpuv_1.6.15            \n[153] tidyr_1.3.1               purrr_1.0.2              \n[155] polyclip_1.10-7           future_1.34.0            \n[157] ggforce_0.4.2             rsvd_1.0.5               \n[159] xtable_1.8-4              later_1.4.1              \n[161] viridisLite_0.4.2         class_7.3-22             \n[163] minpack.lm_1.2-4          tibble_3.2.1             \n[165] memoise_2.0.1             beeswarm_0.4.0           \n[167] AnnotationDbi_1.68.0      cluster_2.1.6            \n[169] timechange_0.3.0          globals_0.16.3",
    "crumbs": [
      "Cell annotation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Supervised cell annotation with a reference</span>"
    ]
  },
  {
    "objectID": "04a-cell_localisation.html",
    "href": "04a-cell_localisation.html",
    "title": "\n8  Cell localisation between pairs of cell types\n",
    "section": "",
    "text": "8.1 Quantifying cell type co-localisation with spicyR\nspicyR provides a metric to quantify the degree of localisation or dispersion between two cell types. It then tests for changes in this co-localisation metric across different disease states or groups.\nHere, we will use the Keren 2018 dataset to demonstrate the use of spicyR. The data is stored as a SpatialExperiment object within the SpatialDatasets package and contains single-cell spatial data from 41 images for three types of breast cancer tumours (cold, compartmentalised, and mixed).\nkerenSPE &lt;- SpatialDatasets::spe_Keren_2018()\n\n# remove any missing data in our outcome columns\nkerenSPE = kerenSPE[, complete.cases(colData(kerenSPE)[, c(\"Censored\", \"Survival_days_capped*\",\n                                                           \"tumour_type\")])]\nEleven immune cell types were identified in this dataset by the original authors: (double negative CD3 T cells, CD4 T cells, B cells, monocytes, macrophages, CD8 T cells, neutrophils, natural killer cells, dendritic cells, regulatory T cells), 2 structural cell types (endothelial, mesenchymal), 2 tumour cell types (keratin+ tumour, tumour) and one unidentified category.",
    "crumbs": [
      "Cell localisation",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Cell localisation between pairs of cell types</span>"
    ]
  },
  {
    "objectID": "04a-cell_localisation.html#quantifying-cell-type-co-localisation-with-spicyr",
    "href": "04a-cell_localisation.html#quantifying-cell-type-co-localisation-with-spicyr",
    "title": "\n8  Cell localisation between pairs of cell types\n",
    "section": "",
    "text": "8.1.1 Linear modelling\nWe use the L-function to measure the degree of co-localisation between two cell types. The L-function is a variance-stabilised version of the K-function given by the equation\n\\[\n\\widehat{L_{ij}} (r) = \\sqrt{\\frac{\\widehat{K_{ij}}(r)}{\\pi}}\n\\]\nwith \\(\\widehat{K_{ij}}\\) defined as\n\\[\n\\widehat{K_{ij}} (r) = \\frac{|W|}{n_i n_j} \\sum_{n_i} \\sum_{n_j} 1 \\{d_{ij} \\leq r \\} e_{ij} (r)\n\\]\nwhere \\(\\widehat{K_{ij}}\\) summarises the degree of co-localisation of cell type \\(j\\) with cell type \\(i\\), \\(n_i\\) and \\(n_j\\) are the number of cells of type \\(i\\) and \\(j\\), \\(|W|\\) is the image area, \\(d_{ij}\\) is the distance between two cells, \\(r\\) is the chosen radius, and \\(e_{ij} (r)\\) is an edge correcting factor.\nTo assess whether the observed co-localisation deviates from what would be expected under random spatial distribution, the experimental L-function is compared to a theoretical L-function derived from a Poisson point process. The Poisson function assumes that cells are distributed completely at random within the image, meaning there are no underlying spatial patterns such as attraction or repulsion between cell types. This provides a baselineexpectation against which the observed clustering or segregation can be evaluated.\nSpecifically, the mean difference between the experimental function and the theoretical function is used as a measure for the level of localisation, defined as\n\\[\nu = \\sum_{r' = r_{\\text{min}}}^{r_{\\text{max}}} \\widehat L_{ij, \\text{Experimental}} (r') - \\widehat L_{ij, \\text{Poisson}} (r')\n\\]\nwhere \\(u\\) is the sum is taken over a discrete range of \\(r\\) between \\(r_{\\text{min}}\\) and \\(r_{\\text{max}}\\). Differences of the statistic \\(u\\) between two conditions is modelled using a weighted linear model.\n\n8.1.2 Test for changes in localisation for a specific pair of cells\nFirstly, we can test whether one cell type tends to be more localised with another cell type in one condition compared to the other. This can be done using the spicy function, where we specify the condition parameter.\nIn this example, we want to see whether or not neutrophils (to) tend to be found around CD8 T cells (from) in compartmentalised tumours compared to cold tumours. Given that there are 3 conditions, we can specify the desired conditions by setting the order of our condition factor. spicy will choose the first level of the factor as the base condition and the second level as the comparison condition. spicy will also naturally coerce the condition column into a factor if it is not already a factor. The radius over which to calculate the L-function can be specified using the Rs argument. By default, spicy calculates the L-function over a range of radii.\nThe column containing cell type annotations and image IDs can be specified using the cellType and imageID arguments respectively. By default, spicy uses the columns named cellType and imageID.\nWe obtain a spicy object which details the results of the modelling performed. The topPairs function can be used to obtain the associated coefficients and p-value.\n\nspicyTestPair &lt;- spicy(\n  kerenSPE,\n  condition = \"tumour_type\",\n  from = \"CD8_T_cell\",\n  to = \"Neutrophils\",\n  BPPARAM = BPPARAM\n)\n\ntopPairs(spicyTestPair)\n\n                        intercept coefficient      p.value   adj.pvalue\nCD8_T_cell__Neutrophils  -91.5703     94.5402 0.0006792206 0.0006792206\n                              from          to\nCD8_T_cell__Neutrophils CD8_T_cell Neutrophils\n\nTime for this code chunk to run with 5.5 cores: 2.29 seconds\n\nAs the coefficient in spicyTestPair is positive, we find that neutrophils are significantly more likely to be found near CD8 T cells in the compartmentalised tumours group compared to the cold tumour group.\n\n\n\n\n\n\nChoosing parameters for spicy\n\n\n\nHow do we select an optimal value for Rs?\n\nThe choice of Rs will depend on the degree of co-localistion we expect to see and the biological context. Choosing a small value of Rs is optimal for examining local spatial relationships, and larger values of Rs will reveal global spatial relationships.\nWhen the degree of localistion is unknown, it is best to choose a range of radii to define the co-localisation statistic to capture both local and global relationships.\n\n\n\n\n8.1.3 Test for changes in localisation for all pairwise cell combinations\nWe can perform what we did above for all pairwise combinations of cell types by excluding the from and to parameters in spicy. Additional covariates can be added using the covariates argument.\n\nspicyTest &lt;- spicy(\n  kerenSPE,\n  condition = \"tumour_type\",\n  BPPARAM = BPPARAM\n)\n\ntopPairs(spicyTest)\n\n                         intercept coefficient      p.value   adj.pvalue\nMacrophages__dn_T_CD3     64.26984   -57.90199 2.240072e-08 6.160198e-06\ndn_T_CD3__Macrophages     62.44605   -55.84542 5.987026e-08 8.232161e-06\nMacrophages__CD8_T_cell  105.28040   -98.30184 2.151824e-05 1.525685e-03\nCD8_T_cell__Macrophages  103.94483   -96.91337 2.219178e-05 1.525685e-03\nMacrophages__DC_or_Mono   74.32427   -60.87678 3.696109e-05 2.032860e-03\nDC_or_Mono__Macrophages   72.47461   -59.14177 5.498388e-05 2.520095e-03\nNeutrophils__dn_T_CD3    -60.45705    66.94703 1.268374e-04 4.534466e-03\ndn_T_CD3__Neutrophils    -60.45215    67.47179 1.319117e-04 4.534466e-03\ndn_T_CD3__dn_T_CD3       -60.82745    97.65301 2.359087e-04 7.208323e-03\nMacrophages__Macrophages  70.42380   -40.78211 9.662288e-04 1.791030e-02\n                                from          to\nMacrophages__dn_T_CD3    Macrophages    dn_T_CD3\ndn_T_CD3__Macrophages       dn_T_CD3 Macrophages\nMacrophages__CD8_T_cell  Macrophages  CD8_T_cell\nCD8_T_cell__Macrophages   CD8_T_cell Macrophages\nMacrophages__DC_or_Mono  Macrophages  DC_or_Mono\nDC_or_Mono__Macrophages   DC_or_Mono Macrophages\nNeutrophils__dn_T_CD3    Neutrophils    dn_T_CD3\ndn_T_CD3__Neutrophils       dn_T_CD3 Neutrophils\ndn_T_CD3__dn_T_CD3          dn_T_CD3    dn_T_CD3\nMacrophages__Macrophages Macrophages Macrophages\n\nTime for this code chunk to run with 5.5 cores: 10.56 seconds\n\nAgain, we obtain a spicy object which outlines the result of the linear models performed for each pairwise combination of cell types.\nWe can also examine the L-function metrics of individual images by using the convenient bind function on our spicyTest results object.\n\nbind(spicyTest)[1:5, 1:5]\n\n  imageID         condition Keratin_Tumour__Keratin_Tumour\n1       1             mixed                      -2.300602\n2       2             mixed                      -1.989699\n3       3 compartmentalised                      11.373530\n4       4 compartmentalised                      33.931133\n5       5 compartmentalised                      17.922818\n  dn_T_CD3__Keratin_Tumour B_cell__Keratin_Tumour\n1                -5.298543             -20.827279\n2               -16.020022               3.025815\n3               -21.857447             -24.962913\n4               -36.438476             -40.470221\n5               -20.816783             -38.138076\n\n\nThe results can be represented as a bubble plot using the signifPlot function.\n\nsignifPlot(\n  spicyTest,\n  breaks = c(-3, 3, 1),\n  marksToPlot = c(\"Macrophages\", \"DC_or_Mono\", \"dn_T_CD3\", \"Neutrophils\",\n                  \"CD8_T_cell\", \"Keratin_Tumour\"))\n\n\n\n\n\n\n\nHere, we can observe that the most significant relationships occur between macrophages and double negative CD3 T cells, suggesting that the two cell types are far more dispersed in compartmentalised tumours compared to cold tumours. In general, it appears that our immune cell types become more dispersed in compartmentalised tumours compared to cold tumours.\nTo examine a specific cell type-cell type relationship in more detail, we can use spicyBoxplot and specify either from = \"Macrophages\" and to = \"dn_T_CD3\" or rank = 1.\n\nspicyBoxPlot(results = spicyTest, \n             # from = \"Macrophages\",\n             # to = \"dn_T_CD3\"\n             rank = 1)\n\n\n\n\n\n\n\nThe boxplot confirms what we originally found in the bubble plot. Macrophages and double negative CD3 T cells are significantly more dispersed (lower L-function score) in compartmentalised tumours compared to cold tumours.\n\n8.1.4 Linear modelling for custom metrics\nspicyR can also be applied to custom distance or abundance metrics. A kNN interactions graph can be generated with the function buildSpatialGraph from the imcRtools package. This generates a colPairs object inside of the SpatialExperiment object.\nspicyR provides the function convPairs for converting a colPairs object into an abundance matrix by calculating the average number of nearby cells types for every cell type for a given k. For example, if there exists on average 5 neutrophils for every macrophage in image 1, the column Neutrophil__Macrophage would have a value of 5 for image 1.\n\nkerenSPE &lt;- imcRtools::buildSpatialGraph(kerenSPE, \n                                         img_id = \"imageID\", \n                                         type = \"knn\", k = 20,\n                                        coords = c(\"x\", \"y\"))\n\npairAbundances &lt;- convPairs(kerenSPE,\n                  colPair = \"knn_interaction_graph\")\n\nhead(pairAbundances[\"B_cell__B_cell\"])\n\n   B_cell__B_cell\n1      12.7349608\n10      0.2777778\n11      0.0000000\n12      1.3333333\n13      1.2200957\n14      0.0000000\n\n\nThe custom distance or abundance metrics can then be included in the analysis with the alternateResult parameter.\n\nspicyTestColPairs &lt;- spicy(\n  kerenSPE,\n  condition = \"tumour_type\",\n  alternateResult = pairAbundances,\n  weights = FALSE,\n  BPPARAM = BPPARAM\n)\n\ntopPairs(spicyTestColPairs)\n\n                             intercept coefficient    p.value adj.pvalue\nUnidentified__CD8_T_cell   0.151346975  0.60159494 0.01687494  0.7034781\nKeratin_Tumour__CD8_T_cell 0.117283437 -0.09850513 0.01870063  0.7034781\nNK__CD8_T_cell             0.113835243  0.53296190 0.02304383  0.7034781\nB_cell__Tumour             0.016326531  0.23053781 0.02626946  0.7034781\nOther_Immune__DC_or_Mono   0.144559342 -0.12839560 0.02895838  0.7034781\ndn_T_CD3__Neutrophils      0.029731407  0.29756814 0.03260677  0.7034781\nTregs__CD4_T_cell          0.195913616  0.51002005 0.03536184  0.7034781\ndn_T_CD3__NK               0.005405405  0.18354680 0.04525721  0.7034781\nOther_Immune__NK           0.013333333  0.22116787 0.04660829  0.7034781\nCD4_T_cell__DC             2.600122100 -1.36259931 0.04845418  0.7034781\n                                     from          to\nUnidentified__CD8_T_cell     Unidentified  CD8_T_cell\nKeratin_Tumour__CD8_T_cell Keratin_Tumour  CD8_T_cell\nNK__CD8_T_cell                         NK  CD8_T_cell\nB_cell__Tumour                     B_cell      Tumour\nOther_Immune__DC_or_Mono     Other_Immune  DC_or_Mono\ndn_T_CD3__Neutrophils            dn_T_CD3 Neutrophils\nTregs__CD4_T_cell                   Tregs  CD4_T_cell\ndn_T_CD3__NK                     dn_T_CD3          NK\nOther_Immune__NK             Other_Immune          NK\nCD4_T_cell__DC                 CD4_T_cell          DC\n\n\n\nsignifPlot(\n  spicyTestColPairs,\n  marksToPlot = c(\"Macrophages\", \"dn_T_CD3\", \"CD4_T_cell\", \n                  \"B_cell\", \"DC_or_Mono\", \"Neutrophils\", \"CD8_T_cell\")\n)\n\n\n\n\n\n\n\nUsing abudance metric yields no cell type pairs which are significantly dispersed or localised in compartmentalised tumours compared to cold tumours.\n\n8.1.5 Mixed effects modelling\nspicyR supports mixed effects modelling when multiple images are obtained for each subject. In this case, subject is treated as a random effect and condition is treated as a fixed effect. To perform mixed effects modelling, we can specify the subject parameter in the spicy function.\nTo demonstrate spicyR’s functionality with mixed effects models, we will use the Damond 2019 dataset.\n\n# load in data\ndata(\"diabetesData\")\n\n# mixed effects modelling with spicy\nspicyMixedTest &lt;- spicy(\n  diabetesData,\n  condition = \"stage\",\n  subject = \"case\",\n  BPPARAM = BPPARAM\n)\nTime for this code chunk to run with 5.5 cores: 113.56 seconds\n\nAs before, we generate a spicy results object, and we can use topPairs to identify the most significant cell type pairs.\n\ntopPairs(spicyMixedTest)\n\n                         intercept coefficient      p.value adj.pvalue\nbeta__delta           6.081500e+01  -15.433244 0.0006616410 0.09171134\ndelta__beta           6.090722e+01  -15.276364 0.0007164949 0.09171134\nB__Th                -4.680923e-15   10.480124 0.0127535339 0.42316692\ndelta__delta          7.021912e+01  -16.358092 0.0155005315 0.42316692\nTh__B                 1.281787e-15   10.003451 0.0173028442 0.42316692\nB__unknown            2.309876e-15    4.584274 0.0182158635 0.42316692\notherimmune__naiveTc -3.179087e+00   11.944638 0.0200230308 0.42316692\nunknown__macrophage   4.339584e+00   -5.274671 0.0222620877 0.42316692\nunknown__B           -1.508529e-15    4.680750 0.0244004305 0.42316692\nmacrophage__unknown   4.305429e+00   -4.886438 0.0249693456 0.42316692\n                            from         to\nbeta__delta                 beta      delta\ndelta__beta                delta       beta\nB__Th                          B         Th\ndelta__delta               delta      delta\nTh__B                         Th          B\nB__unknown                     B    unknown\notherimmune__naiveTc otherimmune    naiveTc\nunknown__macrophage      unknown macrophage\nunknown__B               unknown          B\nmacrophage__unknown   macrophage    unknown\n\n\nWe can use signifPlot to visualise the results.\n\nsignifPlot(spicyMixedTest,\n           marksToPlot = c(\"beta\", \"delta\", \"B\", \"Th\", \"otherimmune\", \n                           \"naiveTc\", \"macrophage\", \"Tc\", \"stromal\"))\n\n\n\n\n\n\n\nThe graph shows a significant decrease in co-localisation between delta and beta cells in the pancreas within the onset diabetes group compared to the non-diabetes group. Additionally, there is a significant increase in co-localisation among certain immune cell groups, including B cells and Th cells, as well as naive Tc cells and other immune cells. These findings align with the results reported in the original study.\n\n8.1.6 Performing survival analysis\nspicy can also be used to perform survival analysis to asses whether changes in co-localisation between cell types are associated with survival probability. spicy fits a Cox proportional hazards model to assess the risk of death with the L-function as the explanatory variable. If there are multiple images provided per subject, spicy fits a Cox mixed effects model instead.\nTo perform survival analysis, spicy requires the SingleCellExperiment object being used to contain a column called survival as a Surv object.\n\nkerenSPE$event = 1 - kerenSPE$Censored\nkerenSPE$survival = Surv(kerenSPE$`Survival_days_capped*`, kerenSPE$event)\n\nWe can then perform survival analysis using the spicy function by specifying condition = \"survival\". The corresponding coefficients and p-values can be accessed through the survivalResults slot in the spicy results object.\n\n# Running survival analysis\nspicySurvival = spicy(kerenSPE,\n                      condition = \"survival\",\n                      BPPARAM = BPPARAM)\n\n# top 10 significant pairs\nhead(spicySurvival$survivalResults, 10)\n\n# A tibble: 10 × 4\n   test                       coef se.coef    p.value\n   &lt;chr&gt;                     &lt;dbl&gt;   &lt;dbl&gt;      &lt;dbl&gt;\n 1 Other_Immune__Tregs     0.0236  0.00868 0.00000850\n 2 CD4_T_cell__Tregs       0.0178  0.00688 0.0000119 \n 3 Tregs__Other_Immune     0.0237  0.00875 0.0000124 \n 4 Tregs__CD4_T_cell       0.0171  0.00677 0.0000290 \n 5 CD8_T_cell__CD8_T_cell  0.00605 0.00273 0.000329  \n 6 Tumour__CD8_T_cell     -0.0307  0.0115  0.000582  \n 7 CD8_T_cell__Tumour     -0.0307  0.0117  0.000667  \n 8 CD4_T_cell__dn_T_CD3    0.00850 0.00354 0.000710  \n 9 dn_T_CD3__CD4_T_cell    0.00841 0.00354 0.000925  \n10 DC__Other_Immune       -0.0288  0.0123  0.00105   \n\nTime for this code chunk to run with 5.5 cores: 8.63 seconds\n\n\nsignifPlot(spicySurvival,\n           marksToPlot = c(\"Tumour\", \"Tregs\", \"NK\", \"Neutrophils\", \"Mono_or_Neu\", \n                           \"Macrophages\", \"Keratin_Tumour\", \"dn_T_CD3\", \"DC_or_Mono\",\n                           \"DC\", \"CD8_T_cell\", \"CD4_T_cell\", \"B_cell\"))\n\n\n\n\n\n\n\nFrom the table and the graph above, we can see that the coefficient for Tumour__CD8_T_cell is negative, indicating that localisation between the two cell types is associated with a better prognosis for the patient. We can also see that localisation between most immune cell types (Neutrophils__CD8_T_cell, Tregs__CD4_T_cell, dn_T_CD3__CD4_T_cell) is associated with worse outcomes for the patient.\nWe can examine the relationship for one pair of cell types (Tumour__CD8_T_cell) more closely using a Kaplan-Meier curve. Below, we extract the survival data from kerenSPE and create a Surv object.\n\n# extracting survival data\nsurvData &lt;- kerenSPE |&gt;\n  colData() |&gt;\n  data.frame() |&gt;\n  select(imageID, survival) |&gt;\n  unique()\n\n# creating survival vector\nkerenSurv &lt;- survData$survival\nnames(kerenSurv) &lt;- survData$imageID\n\nkerenSurv\n\n    1     2     3     4     5     6     7     8     9    10    11    12    13 \n 2612   745 3130+ 2523+ 1683+ 2275+   584   946 3767+ 3822+ 3774+ 4353+  1072 \n   14    15    16    17    18    19    20    21    23    24    25    26    27 \n4145+  1754   530  2842 5063+ 3725+ 4761+   635    91   194 4785+ 4430+  3658 \n   28    29    31    32    33    34    35    36    37    39    40    41 \n3767+  1319  1009 1568+ 1738+ 2832+ 2759+ 3063+ 2853+ 2096+  3573 3355+ \n\n\nWe can then convert our L-function metrics into a binary metric with two categories: Localised and Dispersed, and plot a Kaplan-Meier curve to view its relationship to survival probability.\n\n# obtain L-function values for a specific cell type\n# and convert into localised/dispersed based on the median\nsurvRelationship = bind(spicySurvival)[[\"Tumour__CD8_T_cell\"]]\nsurvRelationship = ifelse(survRelationship &gt; median(survRelationship, na.rm = TRUE),\n                          \"Localised\", \"Dispersed\")\n\n# ensuring consistency and removing missing values\nnames(survRelationship) = names(kerenSurv)\nsurvRelationship = survRelationship[!is.na(names(survRelationship))]\nkerenSurv = kerenSurv[names(kerenSurv) %in% names(survRelationship)]\n\n# plotting Kaplan-Meier curve\nsurvfit2(kerenSurv ~ survRelationship) |&gt;\n  ggsurvfit() +\n  ggtitle(\"Tumour__CD8_T_cell\")\n\n\n\n\n\n\n\nThe KM curve aligns with that we observed from the bubble plot.\n\n8.1.7 Accounting for tissue inhomogeneity\nThe spicy function can also account for tissue inhomogeneity to avoid false positives or negatives. This can be done by setting the sigma = parameter within the spicy function. By default, sigma is set to NULL, and spicy assumes a homogeneous tissue structure.\nTo demonstrate why sigma is a useful parameter, we examine the degree of co-localisation between Keratin_Tumour__Neutrophils in one image using the getPairwise function, which returns the L-function values for each cell type pair. We set the radius over which the L-function should be calculated (Rs = 100) and specify sigma = NULL.\n\n# filter SPE object to obtain image 24 data\nkerenSubset = kerenSPE[, colData(kerenSPE)$imageID == \"24\"]\n\npairwiseAssoc = getPairwise(kerenSubset, \n                            sigma = NULL, \n                            Rs = 100) |&gt;\n  as.data.frame()\n\npairwiseAssoc[[\"Keratin_Tumour__Neutrophils\"]]\n\n[1] 10.88892\n\n\nThe calculated L-function is positive, indicating attraction between the two cell types.\nWhen we specify sigma = 20 and re-calculate the L-function, it indicates that there is no relationship between Keratin_Tumour and Neutrophils, i.e., there is no major attraction or dispersion, as it now takes into account tissue inhomogeneity.\n\npairwiseAssoc = getPairwise(kerenSubset, \n                            sigma = 20, \n                            Rs = 100) |&gt; as.data.frame()\n\npairwiseAssoc[[\"Keratin_Tumour__Neutrophils\"]]\n\n[1] 0.9024836\n\n\nTo understand why this might be happening, we can take a closer look at the relationship between Keratin_Tumour and Neutrophils. The plotImage function allows us to plot any two cell types for a specific image. Below, we plot image 24 for the Keratin_Tumour__Neutrophils relationship by specifying from = Keratin_Tumour and to = Neutrophils.\n\nplotImage(kerenSPE, imageToPlot = \"24\", \n          from = \"Keratin_Tumour\", \n          to = \"Neutrophils\")\n\n\n\n\n\n\n\nPlotting image 24 shows that the supposed co-localisation occurs due to the dense cluster of cells near the bottom of the image, and when we take this into account, the localisation disappears.\n\n8.1.8 Adjusting for cell count\nThe L-function (and by extension, the co-localisation score) is sensitive to the number of cells in an image. Too few cells can cause the L-function to become unstable and obscure meaningful spatial relationships. The issue is particularly pronounced when there is a skewed ratio of cell types in an image.\nIn the plot below, we can see that the variance of the co-localisation metric is greater when the number of cells is low, and becomes more stable as the number of cells increases.\nTo address this issue, spicyR uses a shape constrained generalised additive model (GAM) to model the co-localisation metric \\(u\\) as a function of the number of cells per cell type. The inverse of this fitted curve is used to generate weights which are applied to each image. Images with fewer cells have a lower weight. spicyR can perform image weighting in two ways: by fitting the GAM on the scores from all cell types at once, or by fitting the GAM on each pair of cell types. To perform image weighting by cell type pair, set weightsByPair = TRUE when using spicy.\nFrom the boxplot below, we can identify images that may have very few cells or a skewed cell type distribution. For consistency, we will use the cell type pair Macrophages__dn_T_CD3, which showed significant differences in co-localisation between cold and compartmentalised tumours in our initial analysis.\n\nspicyBoxPlot(spicyTest,\n             from = \"Macrophages\",\n             to = \"dn_T_CD3\")\n\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_boxplot()`).\n\n\n\n\n\n\n\n\nUsing the graph, we can filter for compartmentalised images that had an L-function value greater than 20 and examine the structure of these images.\n\nbind(spicyTest) |&gt; \n  dplyr::select(c(imageID, condition, Macrophages__dn_T_CD3)) |&gt;\n  # filter for compartmenatalised images with L-function &gt; 20 (an outlier)\n  dplyr::filter(condition == \"compartmentalised\" & Macrophages__dn_T_CD3 &gt; 20)\n\n  imageID         condition Macrophages__dn_T_CD3\n1      34 compartmentalised              34.12149\n\n\nWe can use plotImage to examine image 34 more closely.\n\nplotImage(kerenSPE, imageToPlot = 34, from = \"Macrophages\", to = \"dn_T_CD3\")\n\n\n\n\n\n\n\nThe value of the L-function tells us that there is localisation between macrophages and double negative CD3 T cells in this image. However, when we examine the image in question, it appears that the number of dn_T_CD3 cells is low compared to the number of Macrophages. The L-function is therefore not capturing the full context of the spatial relationship.\nWe can repeat the process above for mixed tumours.\n\nbind(spicyTest) |&gt; \n  dplyr::select(c(imageID, condition, Macrophages__dn_T_CD3)) |&gt;\n  dplyr::filter(condition == \"mixed\" & Macrophages__dn_T_CD3 &gt; 20)\n\n  imageID condition Macrophages__dn_T_CD3\n1      14     mixed              38.71105\n2      23     mixed              46.91940\n3      33     mixed              36.41111\n\n\nHere, three images have high L-function values. We will examine image 33.\n\nplotImage(kerenSPE, imageToPlot = 33, from = \"Macrophages\", to = \"dn_T_CD3\")\n\n\n\n\n\n\n\nAs before, we can see that the number of dn_T_CD3 cells is low, driving the L-function up even though true localisation may not be occurring.\n\n\n\n\n\n\nAssessing image quality\n\n\n\nHow do we distinguish “good” images from “bad” ones?\n\nTypically, images with very few cells can skew the L-function, and make it appear as though there is localization or dispersion when, in reality, no significant spatial pattern exists. These images usually have very high or very low L-function values compared to other images in the same group.\nSkewed images must be further examined to understand the reason behind the abnormal L-function values. Factors such as imaging artifacts, poor segmentation, or uneven cell distribution could contribute to this skew. In contrast, good quality images typically exhibit a more balanced ratio of cell types and a consistent number of cells across images.\n\n\n\nIn the next section, we will demonstrate how and why we can derive spatial contexts within tissue samples to produce robust spatial quantifications.",
    "crumbs": [
      "Cell localisation",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Cell localisation between pairs of cell types</span>"
    ]
  },
  {
    "objectID": "04a-cell_localisation.html#sessioninfo",
    "href": "04a-cell_localisation.html#sessioninfo",
    "title": "\n8  Cell localisation between pairs of cell types\n",
    "section": "\n8.2 sessionInfo",
    "text": "8.2 sessionInfo\n\nsessionInfo()\n\nR version 4.4.1 (2024-06-14)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Sonoma 14.4.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Australia/Sydney\ntzcode source: internal\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] spicyR_1.19.3               testthat_3.2.1.1           \n [3] ggsurvfit_1.1.0             treekoR_1.14.0             \n [5] tibble_3.2.1                survival_3.7-0             \n [7] dplyr_1.1.4                 imcRtools_1.12.0           \n [9] SpatialDatasets_1.4.0       ExperimentHub_2.14.0       \n[11] AnnotationHub_3.14.0        BiocFileCache_2.14.0       \n[13] dbplyr_2.5.0                SpatialExperiment_1.16.0   \n[15] SingleCellExperiment_1.28.1 SummarizedExperiment_1.36.0\n[17] Biobase_2.66.0              GenomicRanges_1.58.0       \n[19] GenomeInfoDb_1.42.0         IRanges_2.40.0             \n[21] S4Vectors_0.44.0            BiocGenerics_0.52.0        \n[23] MatrixGenerics_1.18.0       matrixStats_1.4.1          \n[25] ggplot2_3.5.1               Statial_1.8.0              \n\nloaded via a namespace (and not attached):\n  [1] vroom_1.6.5                 urlchecker_1.0.1           \n  [3] tiff_0.1-12                 dcanr_1.22.0               \n  [5] goftest_1.2-3               DT_0.33                    \n  [7] Biostrings_2.74.0           HDF5Array_1.34.0           \n  [9] TH.data_1.1-2               vctrs_0.6.5                \n [11] spatstat.random_3.3-2       digest_0.6.37              \n [13] png_0.1-8                   shape_1.4.6.1              \n [15] proxy_0.4-27                ggrepel_0.9.6              \n [17] deldir_2.0-4                magick_2.8.5               \n [19] MASS_7.3-61                 reshape2_1.4.4             \n [21] httpuv_1.6.15               foreach_1.5.2              \n [23] withr_3.0.2                 ggfun_0.1.7                \n [25] xfun_0.49                   ellipsis_0.3.2             \n [27] ggpubr_0.6.0                doRNG_1.8.6.1              \n [29] memoise_2.0.1               RTriangle_1.6-0.14         \n [31] cytomapper_1.18.0           ggbeeswarm_0.7.2           \n [33] RProtoBufLib_2.18.0         profvis_0.4.0              \n [35] systemfonts_1.1.0           tidytree_0.4.6             \n [37] zoo_1.8-12                  GlobalOptions_0.1.2        \n [39] Formula_1.2-5               KEGGREST_1.46.0            \n [41] promises_1.3.2              httr_1.4.7                 \n [43] rstatix_0.7.2               rhdf5filters_1.18.0        \n [45] rhdf5_2.50.0                rstudioapi_0.17.1          \n [47] miniUI_0.1.1.1              UCSC.utils_1.2.0           \n [49] units_0.8-5                 generics_0.1.3             \n [51] concaveman_1.1.0            curl_6.0.1                 \n [53] zlibbioc_1.52.0             ggraph_2.2.1               \n [55] polyclip_1.10-7             GenomeInfoDbData_1.2.13    \n [57] SparseArray_1.6.0           fftwtools_0.9-11           \n [59] desc_1.4.3                  xtable_1.8-4               \n [61] stringr_1.5.1               doParallel_1.0.17          \n [63] evaluate_1.0.1              S4Arrays_1.6.0             \n [65] hms_1.1.3                   colorspace_2.1-1           \n [67] filelock_1.0.3              spatstat.data_3.1-4        \n [69] magrittr_2.0.3              readr_2.1.5                \n [71] later_1.4.1                 viridis_0.6.5              \n [73] ggtree_3.14.0               lattice_0.22-6             \n [75] spatstat.geom_3.3-4         XML_3.99-0.17              \n [77] scuttle_1.16.0              ggupset_0.4.0              \n [79] class_7.3-22                svgPanZoom_0.3.4           \n [81] pillar_1.9.0                simpleSeg_1.8.0            \n [83] nlme_3.1-166                iterators_1.0.14           \n [85] EBImage_4.48.0              compiler_4.4.1             \n [87] beachmat_2.22.0             stringi_1.8.4              \n [89] sf_1.0-19                   devtools_2.4.5             \n [91] tensor_1.5                  minqa_1.2.8                \n [93] ClassifyR_3.10.5            plyr_1.8.9                 \n [95] crayon_1.5.3                abind_1.4-8                \n [97] gridGraphics_0.5-1          locfit_1.5-9.10            \n [99] sp_2.1-4                    graphlayouts_1.2.1         \n[101] bit_4.5.0                   terra_1.7-78               \n[103] sandwich_3.1-1              codetools_0.2-20           \n[105] multcomp_1.4-26             e1071_1.7-16               \n[107] GetoptLong_1.0.5            plotly_4.10.4              \n[109] mime_0.12                   MultiAssayExperiment_1.32.0\n[111] splines_4.4.1               circlize_0.4.16            \n[113] Rcpp_1.0.13-1               knitr_1.49                 \n[115] blob_1.2.4                  utf8_1.2.4                 \n[117] clue_0.3-66                 BiocVersion_3.20.0         \n[119] lme4_1.1-35.5               fs_1.6.5                   \n[121] nnls_1.6                    pkgbuild_1.4.5             \n[123] ggplotify_0.1.2             ggsignif_0.6.4             \n[125] Matrix_1.7-1                scam_1.2-17                \n[127] statmod_1.5.0               tzdb_0.4.0                 \n[129] svglite_2.1.3               tweenr_2.0.3               \n[131] pkgconfig_2.0.3             pheatmap_1.0.12            \n[133] tools_4.4.1                 cachem_1.1.0               \n[135] RSQLite_2.3.8               viridisLite_0.4.2          \n[137] DBI_1.2.3                   numDeriv_2016.8-1.1        \n[139] fastmap_1.2.0               rmarkdown_2.29             \n[141] scales_1.3.0                grid_4.4.1                 \n[143] usethis_3.1.0               shinydashboard_0.7.2       \n[145] broom_1.0.7                 patchwork_1.3.0            \n[147] BiocManager_1.30.25         carData_3.0-5              \n[149] farver_2.1.2                tidygraph_1.3.1            \n[151] mgcv_1.9-1                  yaml_2.3.10                \n[153] ggthemes_5.1.0              cli_3.6.3                  \n[155] purrr_1.0.2                 hopach_2.66.0              \n[157] lifecycle_1.0.4             mvtnorm_1.3-2              \n[159] sessioninfo_1.2.2           backports_1.5.0            \n[161] BiocParallel_1.40.0         cytolib_2.18.0             \n[163] gtable_0.3.6                rjson_0.2.23               \n[165] parallel_4.4.1              ape_5.8                    \n[167] limma_3.62.1                jsonlite_1.8.9             \n[169] edgeR_4.4.0                 bitops_1.0-9               \n[171] bit64_4.5.2                 brio_1.1.5                 \n[173] Rtsne_0.17                  FlowSOM_2.14.0             \n[175] yulab.utils_0.1.8           spatstat.utils_3.1-1       \n[177] BiocNeighbors_2.0.0         ranger_0.17.0              \n[179] flowCore_2.18.0             bdsmatrix_1.3-7            \n[181] spatstat.univar_3.1-1       lazyeval_0.2.2             \n[183] shiny_1.9.1                 ConsensusClusterPlus_1.70.0\n[185] htmltools_0.5.8.1           diffcyt_1.26.0             \n[187] rappdirs_0.3.3              distances_0.1.11           \n[189] glue_1.8.0                  XVector_0.46.0             \n[191] RCurl_1.98-1.16             rprojroot_2.0.4            \n[193] treeio_1.30.0               classInt_0.4-10            \n[195] coxme_2.2-22                jpeg_0.1-10                \n[197] gridExtra_2.3               boot_1.3-31                \n[199] igraph_2.1.1                R6_2.5.1                   \n[201] tidyr_1.3.1                 ggiraph_0.8.11             \n[203] labeling_0.4.3              ggh4x_0.2.8                \n[205] cluster_2.1.6               rngtools_1.5.2             \n[207] pkgload_1.4.0               Rhdf5lib_1.28.0            \n[209] aplot_0.2.3                 nloptr_2.1.1               \n[211] DelayedArray_0.32.0         tidyselect_1.2.1           \n[213] vipor_0.4.7                 ggforce_0.4.2              \n[215] raster_3.6-30               car_3.1-3                  \n[217] AnnotationDbi_1.68.0        munsell_0.5.1              \n[219] KernSmooth_2.23-24          data.table_1.16.2          \n[221] htmlwidgets_1.6.4           ComplexHeatmap_2.22.0      \n[223] RColorBrewer_1.1-3          rlang_1.1.4                \n[225] spatstat.sparse_3.1-0       spatstat.explore_3.3-3     \n[227] remotes_2.5.0               lmerTest_3.1-3             \n[229] uuid_1.2-1                  colorRamps_2.3.4           \n[231] ggnewscale_0.5.0            fansi_1.0.6                \n[233] beeswarm_0.4.0",
    "crumbs": [
      "Cell localisation",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Cell localisation between pairs of cell types</span>"
    ]
  },
  {
    "objectID": "04b-cell_localisation_parent.html",
    "href": "04b-cell_localisation_parent.html",
    "title": "\n9  Cell relationships relative to expected behaviour\n",
    "section": "",
    "text": "9.1 Load datasets\nkerenSPE &lt;- SpatialDatasets::spe_Keren_2018()\n\n# remove any missing data in our outcome columns\nkerenSPE = kerenSPE[, complete.cases(colData(kerenSPE)[, c(\"Censored\", \"Survival_days_capped*\",\n                                                           \"tumour_type\")])]",
    "crumbs": [
      "Cell localisation",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Cell relationships relative to expected behaviour</span>"
    ]
  },
  {
    "objectID": "04b-cell_localisation_parent.html#kontextual-context-aware-cell-localisation",
    "href": "04b-cell_localisation_parent.html#kontextual-context-aware-cell-localisation",
    "title": "\n9  Cell relationships relative to expected behaviour\n",
    "section": "\n9.2 Kontextual: Context aware cell localisation",
    "text": "9.2 Kontextual: Context aware cell localisation\nKontextual is a method for performing inference on cell localisation which explicitly defines the contexts in which spatial relationships between cells can be identified and interpreted. These contexts may represent landmarks, spatial domains, or groups of functionally similar cells which are consistent across regions. By modelling spatial relationships between cells relative to these contexts, Kontextual produces robust spatial quantifications that are not confounded by biases such as the choice of region to image and the tissue structure present in the images. The Kontextual function is available in the Statial package.\n\nIn this example we demonstrate how cell type hierarchies can be used as a means to derive appropriate “contexts” for the evaluation of cell localisation. We then demonstrate the types of conclusions which Kontextual enables.\n\n9.2.1 Using cell type hierarchies to define a “context”\nA cell type hierarchy may be used to define the “context” in which cell type relationships are evaluated within. A cell type hierarchy defines how cell types are functionally related to one another. The bottom of the hierarchy represents homogeneous populations of a cell type (child), and the cell populations at the nodes of the hierarchy represent broader parent populations with shared generalised function. For example, CD4 T cells may be considered a child population to the Immune parent population.\nThere are two ways to define the cell type hierarchy. First, they can be defined based on our biological understanding of the cell types. We can represent this by creating a named list containing the names of each parent and the associated vector of child cell types.\n\n\n\n\n\n\nNote\n\n\n\nThe all vector must be created to include cell types which do not have a parent e.g. the undefined cell type in this data set.\n\n\n\n# Examine all cell types in image\nunique(kerenSPE$cellType)\n\n [1] \"Keratin_Tumour\" \"dn_T_CD3\"       \"B_cell\"         \"CD4_T_cell\"    \n [5] \"DC_or_Mono\"     \"Unidentified\"   \"Macrophages\"    \"CD8_T_cell\"    \n [9] \"Other_Immune\"   \"Endothelial\"    \"Mono_or_Neu\"    \"Mesenchymal\"   \n[13] \"Neutrophils\"    \"NK\"             \"Tumour\"         \"DC\"            \n[17] \"Tregs\"         \n\n# Named list of parents and their child cell types\nbiologicalHierarchy = list(\n  \"tumour\" = c(\"Keratin_Tumour\", \"Tumour\"),\n  \"tcells\" = c(\"dn_T_CD3\", \"CD4_T_cell\", \"CD8_T_cell\", \"Tregs\"),\n  \"myeloid\" = c(\"DC_or_Mono\", \"DC\", \"Mono_or_Neu\", \"Macrophages\", \"Neutrophils\"),\n  \"tissue\" = c(\"Endothelial\", \"Mesenchymal\")\n)\n\n# Adding more broader immune parent populations\nbiologicalHierarchy$immune = c(biologicalHierarchy$bcells,\n                               biologicalHierarchy$tcells,\n                               biologicalHierarchy$myeloid,\n                               \"NK\", \"Other_Immune\", \"B_cell\")\n\n\n# Creating a vector for all cellTypes\nall &lt;- unique(kerenSPE$cellType)\n\nAlternatively, you can use the treeKoR package on Bioconductor to define these hierarchies in a data driven way.\n\n\n\n\n\n\nNote\n\n\n\nThese parent populations may not be accurate as we are using a small subset of the data.\n\n\n\n# Calculate hierarchy using treekoR\nkerenTree &lt;- treekoR::getClusterTree(t(assay(kerenSPE, \"intensities\")),\n                            kerenSPE$cellType,\n                            hierarchy_method = \"hopach\",\n                            hopach_K = 1)\n\n# Convert treekoR result to a name list of parents and children.\ntreekorParents = getParentPhylo(kerenTree)\n\ntreekorParents\n\n$parent_1\n [1] \"dn_T_CD3\"     \"B_cell\"       \"CD4_T_cell\"   \"DC_or_Mono\"   \"Macrophages\" \n [6] \"CD8_T_cell\"   \"Other_Immune\" \"NK\"           \"DC\"           \"Tregs\"       \n\n$parent_2\n[1] \"Unidentified\" \"Endothelial\"  \"Mesenchymal\" \n\n$parent_3\n[1] \"Keratin_Tumour\" \"Mono_or_Neu\"    \"Neutrophils\"    \"Tumour\"        \n\n\n\n9.2.2 Application on triple negative breast cancer image\nHere we examine an image highlighted in the Keren 2018 manuscript where accounting for context information enabled new conclusions.\n\n# Lets define a new cell type vector\nkerenSPE$cellTypeNew &lt;- kerenSPE$cellType\n\n# Select for all cells that express higher than baseline level of p53\np53Pos &lt;- assay(kerenSPE)[\"p53\", ] &gt; -0.300460\n\n# Find p53+ tumour cells\nkerenSPE$cellTypeNew[kerenSPE$cellType %in% biologicalHierarchy$tumour] &lt;- \"Tumour\"\nkerenSPE$cellTypeNew[p53Pos & kerenSPE$cellType %in% biologicalHierarchy$tumour] &lt;- \"p53_Tumour\"\n\n# Group all immune cells under the name \"Immune\"\nkerenSPE$cellTypeNew[kerenSPE$cellType %in% biologicalHierarchy$immune] &lt;- \"Immune\"\n\nkerenSPE$x &lt;- spatialCoords(kerenSPE)[,\"x\"]\nkerenSPE$y &lt;- spatialCoords(kerenSPE)[,\"y\"]\n\n# Plot image 6\nkerenSPE |&gt;\n  colData() |&gt;\n  as.data.frame() |&gt;\n  filter(imageID == \"6\") |&gt;\n  filter(cellTypeNew %in% c(\"Immune\", \"Tumour\", \"p53_Tumour\")) |&gt;\n  arrange(cellTypeNew) |&gt;\n  ggplot(aes(x = x, y = y, color = cellTypeNew)) +\n  geom_point(size = 1) +\n  scale_colour_manual(values = c(\"Immune\" = \"#505050\", \"p53_Tumour\" = \"#64BC46\", \"Tumour\" = \"#D6D6D6\")) +\n  guides(colour = guide_legend(title = \"Cell types\", override.aes = list(size = 3)))\n\n\n\n\n\n\n\nIn image 6 of the Keren 2018 dataset given above, we can see that p53+ tumour cells and immune cells are dispersed. However, we can also see that p53+ tumour cells appear much more localised to immune cells relative to the tumour context (tumour cells and p53+ tumour cells).\nWe can calculate a context-aware spatial co-localisation metric using Kontextual. Kontextual accepts a SingleCellExperiment object, a single image, or list of images from a SingleCellExperiment object, which gets passed into the cells argument. The two cell types which will be evaluated are specified in the to and from arguments. A parent population must also be specified in the parent argument. Note the parent cell population must include the to cell type. The argument r will specify the radius which the cell relationship will be evaluated on. Kontextual supports parallel processing, and the number of cores can be specified using the cores argument. Kontextual can take a single value or multiple values for each argument and will test all combinations of the arguments specified.\nWe can calculate these relationships across all images for a single radius (r = 100).\n\np53_Kontextual &lt;- Kontextual(\n  cells = kerenSPE,\n  r = 100,\n  from = \"Immune\",\n  to = \"p53_Tumour\",\n  parent = c(\"p53_Tumour\", \"Tumour\"),\n  cellType = \"cellTypeNew\"\n)\n\nhead(p53_Kontextual)\n\n  imageID               test   original kontextual   r inhomL\n1       1 Immune__p53_Tumour -16.212016  -1.681595 100  FALSE\n2      10 Immune__p53_Tumour -14.715356  -1.793741 100  FALSE\n3      11 Immune__p53_Tumour -11.696597  -7.461566 100  FALSE\n4      12 Immune__p53_Tumour  -9.777271  -2.628700 100  FALSE\n5      13 Immune__p53_Tumour -15.613023  -3.993736 100  FALSE\n6      14 Immune__p53_Tumour -14.671281  -4.287914 100  FALSE\n\nTime for this code chunk to run with 5.5 cores: 12.82 seconds\n\nThe kontextCurve function plots the L-function value and Kontextual values over a range of radii. If the points lie above the red line (expected pattern) then localisation is indicated for that radius, if the points lie below the red line then dispersion is indicated.\nAs seen in the following plot the L-function produces negative values over a range of radii, indicating that p53+ tumour cells and immune cells are dispersed from one another. However by taking into account the tumour context, Kontextual shows positive values over some radii, indicating localisation between p53+ tumour cells and immune cells.\n\ncurves &lt;- kontextCurve(\n  cells = kerenSPE,\n  from = \"Immune\",\n  to = \"p53_Tumour\",\n  parent = c(\"p53_Tumour\", \"Tumour\"),\n  rs = seq(50, 510, 50),\n  image = \"6\",\n  cellType = \"cellTypeNew\",\n  cores = nCores\n)\n\nkontextPlot(curves)\n\n\n\n\n\n\nTime for this code chunk to run with 5.5 cores: 14.56 seconds\n\nAlternatively, we can also test all pairwise cell relationships and their corresponding parent in the dataset. First, we create a data frame with all pairwise combinations using the parentCombinations function. This function takes in a vector of all the cells, as well as the named list of parents and children created earlier in the parentList argument. As shown below, the output is a data frame specifying the to, from, and parent arguments for Kontextual.\n\n\n\n\n\n\nNote\n\n\n\nIf you want to use the treeKor defined hierarchy instead, the output of getParentPhylo can be passed to the parentList argument.\n\n\n\n# Get all relationships between cell types and their parents\nparentDf &lt;- parentCombinations(\n  all = all,\n  parentList = biologicalHierarchy\n)\n\nhead(parentDf)\n\n            from     to       parent parent_name\n1 Keratin_Tumour B_cell dn_T_CD3....      immune\n2       dn_T_CD3 B_cell dn_T_CD3....      immune\n3     CD4_T_cell B_cell dn_T_CD3....      immune\n4     DC_or_Mono B_cell dn_T_CD3....      immune\n5   Unidentified B_cell dn_T_CD3....      immune\n6    Macrophages B_cell dn_T_CD3....      immune\n\n\n\n9.2.3 Calculating all pairwise relationships\nRather than specifying to, from, and parent in Kontextual, the output from parentCombinations can be inputted into Kontextual using the parentDf argument to examine all pairwise relationships in the dataset.\n\n# Running Kontextual on all relationships across all images.\nkerenKontextual &lt;- Kontextual(\n  cells = kerenSPE,\n  parentDf = parentDf,\n  r = 100,\n  cores = nCores\n)\n\nhead(kerenKontextual)\n\n  imageID                           test   original kontextual   r inhomL\n1       1 Keratin_Tumour__B_cell__immune -32.547645 -20.812972 100  FALSE\n2      10 Keratin_Tumour__B_cell__immune -32.497368 -26.795851 100  FALSE\n3      11 Keratin_Tumour__B_cell__immune   4.829389   1.697818 100  FALSE\n4      12 Keratin_Tumour__B_cell__immune -13.468515  -8.937432 100  FALSE\n5      13 Keratin_Tumour__B_cell__immune -21.768051 -14.206190 100  FALSE\n6      14 Keratin_Tumour__B_cell__immune         NA         NA 100  FALSE\n\nTime for this code chunk to run with 5.5 cores: 82.94 seconds\n\nFor every pairwise relationship (named accordingly: from__to__parent) Kontextual outputs the L-function values (original) and the Kontextual value. The relationships where the L-function and Kontextual disagree (e.g. one metric is positive and the other is negative) represent relationships where adding context information results in different conclusions on the spatial relationship between the two cell types.\n\n9.2.4 Associating the relationships with survival outcomes\nWe can then examine whether Kontexual can be associated with patient outcomes or groupings. For this, we can use the spicy function from the spicyR package. First, the Kontextual results must be converted from a data.frame to a wide matrix. This can be done with the prepMatrix function.\n\n\n\n\n\n\nNote\n\n\n\nTo extract the original L-function values, specify column = \"original\" in prepMatrix.\n\n\n\n# Converting Kontextual result into data matrix\nkontextMat &lt;- prepMatrix(kerenKontextual)\n\n# Ensuring rownames of kontextMat match up with the image IDs of the SCE object\nkontextMat &lt;- kontextMat[kerenSPE$imageID |&gt; unique(), ]\n\n# Replace NAs with 0\nkontextMat[is.na(kontextMat)] &lt;- 0\n\nFinally, both the SingleCellExperiment object and the Kontextual matrix are passed into the spicy function, with condition = \"survival\". The resulting coefficients and p values can be obtained by accessing the survivalResults slot.\n\nkerenSPE$event = 1 - kerenSPE$Censored\nkerenSPE$survival = Surv(kerenSPE$`Survival_days_capped*`, kerenSPE$event)\n\n# Running survival analysis using spicy\nsurvivalResults = spicy(cells = kerenSPE,\n                        alternateResult = kontextMat,\n                        condition = \"survival\",\n                        weights = TRUE)\n\nhead(survivalResults$survivalResults, 10)\n\n# A tibble: 10 × 4\n   test                                    coef se.coef     p.value\n   &lt;chr&gt;                                  &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n 1 dn_T_CD3__Tregs__immune               0.0187 0.00716 0.000000568\n 2 Other_Immune__Tregs__immune           0.0255 0.00885 0.000000696\n 3 Tregs__dn_T_CD3__immune               0.0189 0.00716 0.00000176 \n 4 Neutrophils__CD8_T_cell__immune       0.0178 0.00652 0.00000177 \n 5 DC__dn_T_CD3__immune                 -0.0195 0.00662 0.00000730 \n 6 DC__dn_T_CD3__tcells                 -0.0171 0.00759 0.0000165  \n 7 Other_Immune__Keratin_Tumour__tumour  0.137  0.0409  0.0000207  \n 8 CD4_T_cell__Tregs__immune             0.0216 0.00902 0.0000290  \n 9 Other_Immune__DC__myeloid            -0.0181 0.00664 0.0000490  \n10 Other_Immune__DC__immune             -0.0186 0.00669 0.0000652  \n\nTime for this code chunk to run with 5.5 cores: 3.84 seconds\n\nThe survival results can also be visualised using the signifPlot function. The “Context” slot in the legend describes the parent population with respect to which the Kontextual metric is calculated.\n\nsignifPlot(survivalResults)\n\n\n\n\n\n\n\nAs we can see from the results, dn_T_CD3__Tregs__immune is the one of the most significant pairwise relationships which contributes to patient survival. That is the relationship between double negative CD3 T cells and regulatory T cells, relative to the parent population of immune cells. We can see that there is a positive coefficient associated with this relationship, which tells us an increase in localisation of these cell types relative to immune cells leads to worse survival outcomes for patients.\nThe association between dn_T_CD3__Tregs__immune and survival can also be visualised on a Kaplan-Meier curve. First, we extract survival data from the SingleCellExperiment object and create a survival vector.\n\n# Extracting survival data\nsurvData &lt;- kerenSPE |&gt;\n  colData() |&gt;\n  data.frame() |&gt;\n  select(imageID, survival) |&gt;\n  unique()\n\n# Creating survival vector\nkerenSurv &lt;- survData$survival\nnames(kerenSurv) &lt;- survData$imageID\n\nkerenSurv\n\n    1     2     3     4     5     6     7     8     9    10    11    12    13 \n 2612   745 3130+ 2523+ 1683+ 2275+   584   946 3767+ 3822+ 3774+ 4353+  1072 \n   14    15    16    17    18    19    20    21    23    24    25    26    27 \n4145+  1754   530  2842 5063+ 3725+ 4761+   635    91   194 4785+ 4430+  3658 \n   28    29    31    32    33    34    35    36    37    39    40    41 \n3767+  1319  1009 1568+ 1738+ 2832+ 2759+ 3063+ 2853+ 2096+  3573 3355+ \n\n\nNext, we extract the Kontextual values of this relationship across all images. We then determine if double negative CD3 T cells and regulatory T cells cells are relatively attracted or avoiding in each image by comparing the Kontextual value in each image to the median Kontextual value.\nFinally, we plot a Kaplan-Meier curve using the ggsurvfit package. As shown below, when double negative CD3 T cells and regulatory T cells are more localised to one another relative to the immune cell population, patients tend to have worse survival outcomes.\n\n# Selecting most significant relationship\nsurvRelationship &lt;- kontextMat[[\"dn_T_CD3__Tregs__immune\"]]\nsurvRelationship &lt;- ifelse(survRelationship &gt; median(survRelationship), \"Localised\", \"Dispersed\")\n\n# Plotting Kaplan-Meier curve\nsurvfit2(kerenSurv ~ survRelationship) |&gt;\n  ggsurvfit() +\n  ggtitle(\"dn_T_CD3__Tregs__immune\")\n\n\n\n\n\n\n\nIn the next section, we will look at how we can identify spatial domains, or regions of co-localisation between cell types, and how they can be associated with clinical outcomes.",
    "crumbs": [
      "Cell localisation",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Cell relationships relative to expected behaviour</span>"
    ]
  },
  {
    "objectID": "04b-cell_localisation_parent.html#sessioninfo",
    "href": "04b-cell_localisation_parent.html#sessioninfo",
    "title": "\n9  Cell relationships relative to expected behaviour\n",
    "section": "\n9.3 sessionInfo",
    "text": "9.3 sessionInfo\n\nsessionInfo()\n\nR version 4.4.1 (2024-06-14)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Sonoma 14.4.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Australia/Sydney\ntzcode source: internal\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] ggsurvfit_1.1.0             treekoR_1.14.0             \n [3] tibble_3.2.1                survival_3.7-0             \n [5] dplyr_1.1.4                 imcRtools_1.12.0           \n [7] SpatialDatasets_1.4.0       ExperimentHub_2.14.0       \n [9] AnnotationHub_3.14.0        BiocFileCache_2.14.0       \n[11] dbplyr_2.5.0                SpatialExperiment_1.16.0   \n[13] SingleCellExperiment_1.28.1 SummarizedExperiment_1.36.0\n[15] Biobase_2.66.0              GenomicRanges_1.58.0       \n[17] GenomeInfoDb_1.42.0         IRanges_2.40.0             \n[19] S4Vectors_0.44.0            BiocGenerics_0.52.0        \n[21] MatrixGenerics_1.18.0       matrixStats_1.4.1          \n[23] ggplot2_3.5.1               Statial_1.8.0              \n[25] spicyR_1.18.0              \n\nloaded via a namespace (and not attached):\n  [1] vroom_1.6.5                 tiff_0.1-12                \n  [3] dcanr_1.22.0                goftest_1.2-3              \n  [5] DT_0.33                     Biostrings_2.74.0          \n  [7] HDF5Array_1.34.0            TH.data_1.1-2              \n  [9] vctrs_0.6.5                 spatstat.random_3.3-2      \n [11] digest_0.6.37               png_0.1-8                  \n [13] shape_1.4.6.1               proxy_0.4-27               \n [15] ggrepel_0.9.6               deldir_2.0-4               \n [17] magick_2.8.5                MASS_7.3-61                \n [19] reshape2_1.4.4              httpuv_1.6.15              \n [21] foreach_1.5.2               withr_3.0.2                \n [23] ggfun_0.1.7                 xfun_0.49                  \n [25] ggpubr_0.6.0                doRNG_1.8.6.1              \n [27] memoise_2.0.1               RTriangle_1.6-0.14         \n [29] cytomapper_1.18.0           ggbeeswarm_0.7.2           \n [31] RProtoBufLib_2.18.0         systemfonts_1.1.0          \n [33] tidytree_0.4.6              zoo_1.8-12                 \n [35] GlobalOptions_0.1.2         Formula_1.2-5              \n [37] KEGGREST_1.46.0             promises_1.3.2             \n [39] httr_1.4.7                  rstatix_0.7.2              \n [41] rhdf5filters_1.18.0         rhdf5_2.50.0               \n [43] rstudioapi_0.17.1           UCSC.utils_1.2.0           \n [45] units_0.8-5                 generics_0.1.3             \n [47] concaveman_1.1.0            curl_6.0.1                 \n [49] zlibbioc_1.52.0             ggraph_2.2.1               \n [51] polyclip_1.10-7             GenomeInfoDbData_1.2.13    \n [53] SparseArray_1.6.0           fftwtools_0.9-11           \n [55] xtable_1.8-4                stringr_1.5.1              \n [57] doParallel_1.0.17           evaluate_1.0.1             \n [59] S4Arrays_1.6.0              hms_1.1.3                  \n [61] colorspace_2.1-1            filelock_1.0.3             \n [63] spatstat.data_3.1-4         magrittr_2.0.3             \n [65] readr_2.1.5                 later_1.4.1                \n [67] viridis_0.6.5               ggtree_3.14.0              \n [69] lattice_0.22-6              spatstat.geom_3.3-4        \n [71] XML_3.99-0.17               scuttle_1.16.0             \n [73] ggupset_0.4.0               class_7.3-22               \n [75] svgPanZoom_0.3.4            pillar_1.9.0               \n [77] simpleSeg_1.8.0             nlme_3.1-166               \n [79] iterators_1.0.14            EBImage_4.48.0             \n [81] compiler_4.4.1              beachmat_2.22.0            \n [83] stringi_1.8.4               sf_1.0-19                  \n [85] tensor_1.5                  minqa_1.2.8                \n [87] ClassifyR_3.10.5            plyr_1.8.9                 \n [89] crayon_1.5.3                abind_1.4-8                \n [91] gridGraphics_0.5-1          locfit_1.5-9.10            \n [93] sp_2.1-4                    graphlayouts_1.2.1         \n [95] bit_4.5.0                   terra_1.7-78               \n [97] sandwich_3.1-1              codetools_0.2-20           \n [99] multcomp_1.4-26             e1071_1.7-16               \n[101] GetoptLong_1.0.5            plotly_4.10.4              \n[103] mime_0.12                   MultiAssayExperiment_1.32.0\n[105] splines_4.4.1               circlize_0.4.16            \n[107] Rcpp_1.0.13-1               knitr_1.49                 \n[109] blob_1.2.4                  utf8_1.2.4                 \n[111] clue_0.3-66                 BiocVersion_3.20.0         \n[113] lme4_1.1-35.5               fs_1.6.5                   \n[115] nnls_1.6                    ggplotify_0.1.2            \n[117] ggsignif_0.6.4              Matrix_1.7-1               \n[119] scam_1.2-17                 statmod_1.5.0              \n[121] tzdb_0.4.0                  svglite_2.1.3              \n[123] tweenr_2.0.3                pkgconfig_2.0.3            \n[125] pheatmap_1.0.12             tools_4.4.1                \n[127] cachem_1.1.0                RSQLite_2.3.8              \n[129] viridisLite_0.4.2           DBI_1.2.3                  \n[131] numDeriv_2016.8-1.1         fastmap_1.2.0              \n[133] rmarkdown_2.29              scales_1.3.0               \n[135] grid_4.4.1                  shinydashboard_0.7.2       \n[137] broom_1.0.7                 patchwork_1.3.0            \n[139] BiocManager_1.30.25         carData_3.0-5              \n[141] farver_2.1.2                tidygraph_1.3.1            \n[143] mgcv_1.9-1                  yaml_2.3.10                \n[145] ggthemes_5.1.0              cli_3.6.3                  \n[147] purrr_1.0.2                 hopach_2.66.0              \n[149] lifecycle_1.0.4             mvtnorm_1.3-2              \n[151] backports_1.5.0             BiocParallel_1.40.0        \n[153] cytolib_2.18.0              gtable_0.3.6               \n[155] rjson_0.2.23                parallel_4.4.1             \n[157] ape_5.8                     limma_3.62.1               \n[159] jsonlite_1.8.9              edgeR_4.4.0                \n[161] bitops_1.0-9                bit64_4.5.2                \n[163] Rtsne_0.17                  FlowSOM_2.14.0             \n[165] yulab.utils_0.1.8           spatstat.utils_3.1-1       \n[167] BiocNeighbors_2.0.0         ranger_0.17.0              \n[169] flowCore_2.18.0             bdsmatrix_1.3-7            \n[171] spatstat.univar_3.1-1       lazyeval_0.2.2             \n[173] shiny_1.9.1                 ConsensusClusterPlus_1.70.0\n[175] htmltools_0.5.8.1           diffcyt_1.26.0             \n[177] rappdirs_0.3.3              distances_0.1.11           \n[179] glue_1.8.0                  XVector_0.46.0             \n[181] RCurl_1.98-1.16             treeio_1.30.0              \n[183] classInt_0.4-10             coxme_2.2-22               \n[185] jpeg_0.1-10                 gridExtra_2.3              \n[187] boot_1.3-31                 igraph_2.1.1               \n[189] R6_2.5.1                    tidyr_1.3.1                \n[191] ggiraph_0.8.11              labeling_0.4.3             \n[193] ggh4x_0.2.8                 cluster_2.1.6              \n[195] rngtools_1.5.2              Rhdf5lib_1.28.0            \n[197] aplot_0.2.3                 nloptr_2.1.1               \n[199] DelayedArray_0.32.0         tidyselect_1.2.1           \n[201] vipor_0.4.7                 ggforce_0.4.2              \n[203] raster_3.6-30               car_3.1-3                  \n[205] AnnotationDbi_1.68.0        munsell_0.5.1              \n[207] KernSmooth_2.23-24          data.table_1.16.2          \n[209] htmlwidgets_1.6.4           ComplexHeatmap_2.22.0      \n[211] RColorBrewer_1.1-3          rlang_1.1.4                \n[213] spatstat.sparse_3.1-0       spatstat.explore_3.3-3     \n[215] lmerTest_3.1-3              uuid_1.2-1                 \n[217] colorRamps_2.3.4            ggnewscale_0.5.0           \n[219] fansi_1.0.6                 beeswarm_0.4.0",
    "crumbs": [
      "Cell localisation",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Cell relationships relative to expected behaviour</span>"
    ]
  },
  {
    "objectID": "05-cellular_niches.html",
    "href": "05-cellular_niches.html",
    "title": "\n10  Identifying spatial domains with unsupervised clustering\n",
    "section": "",
    "text": "10.1 lisaClust\nClustering Local Indicators of Spatial Association (LISA) functions is a methodology for identifying consistent spatial organisation of multiple cell-types in an unsupervised way. This can be used to enable the characterisation of interactions between multiple cell-types simultaneously and can complement traditional pairwise analysis. In our implementation our LISA curves are a localised summary of an L-function from a Poisson point process model. Our framework lisaClust can be used to provide a high-level summary of cell type co-localisation in high-parameter spatial cytometry data, facilitating the identification of distinct tissue compartments or complex cellular microenvironments.\nThe workflow that lisaClust uses to identify regions of tissue with similar localisation patterns of cells contains multiple key steps. First, cells are treated as objects and assigned coordinates in an x-y space. Second, distances between all cells are calculated and then, by modeling the cells as a multi-type Poisson point process, the distances are used to calculate local indicators of spatial association (LISA). These LISA curves summarize the spatial association between each cell and a specific cell type over a range of radii. The LISA curves are calculated for each cell and cell type and then clustered to assign a region label for each cell.",
    "crumbs": [
      "Spatial domains",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Identifying spatial domains with unsupervised clustering</span>"
    ]
  },
  {
    "objectID": "05-cellular_niches.html#lisaclust",
    "href": "05-cellular_niches.html#lisaclust",
    "title": "\n10  Identifying spatial domains with unsupervised clustering\n",
    "section": "",
    "text": "10.1.1 Case study: Keren\nWe will start by reading in the Keren 2018 dataset from the SpatialDatasets package as a SingleCellExperiment object. Here the data is in a format consistent with that outputted by CellProfiler.\n\nkerenSPE &lt;- SpatialDatasets::spe_Keren_2018()\n\nsee ?SpatialDatasets and browseVignettes('SpatialDatasets') for documentation\n\n\nloading from cache\n\n\n\n10.1.1.1 Generate LISA curves\nFor the purpose of this demonstration, we will be using only images 5 and 6 of the dataset.\n\nkerenSPE &lt;- kerenSPE[,kerenSPE$imageID %in% c(\"5\", \"6\")]\n\nThis data comes with pre-annotated cell types, sowe can move directly to performing k-means clustering on the local indicators of spatial association (LISA) functions using the lisaClust function. The image ID, cell type column, and spatial coordinates can be specified using the imageID, cellType, and spatialCoords arguments respectively. We will identify 5 regions of co-localisation by setting k = 5.\n\nkerenSPE &lt;- lisaClust(kerenSPE,\n                      k = 5)\n\nThese regions are stored in colData and can be extracted.\n\ncolData(kerenSPE)[, c(\"imageID\", \"region\")] |&gt;\n  head(10)\n\nDataFrame with 10 rows and 2 columns\n          imageID      region\n      &lt;character&gt; &lt;character&gt;\n21154           5    region_4\n21155           5    region_4\n21156           5    region_4\n21157           5    region_2\n21158           5    region_2\n21159           5    region_2\n21160           5    region_5\n21161           5    region_2\n21162           5    region_2\n21163           5    region_2\n\n\n\n10.1.1.2 Examine cell type enrichment\nlisaClust also provides a convenient function, regionMap, for examining which cell types are located in which regions. In this example, we use this to check which cell types appear more frequently in each region than expected by chance.\n\nregionMap(kerenSPE,\n  type = \"bubble\")\n\n\n\n\n\n\n\nAbove, we can see that tumour cells are concentrated in region 5, and immune cells are concentrated in region 1 and 4. We can further segregate these cells by increasing the number of clusters, i.e., increasing the parameter k = in the lisaClust function.\n\n\n\n\n\n\nChoosing the number of spatial domains\n\n\n\nHow do we choose an appropriate value for k?\n\nThe choice of k depends largely on the biological question being asked. For instance, if we are interested in understanding the interactions between immune cells in a tumor microenvironment, the number of clusters should reflect the known biological subtypes of immune cells, such as T cells, B cells, macrophages, etc. In this case, a larger value of k may be needed to capture the diversity within these immune cell populations.\nOn the other hand, if the focus is on interactions between immune cells and tumor cells, we might choose a smaller value of k to group immune cells into broader categories.\nAdditionally, methods like the Gap statistic, Jump statistic, or Silhouette score could be employed to determine an optimal value of k.\n\n\n\n\n10.1.1.3 Plot identified regions\nWe can use the hatchingPlot function to visualise all 5 regions and 17 cell types simultaneously for a specific image or set of images. The output is a ggplot object where the regions are marked by different hatching patterns. The nbp argument can be used to tune the granularity of the grid used for defining regions.\n\nhatchingPlot(kerenSPE, useImages = 5, nbp = 300)\n\nConcave windows are temperamental. Try choosing values of window.length &gt; and &lt; 1 if you have problems.\n\n\nWarning in split.default(x = seq_len(nrow(x)), f = f, drop = drop, ...): data\nlength is not a multiple of split variable\nWarning in split.default(x = seq_len(nrow(x)), f = f, drop = drop, ...): data\nlength is not a multiple of split variable\n\n\n\n\n\n\n\nTime for this code chunk to run with 5.5 cores: 36.72 seconds\n\nIn accordance with the regionMap output, we can see that region 5 is mostly made up of tumour cells, and region 2 and 4 both contain our immune cell populations.\n\n\n\n\n\n\nCombining localisation scores with spatial domains\n\n\n\nHow could results from lisaClust be used in conjunction with results from spicyR?\nlisaClust provides a high-resolution view of the tissue architecture, while spicyR can quantify how these spatial relationships or features contribute to clinical outcomes. spicyR’s L-function metric can be used to determine the degree of localisation or dispersion between different spatial domains. For instance, we can look at co-localisation between region 5 (our tumour cells) and regions 2 or 4 (our immune cells).",
    "crumbs": [
      "Spatial domains",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Identifying spatial domains with unsupervised clustering</span>"
    ]
  },
  {
    "objectID": "05-cellular_niches.html#sessioninfo",
    "href": "05-cellular_niches.html#sessioninfo",
    "title": "\n10  Identifying spatial domains with unsupervised clustering\n",
    "section": "\n10.2 sessionInfo",
    "text": "10.2 sessionInfo\n\nsessionInfo()\n\nR version 4.4.1 (2024-06-14)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Sonoma 14.4.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Australia/Sydney\ntzcode source: internal\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] SpatialDatasets_1.4.0       SpatialExperiment_1.16.0   \n [3] ExperimentHub_2.14.0        AnnotationHub_3.14.0       \n [5] BiocFileCache_2.14.0        dbplyr_2.5.0               \n [7] SingleCellExperiment_1.28.1 SummarizedExperiment_1.36.0\n [9] Biobase_2.66.0              GenomicRanges_1.58.0       \n[11] GenomeInfoDb_1.42.0         IRanges_2.40.0             \n[13] S4Vectors_0.44.0            BiocGenerics_0.52.0        \n[15] MatrixGenerics_1.18.0       matrixStats_1.4.1          \n[17] ggplot2_3.5.1               spicyR_1.18.0              \n[19] lisaClust_1.14.4           \n\nloaded via a namespace (and not attached):\n  [1] splines_4.4.1               later_1.4.1                \n  [3] bitops_1.0-9                filelock_1.0.3             \n  [5] svgPanZoom_0.3.4            tibble_3.2.1               \n  [7] polyclip_1.10-7             lifecycle_1.0.4            \n  [9] rstatix_0.7.2               lattice_0.22-6             \n [11] MASS_7.3-61                 MultiAssayExperiment_1.32.0\n [13] backports_1.5.0             magrittr_2.0.3             \n [15] rmarkdown_2.29              yaml_2.3.10                \n [17] httpuv_1.6.15               doRNG_1.8.6.1              \n [19] ClassifyR_3.10.5            sp_2.1-4                   \n [21] dcanr_1.22.0                spatstat.sparse_3.1-0      \n [23] DBI_1.2.3                   minqa_1.2.8                \n [25] RColorBrewer_1.1-3          abind_1.4-8                \n [27] zlibbioc_1.52.0             purrr_1.0.2                \n [29] RCurl_1.98-1.16             tweenr_2.0.3               \n [31] rappdirs_0.3.3              GenomeInfoDbData_1.2.13    \n [33] spatstat.utils_3.1-1        terra_1.7-78               \n [35] pheatmap_1.0.12             goftest_1.2-3              \n [37] simpleSeg_1.8.0             spatstat.random_3.3-2      \n [39] svglite_2.1.3               codetools_0.2-20           \n [41] DelayedArray_0.32.0         ggforce_0.4.2              \n [43] tidyselect_1.2.1            raster_3.6-30              \n [45] UCSC.utils_1.2.0            farver_2.1.2               \n [47] viridis_0.6.5               lme4_1.1-35.5              \n [49] spatstat.explore_3.3-3      jsonlite_1.8.9             \n [51] Formula_1.2-5               survival_3.7-0             \n [53] iterators_1.0.14            systemfonts_1.1.0          \n [55] foreach_1.5.2               tools_4.4.1                \n [57] Rcpp_1.0.13-1               glue_1.8.0                 \n [59] gridExtra_2.3               SparseArray_1.6.0          \n [61] xfun_0.49                   mgcv_1.9-1                 \n [63] ggthemes_5.1.0              EBImage_4.48.0             \n [65] HDF5Array_1.34.0            dplyr_1.1.4                \n [67] shinydashboard_0.7.2        scam_1.2-17                \n [69] withr_3.0.2                 numDeriv_2016.8-1.1        \n [71] BiocManager_1.30.25         fastmap_1.2.0              \n [73] ggh4x_0.2.8                 rhdf5filters_1.18.0        \n [75] boot_1.3-31                 fansi_1.0.6                \n [77] digest_0.6.37               mime_0.12                  \n [79] R6_2.5.1                    colorspace_2.1-1           \n [81] tensor_1.5                  jpeg_0.1-10                \n [83] spatstat.data_3.1-4         RSQLite_2.3.8              \n [85] utf8_1.2.4                  tidyr_1.3.1                \n [87] generics_0.1.3              data.table_1.16.2          \n [89] class_7.3-22                httr_1.4.7                 \n [91] htmlwidgets_1.6.4           S4Arrays_1.6.0             \n [93] pkgconfig_2.0.3             gtable_0.3.6               \n [95] blob_1.2.4                  XVector_0.46.0             \n [97] htmltools_0.5.8.1           carData_3.0-5              \n [99] fftwtools_0.9-11            scales_1.3.0               \n[101] ggupset_0.4.0               png_0.1-8                  \n[103] spatstat.univar_3.1-1       knitr_1.49                 \n[105] rstudioapi_0.17.1           reshape2_1.4.4             \n[107] rjson_0.2.23                nlme_3.1-166               \n[109] curl_6.0.1                  nloptr_2.1.1               \n[111] bdsmatrix_1.3-7             rhdf5_2.50.0               \n[113] cachem_1.1.0                stringr_1.5.1              \n[115] BiocVersion_3.20.0          vipor_0.4.7                \n[117] parallel_4.4.1              concaveman_1.1.0           \n[119] AnnotationDbi_1.68.0        pillar_1.9.0               \n[121] grid_4.4.1                  vctrs_0.6.5                \n[123] coxme_2.2-22                promises_1.3.2             \n[125] ggpubr_0.6.0                car_3.1-3                  \n[127] xtable_1.8-4                beeswarm_0.4.0             \n[129] evaluate_1.0.1              magick_2.8.5               \n[131] cli_3.6.3                   locfit_1.5-9.10            \n[133] compiler_4.4.1              rlang_1.1.4                \n[135] crayon_1.5.3                rngtools_1.5.2             \n[137] ggsignif_0.6.4              labeling_0.4.3             \n[139] ggbeeswarm_0.7.2            plyr_1.8.9                 \n[141] stringi_1.8.4               viridisLite_0.4.2          \n[143] nnls_1.6                    deldir_2.0-4               \n[145] BiocParallel_1.40.0         cytomapper_1.18.0          \n[147] lmerTest_3.1-3              munsell_0.5.1              \n[149] Biostrings_2.74.0           tiff_0.1-12                \n[151] spatstat.geom_3.3-4         V8_6.0.0                   \n[153] Matrix_1.7-1                bit64_4.5.2                \n[155] Rhdf5lib_1.28.0             KEGGREST_1.46.0            \n[157] shiny_1.9.1                 igraph_2.1.1               \n[159] broom_1.0.7                 memoise_2.0.1              \n[161] bit_4.5.0",
    "crumbs": [
      "Spatial domains",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Identifying spatial domains with unsupervised clustering</span>"
    ]
  },
  {
    "objectID": "06-changes_in_marker_expression.html",
    "href": "06-changes_in_marker_expression.html",
    "title": "\n11  Changes in marker expression\n",
    "section": "",
    "text": "11.1 Statial: Marker means\nOne of the easiest things to quantify in terms of markers is a marker mean. For a given image, we assess the total marker mean across all cells within an image, and compare them across disease states. We can do this on an image level, a cell type level, a region level, and a cell type within regions level. For example, if your question is: “How does the expression of CD163 in infiltrating macrophages within the tumour spatial domain differ across my 2 treatment groups?”, you’ll want to look at the marker mean of macrophages within specifically the tumour domain.\nFor this demonstration, we will use our Keren 2018 dataset.\nkerenSPE &lt;- SpatialDatasets::spe_Keren_2018()\n\n# Removing patients without survival data.\nkerenSPE &lt;- kerenSPE[,!is.na(kerenSPE$`Survival_days_capped*`)]\n\n# identify spatial domains with lisaClust\nkerenSPE &lt;- lisaClust(kerenSPE,\n                      k = 5,\n                      BPPARAM = BPPARAM)\nTime for this code chunk to run with 5.5 cores: 24.32 seconds\nkerenSPE$event = 1 - kerenSPE$Censored\nkerenSPE$survival = Surv(kerenSPE$`Survival_days_capped*`, kerenSPE$event)\n# Extracting survival data\nsurvData &lt;- kerenSPE |&gt;\n  colData() |&gt;\n  data.frame() |&gt;\n  select(imageID, survival) |&gt;\n  unique()\n\nkerenSPE$survival &lt;- NULL\n\n# Creating survival vector\nkerenSurv &lt;- survData$survival\nnames(kerenSurv) &lt;- survData$imageID\n\nkerenSurv &lt;- kerenSurv[!is.na(kerenSurv)]\nOur Statial package provides functionality to identify the average marker expression of a given cell type in a given region, using the getMarkerMeans function. Similar to spicyR and lisaClust, these features can also be used for survival analysis.\ncellTypeRegionMeans &lt;- getMarkerMeans(kerenSPE,\n  imageID = \"imageID\",\n  cellType = \"cellType\",\n  region = \"region\")\n\ncellTypeRegionMeans[1:3, 1:3]\n\n   Na__Keratin_Tumour__region_5 Si__Keratin_Tumour__region_5\n1                   -0.76850506                  -0.54544463\n10                  -0.01850892                   0.08525614\n11                  -0.62116507                  -0.41870981\n   P__Keratin_Tumour__region_5\n1                  -1.12173616\n10                 -0.05567915\n11                  0.25139671\nThe output is a dataframe containing the average expression of each marker in each cell type in each region. The column names are formatted as: marker__cell_type__region.\nWe can use the colTest function from spicyR to check whether average marker expression in each cell type in each region is associated with survival probability. colTest requires three arguments: i) df specifies the dataframe containing marker means, ii) condition specifies the outcome of interest, and iii) type specifies the type of test to perform (wilcox, t-test, or survival). In the code below, we’ve specified condition to be our Surv vector and type = survival indicates we are performing survival analysis.\nsurvivalResults &lt;- colTest(df = cellTypeRegionMeans[names(kerenSurv), ], \n                           condition = kerenSurv, \n                           type = \"survival\")\n\nhead(survivalResults)\n\n                                    coef se.coef    pval adjPval\nCD209__CD4_T_cell__region_2         12.0    3.20 0.00016    0.39\nB7H3__CD4_T_cell__region_2         270.0   76.00 0.00038    0.39\nFoxP3__CD4_T_cell__region_2         25.0    7.10 0.00038    0.39\nCD163__CD4_T_cell__region_2         67.0   19.00 0.00038    0.39\nCD8__Endothelial__region_1           7.6    2.20 0.00060    0.40\nKeratin6__Keratin_Tumour__region_1   1.5    0.45 0.00068    0.40\n                                                              cluster\nCD209__CD4_T_cell__region_2               CD209__CD4_T_cell__region_2\nB7H3__CD4_T_cell__region_2                 B7H3__CD4_T_cell__region_2\nFoxP3__CD4_T_cell__region_2               FoxP3__CD4_T_cell__region_2\nCD163__CD4_T_cell__region_2               CD163__CD4_T_cell__region_2\nCD8__Endothelial__region_1                 CD8__Endothelial__region_1\nKeratin6__Keratin_Tumour__region_1 Keratin6__Keratin_Tumour__region_1\nOur most significant relationship appears to be CD209__CD4_T_cell__region_2, which indicates that the expression of marker CD209 in CD4 T cells in region 2 is strongly associated with survival probability. We can examine this relationship in more detail by plotting a Kaplan-Meier curve.\n# Selecting the most significant relationship\nsurvRelationship &lt;- cellTypeRegionMeans[[\"CD209__CD4_T_cell__region_2\"]]\nsurvRelationship &lt;- ifelse(survRelationship &gt; median(survRelationship), \"Higher expression\", \"Lower expression\")\n\n# Plotting Kaplan-Meier curve\nsurvfit2(kerenSurv ~ survRelationship) |&gt;\n  ggsurvfit() +\n  add_pvalue() +\n  ggtitle(\"CD209__CD4_T_cell__region_2\")\nThe positive coefficient associated with CD209__CD4_T_cell__region_2 indicates that higher expression is associated with poorer survival outcomes for patients, which is supported by the Kaplan-Meier curve.\nWe can also look at cell types alone, without separating by region. To do this, we simply do not specify region.\ncellTypeMeans &lt;- getMarkerMeans(kerenSPE,\n  imageID = \"imageID\",\n  cellType = \"cellType\")\n\nsurvivalResults &lt;- colTest(cellTypeMeans[names(kerenSurv), ], kerenSurv, type = \"survival\")\n\nhead(survivalResults)\n\n                          coef se.coef    pval adjPval                  cluster\nCD56__Tregs               15.0    4.20 0.00051    0.41              CD56__Tregs\nHLA_Class_1__Mono_or_Neu  -1.4    0.47 0.00230    0.51 HLA_Class_1__Mono_or_Neu\nFoxP3__Endothelial       120.0   40.00 0.00350    0.51       FoxP3__Endothelial\nCD138__Macrophages         1.1    0.39 0.00490    0.51       CD138__Macrophages\nHLA_Class_1__CD8_T_cell   -1.3    0.48 0.00520    0.51  HLA_Class_1__CD8_T_cell\nCD138__dn_T_CD3            0.4    0.15 0.00570    0.51          CD138__dn_T_CD3\n# Selecting the most significant relationship\nsurvRelationship &lt;- cellTypeMeans[[\"CD56__Tregs\"]]\nsurvRelationship &lt;- ifelse(survRelationship &gt; median(survRelationship), \"Higher expression\", \"Lower expression\")\n\n# Plotting Kaplan-Meier curve\nsurvfit2(kerenSurv ~ survRelationship) |&gt;\n  ggsurvfit() +\n  add_pvalue() +\n  ggtitle(\"CD56__Tregs\")\nThe coefficient associated with CD56__Tregs is positive, which indicates that higher expression is associated with poorer survival outcomes for patients.",
    "crumbs": [
      "Marker expression",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Changes in marker expression</span>"
    ]
  },
  {
    "objectID": "06-changes_in_marker_expression.html#spatiomark-identifying-continuous-changes-in-cell-state",
    "href": "06-changes_in_marker_expression.html#spatiomark-identifying-continuous-changes-in-cell-state",
    "title": "\n11  Changes in marker expression\n",
    "section": "\n11.2 SpatioMark: Identifying continuous changes in cell state",
    "text": "11.2 SpatioMark: Identifying continuous changes in cell state\nAnother approach we can take is to examine contiguous changes in abundance of a gene or protein within a particular cell type. Before, we were comparing changes in abundance across discrete groups or clinical outcomes. By examining contiguous changes in marker expression, we can identify cell-cell interactions that catalyse cell state changes.\nThe approach outlined below measures how marker expression in a cell changes with spatial proximity and abundance with respect to other cell types. The methods utilised here will thereby provide a framework to explore how the dynamic behaviour of cells are altered by the agents they are surrounded by.\n\n\n11.2.1 Continuous cell state changes within a single image\nThe first step in analysing these changes is to calculate the spatial proximity and abundance of each cell to every cell type. getDistances calculates the Euclidean distance from each cell to the nearest cell of each cell type. getAbundances calculates the K-function value for each cell with respect to each cell type. Both metrics are stored in the reducedDims slot of the SpatialExperiment object.\n\n\n# assign spatial coordinates\nkerenSPE$x = spatialCoords(kerenSPE)[, 1]\nkerenSPE$y = spatialCoords(kerenSPE)[, 2]\n\n# calculate distances for a maximum distance of 200\nkerenSPE &lt;- getDistances(kerenSPE,\n  maxDist = 200)\n\n# calculate K-function for a radius of 200\nkerenSPE &lt;- getAbundances(kerenSPE,\n  r = 200,\n  nCores = nCores)\n\nreducedDims(kerenSPE)\n\nList of length 2\nnames(2): distances abundances\n\n\nFirst, let’s examine the same effect observed earlier with Kontextual - the localisation between p53-positive keratin/tumour cells and macrophages in the context of total keratin/tumour cells for image 6 of the Keren 2018 dataset.\nStatial provides two main functions to assess this relationship - calcStateChanges and plotStateChanges. We can use calcStateChanges to examine the relationship between two cell types for one marker in a specific image. In this case, we’re examining the relationship between keratin/tumour cells (from = Keratin_Tumour) and macrophages (to = \"Macrophages\") for the marker p53 (marker = \"p53\") in image = \"6\". We can appreciate that the fdr statistic for this relationship is significant, with a negative t-value, indicating that the expression of p53 in keratin/tumour cells decreases as distance from macrophages increases.\n\nstateChanges &lt;- calcStateChanges(\n  cells = kerenSPE,\n  type = \"distances\",\n  image = \"6\",\n  from = \"Keratin_Tumour\",\n  to = \"Macrophages\",\n  marker = \"p53\",\n  nCores = nCores)\n\nstateChanges\n\n  imageID primaryCellType otherCellType marker         coef      tval\n1       6  Keratin_Tumour   Macrophages    p53 -0.001402178 -7.010113\n          pval          fdr\n1 2.868257e-12 2.868257e-12\n\n\nStatial also provides a convenient function for visualising this interaction - plotStateChanges. Here, again we can specify image = 6 and our main cell types of interest, keratin/tumour cells and macrophages, and our marker p53, in the same format as calcStateChanges.\nThrough this analysis, we can observe that keratin/tumour cells closer to a group of macrophages tend to have higher expression of p53, as observed in the first graph. This relationship is quantified with the second graph, showing an overall decrease of p53 expression in keratin/tumour cells as distance from macrophages increases.\nThese results allow us to essentially arrive at the same result as Kontextual, which calculated a localisation between p53+ keratin/tumour cells and macrophages in the wider context of keratin/tumour cells.\n\np &lt;- plotStateChanges(\n  cells = kerenSPE,\n  type = \"distances\",\n  image = \"6\",\n  from = \"Keratin_Tumour\",\n  to = \"Macrophages\",\n  marker = \"p53\",\n  size = 1,\n  shape = 19,\n  interactive = FALSE,\n  plotModelFit = FALSE,\n  method = \"lm\")\n\n# plot the image\np$image\n\n\n\n\n\n\n\n\n# plot the scatter plot\np$scatter\n\n\n\n\n\n\n\n\n11.2.2 Continuous cell state changes across all images\nBeyond looking at single cell-to-cell interactions for a single image, we can also look at all interactions across all images. The calcStateChanges function provided by Statial can be expanded for this exact purpose - by not specifying cell types, a marker, or an image, calcStateChanges will examine the most significant correlations between distance and marker expression across the entire dataset. Here, we’ve filtered out the most significant interactions to only include those found within image 6 of the Keren et al. dataset.\n\nstateChanges &lt;- calcStateChanges(\n  cells = kerenSPE,\n  type = \"distances\",\n  nCores = nCores,\n  minCells = 100\n)\n\nstateChanges |&gt;\n  filter(imageID == 6) |&gt;\n  head(n = 10)\n\n   imageID primaryCellType otherCellType       marker         coef      tval\n1        6  Keratin_Tumour  Unidentified           Na  0.004218419  25.03039\n2        6  Keratin_Tumour   Macrophages  HLA_Class_1 -0.003823497 -24.69629\n3        6  Keratin_Tumour    CD4_T_cell  HLA_Class_1 -0.003582774 -23.87797\n4        6  Keratin_Tumour  Unidentified Beta.catenin  0.005893120  23.41953\n5        6  Keratin_Tumour    CD8_T_cell  HLA_Class_1 -0.003154544 -23.13804\n6        6  Keratin_Tumour    DC_or_Mono  HLA_Class_1 -0.003353834 -22.98944\n7        6  Keratin_Tumour      dn_T_CD3  HLA_Class_1 -0.003123446 -22.63197\n8        6  Keratin_Tumour        Tumour  HLA_Class_1  0.003684079  21.94265\n9        6  Keratin_Tumour    CD4_T_cell           Fe -0.003457338 -21.43550\n10       6  Keratin_Tumour    CD4_T_cell   phospho.S6 -0.002892457 -20.50767\n            pval           fdr\n1  6.971648e-127 3.361087e-123\n2  7.814253e-124 3.408521e-120\n3  1.745242e-116 5.328836e-113\n4  1.917245e-112 5.488145e-109\n5  5.444541e-110 1.424922e-106\n6  1.053130e-108 2.679645e-105\n7  1.237988e-105 2.870893e-102\n8  8.188258e-100  1.630540e-96\n9   1.287478e-95  2.246354e-92\n10  3.928912e-88  5.712544e-85\n\nTime for this code chunk to run with 5.5 cores: 22.13 seconds\n\nIn image 6, the majority of the top 10 most significant interactions occur between keratin/tumour cells and an immune population, and many of these interactions appear to involve the HLA class I ligand.\nWe can examine some of these interactions further with the plotStateChanges function.\n\np &lt;- plotStateChanges(\n  cells = kerenSPE,\n  type = \"distances\",\n  image = \"6\",\n  from = \"Keratin_Tumour\",\n  to = \"Macrophages\",\n  marker = \"HLA_Class_1\",\n  size = 1,\n  shape = 19,\n  interactive = FALSE,\n  plotModelFit = FALSE,\n  method = \"lm\"\n)\n\n# plot the image\np$image\n\n\n\n\n\n\n\n\n# plot the scatter plot\np$scatter\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 1359 rows containing non-finite outside the scale range\n(`stat_smooth()`).\n\n\nWarning: Removed 1359 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\nThe plot above shows us a clear visual correlation - as the distance from macrophages decreases, keratin/tumour cells increase their expression HLA class I. Biologically, HLA Class I molecules are ligands present on all nucleated cells, responsible for presenting internal cell antigens to the immune system. Their role is to mark abnormal cells for destruction by CD8+ T cells or NK cells, facilitating immune surveillance and response.\nNext, let’s take a look at the top 10 most significant results across all images.\n\nstateChanges |&gt; head(n = 10)\n\n       imageID primaryCellType otherCellType     marker         coef\n69468       37     Endothelial        Tumour       Lag3 -0.001621517\n150351      11     Neutrophils            NK       CD56 -0.059936866\n16402       35      CD4_T_cell        B_cell       CD20 -0.029185750\n16498       35      CD4_T_cell    DC_or_Mono       CD20  0.019125946\n4891        35          B_cell    DC_or_Mono phospho.S6  0.005282065\n16507       35      CD4_T_cell    DC_or_Mono phospho.S6  0.004033218\n4885        35          B_cell    DC_or_Mono     HLA.DR  0.011120703\n5043        35          B_cell  Other_Immune          P  0.011182182\n16354       35      CD4_T_cell      dn_T_CD3       CD20  0.016349492\n4888        35          B_cell    DC_or_Mono     H3K9ac  0.005096632\n                tval          pval           fdr\n69468  -1.082138e+14  0.000000e+00  0.000000e+00\n150351 -1.419485e+14  0.000000e+00  0.000000e+00\n16402  -4.057355e+01 7.019343e-282 4.286502e-277\n16498   4.053436e+01 1.891267e-281 8.662052e-277\n4891    4.041385e+01 5.306590e-278 1.944345e-273\n16507   3.472882e+01 4.519947e-219 1.380098e-214\n4885    3.415344e+01 8.401034e-212 2.198683e-207\n5043    3.414375e+01 1.056403e-211 2.419176e-207\n16354   3.391901e+01 1.219488e-210 2.482349e-206\n4888    3.399856e+01 3.266533e-210 5.984320e-206\n\n\nImmediately, we can appreciate that a couple of these interactions are not biologically plausible. One of the most significant interactions occurs between B cells and CD4 T cells in image 35, where CD4 T cells are found to increase CD20 expression when in close proximity to B cells. Biologically, CD20 is a highly specific marker for B cells, and under healthy circumstances are usually not expressed in T cells.\nCould this potentially be an artefact of calcStateChanges? We can examine the image through the plotStateChanges function, where we indeed observe a strong increase in CD20 expression in T cells nearby B cell populations.\n\np &lt;- plotStateChanges(\n  cells = kerenSPE,\n  type = \"distances\",\n  image = \"35\",\n  from = \"CD4_T_cell\",\n  to = \"B_cell\",\n  marker = \"CD20\",\n  size = 1,\n  shape = 19,\n  interactive = FALSE,\n  plotModelFit = FALSE,\n  method = \"lm\")\n\n# plot the image\np$image\n\n\n\n\n\n\n\n\n# plot the scatter plot\np$scatter\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 26 rows containing missing values or values outside the scale range\n(`geom_smooth()`).\n\n\n\n\n\n\n\n\nSo why are T cells expressing CD20? This brings us to a key problem of cell segmentation - contamination.\n\n11.2.3 Contamination (Lateral marker spill over)\nContamination, or lateral marker spill over, is an issue that results in a cell’s marker expressions being wrongly attributed to another adjacent cell. This issue arises from incorrect segmentation where components of one cell are wrongly determined as belonging to another cell. Alternatively, this issue can arise when antibodies used to tag and measure marker expressions don’t latch on properly to a cell of interest, thereby resulting in residual markers being wrongly assigned as belonging to a cell near the intended target cell. It is important that we either correct or account for this incorrect attribution of markers in our modelling process. This is critical in understanding whether significant cell-cell interactions detected are an artefact of technical measurement errors driven by spill over or are real biological changes that represent a shift in a cell’s state.\nTo circumvent this problem, Statial provides a function that predicts the probability that a cell is any particular cell type - calcContamination. calcContamination returns a dataframe of probabilities demarcating the chance of a cell being any particular cell type. This dataframe is stored under contaminations in the reducedDim slot of the SingleCellExperiment object. It also provides the rfMainCellProb column, which provides the probability that a cell is indeed the cell type it has been designated. For example, for a cell designated as CD8, rfMainCellProb could give a 80% chance that the cell is indeed CD8, due to contamination.\nWe can then introduce these probabilities as covariates into our linear model by setting contamination = TRUE as a parameter in our calcStateChanges function.\n\nkerenSPE &lt;- calcContamination(kerenSPE)\n\nstateChangesCorrected &lt;- calcStateChanges(\n  cells = kerenSPE,\n  type = \"distances\",\n  nCores = 1,\n  minCells = 100,\n  contamination = TRUE\n)\n\nstateChangesCorrected |&gt; head(n = 10)\n\n       imageID primaryCellType otherCellType     marker         coef\n69468       37     Endothelial        Tumour       Lag3 -0.001621517\n150351      11     Neutrophils            NK       CD56 -0.059936866\n16402       35      CD4_T_cell        B_cell       CD20 -0.024761183\n16498       35      CD4_T_cell    DC_or_Mono       CD20  0.015967654\n16507       35      CD4_T_cell    DC_or_Mono phospho.S6  0.003559626\n16354       35      CD4_T_cell      dn_T_CD3       CD20  0.013556323\n88516        3  Keratin_Tumour            DC         Ca -0.013837429\n3697        28          B_cell            NK         Na -0.004478243\n4891        35          B_cell    DC_or_Mono phospho.S6  0.004175050\n16357       35      CD4_T_cell      dn_T_CD3     HLA.DR  0.010239992\n                tval          pval           fdr\n69468  -5.105340e+13  0.000000e+00  0.000000e+00\n150351 -1.421653e+14  0.000000e+00  0.000000e+00\n16402  -3.462418e+01 9.037153e-218 5.518718e-213\n16498   3.368498e+01 4.984871e-208 2.283084e-203\n16507   2.937078e+01 8.017875e-165 2.937765e-160\n16354   2.917098e+01 6.842185e-163 2.089158e-158\n88516  -2.957229e+01 1.895400e-162 4.960560e-158\n3697   -2.932623e+01 2.906760e-160 6.656517e-156\n4891    2.896985e+01 3.337690e-160 6.794091e-156\n16357   2.862558e+01 1.179250e-157 2.160397e-153\n\n\nHowever, this is not a perfect solution for the issue of contamination. As we can see, despite factoring in contamination into our linear model, the correlation between B cell density and CD20 expression in CD4 T cells remains one of the most significant interactions in our model.\nHowever, this does not mean factoring in contamination into our linear model was ineffective.\nWhilst our correction attempts do not rectify every relationship which arises due to contamination, we show that a significant portion of these relationships are rectified. We can show this by plotting a ROC curve of true positives against false positives. In general, cell type specific markers such as CD4 (specific to T helper cells), CD8 (specific to cytotoxic T cells), and CD20 should not change in cells they are not specific to. Therefore, relationships detected to be significant involving these cell type markers are likely false positives and will be treated as such for the purposes of evaluation. Meanwhile, cell state markers are predominantly likely to be true positives.\nPlotting the relationship between false positives and true positives, we’d expect the contamination correction to be greatest in the relationships with the top 100 lowest p values, where we indeed see more true positives than false positives with contamination correction.\n\ncellTypeMarkers &lt;- c(\"CD3\", \"CD4\", \"CD8\", \"CD56\", \"CD11c\", \"CD68\", \"CD45\", \"CD20\")\n\nvalues &lt;- c(\"blue\", \"red\")\nnames(values) &lt;- c(\"None\", \"Corrected\")\n\ndf &lt;- rbind(\n  data.frame(TP = cumsum(stateChanges$marker %in% cellTypeMarkers), \n             FP = cumsum(!stateChanges$marker %in% cellTypeMarkers), type = \"None\"),\n  data.frame(TP = cumsum(stateChangesCorrected$marker %in% cellTypeMarkers), \n             FP = cumsum(!stateChangesCorrected$marker %in% cellTypeMarkers), type = \"Corrected\"))\n\nggplot(df, aes(x = TP, y = FP, colour = type)) +\n  geom_line() +\n  labs(y = \"Cell state marker (FP)\", x = \"Cell type marker (TP)\") +\n  scale_colour_manual(values = values)\n\n\n\n\n\n\n\nBelow, we zoom in on the ROC curve where the top 100 lowest p values occur, where we indeed see more true positives than false positives with contamination correction.\n\nggplot(df, aes(x = TP, y = FP, colour = type)) +\n  geom_line() +\n  xlim(0, 100) +\n  ylim(0, 1000) +\n  labs(y = \"Cell state marker (FP)\", x = \"Cell type marker (TP)\") +\n  scale_colour_manual(values = values)\n\n\n\n\n\n\n\n\n11.2.4 Associate continuous state changes with survival outcomes\nSimiliar to Kontextual, we can run a similar survival analysis using our state change results. Here, prepMatrix extracts the coefficients, or the coef column of stateChanges by default. To use the t-values instead, specify column = \"tval\" in the prepMatrix function. As before, we use colTest to build the CoxPH model.\n\n# Preparing features for Statial\nstateMat &lt;- prepMatrix(stateChanges)\n\n# Ensuring rownames of stateMat match up with rownames of the survival vector\nstateMat &lt;- stateMat[names(kerenSurv), ]\n\n# Remove some very small values\nstateMat &lt;- stateMat[, colMeans(abs(stateMat) &gt; 0.0001) &gt; .8]\n\nsurvivalResults &lt;- colTest(stateMat, kerenSurv, type = \"survival\")\n\nhead(survivalResults)\n\n                                         coef se.coef   pval adjPval\nKeratin_Tumour__Mono_or_Neu__Pan.Keratin -280      89 0.0018    0.63\nMacrophages__Keratin_Tumour__HLA_Class_1  220      75 0.0034    0.63\nKeratin_Tumour__CD8_T_cell__Keratin6     -220      77 0.0036    0.63\nMacrophages__Other_Immune__HLA_Class_1   -480     170 0.0057    0.75\nKeratin_Tumour__Mesenchymal__dsDNA       -810     310 0.0094    0.80\nKeratin_Tumour__Unidentified__H3K27me3    490     190 0.0100    0.80\n                                                                          cluster\nKeratin_Tumour__Mono_or_Neu__Pan.Keratin Keratin_Tumour__Mono_or_Neu__Pan.Keratin\nMacrophages__Keratin_Tumour__HLA_Class_1 Macrophages__Keratin_Tumour__HLA_Class_1\nKeratin_Tumour__CD8_T_cell__Keratin6         Keratin_Tumour__CD8_T_cell__Keratin6\nMacrophages__Other_Immune__HLA_Class_1     Macrophages__Other_Immune__HLA_Class_1\nKeratin_Tumour__Mesenchymal__dsDNA             Keratin_Tumour__Mesenchymal__dsDNA\nKeratin_Tumour__Unidentified__H3K27me3     Keratin_Tumour__Unidentified__H3K27me3\n\nTime for this code chunk to run with 5.5 cores: 0.18 seconds\n\nKeratin_Tumour__Mono_or_Neu__Pan.Keratin is the most significant pairwise relationship which contributes to patient survival. That is, the relationship between pan-keratin expression in keratin/tumour cells and their spatial proximity to monocytes/neutrophils. The negative coefficient associated with this relationship tells us that higher pan-keratin expression in keratin/tumour cells nearby monocyte/neutrophil cell populations leads to better survival outcomes for patients.\n\n# Selecting the most significant relationship\nsurvRelationship &lt;- stateMat[[\"Keratin_Tumour__Mono_or_Neu__Pan.Keratin\"]]\nsurvRelationship &lt;- ifelse(survRelationship &gt; median(survRelationship), \"Higher expression in close cells\", \"Lower expression in close cells\")\n\n# Plotting Kaplan-Meier curve\nsurvfit2(kerenSurv ~ survRelationship) |&gt;\n  ggsurvfit() +\n  add_pvalue() +\n  ggtitle(\"Keratin_Tumour__Mono_or_Neu__Pan.Keratin\")\n\n\n\n\n\n\n\n\nWe conclude the section on spatial quantification metrics here. So far, we have identified 7 metrics to quantify spatial relationships -\n\nCell type proportions (FuseSOM)\nCo-localisation between pairs of cell types using the L-function (spicyR)\nCell type co-localisation with respect to a parent population using Kontextual (Statial)\nRegions of co-localisation, or spatial domains (lisaClust)\nMarker means in each cell type (Statial)\nMarker means in each cell type in each region (Statial)\nProximity-associated changes in marker expression using SpatioMark (Statial)\n\nIn the next section, we will look into how each of these metrics can be used to predict clinical outcomes for patients.",
    "crumbs": [
      "Marker expression",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Changes in marker expression</span>"
    ]
  },
  {
    "objectID": "06-changes_in_marker_expression.html#sessioninfo",
    "href": "06-changes_in_marker_expression.html#sessioninfo",
    "title": "\n11  Changes in marker expression\n",
    "section": "\n11.3 sessionInfo",
    "text": "11.3 sessionInfo\n\nsessionInfo()\n\nR version 4.4.1 (2024-06-14)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Sonoma 14.4.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Australia/Sydney\ntzcode source: internal\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] SpatialDatasets_1.4.0       SpatialExperiment_1.16.0   \n [3] ExperimentHub_2.14.0        AnnotationHub_3.14.0       \n [5] BiocFileCache_2.14.0        dbplyr_2.5.0               \n [7] treekoR_1.14.0              tibble_3.2.1               \n [9] ggsurvfit_1.1.0             ggplot2_3.5.1              \n[11] SingleCellExperiment_1.28.1 dplyr_1.1.4                \n[13] lisaClust_1.14.4            ClassifyR_3.10.5           \n[15] survival_3.7-0              BiocParallel_1.40.0        \n[17] MultiAssayExperiment_1.32.0 SummarizedExperiment_1.36.0\n[19] Biobase_2.66.0              GenomicRanges_1.58.0       \n[21] GenomeInfoDb_1.42.0         IRanges_2.40.0             \n[23] MatrixGenerics_1.18.0       matrixStats_1.4.1          \n[25] S4Vectors_0.44.0            BiocGenerics_0.52.0        \n[27] generics_0.1.3              spicyR_1.18.0              \n[29] Statial_1.8.0              \n\nloaded via a namespace (and not attached):\n  [1] fs_1.6.5                    spatstat.sparse_3.1-0      \n  [3] bitops_1.0-9                EBImage_4.48.0             \n  [5] httr_1.4.7                  hopach_2.66.0              \n  [7] RColorBrewer_1.1-3          doParallel_1.0.17          \n  [9] numDeriv_2016.8-1.1         tools_4.4.1                \n [11] doRNG_1.8.6.1               backports_1.5.0            \n [13] utf8_1.2.4                  R6_2.5.1                   \n [15] HDF5Array_1.34.0            lazyeval_0.2.2             \n [17] mgcv_1.9-1                  rhdf5filters_1.18.0        \n [19] GetoptLong_1.0.5            sp_2.1-4                   \n [21] withr_3.0.2                 gridExtra_2.3              \n [23] coxme_2.2-22                cli_3.6.3                  \n [25] spatstat.explore_3.3-3      sandwich_3.1-1             \n [27] labeling_0.4.3              nnls_1.6                   \n [29] mvtnorm_1.3-2               spatstat.data_3.1-4        \n [31] systemfonts_1.1.0           yulab.utils_0.1.8          \n [33] ggupset_0.4.0               svglite_2.1.3              \n [35] colorRamps_2.3.4            limma_3.62.1               \n [37] RSQLite_2.3.8               flowCore_2.18.0            \n [39] rstudioapi_0.17.1           simpleSeg_1.8.0            \n [41] gridGraphics_0.5-1          shape_1.4.6.1              \n [43] spatstat.random_3.3-2       car_3.1-3                  \n [45] scam_1.2-17                 Matrix_1.7-1               \n [47] RProtoBufLib_2.18.0         ggbeeswarm_0.7.2           \n [49] fansi_1.0.6                 abind_1.4-8                \n [51] terra_1.7-78                lifecycle_1.0.4            \n [53] yaml_2.3.10                 multcomp_1.4-26            \n [55] edgeR_4.4.0                 carData_3.0-5              \n [57] rhdf5_2.50.0                SparseArray_1.6.0          \n [59] Rtsne_0.17                  blob_1.2.4                 \n [61] grid_4.4.1                  promises_1.3.2             \n [63] shinydashboard_0.7.2        crayon_1.5.3               \n [65] bdsmatrix_1.3-7             lattice_0.22-6             \n [67] KEGGREST_1.46.0             magick_2.8.5               \n [69] cytomapper_1.18.0           pillar_1.9.0               \n [71] knitr_1.49                  ComplexHeatmap_2.22.0      \n [73] dcanr_1.22.0                rjson_0.2.23               \n [75] boot_1.3-31                 codetools_0.2-20           \n [77] glue_1.8.0                  ggiraph_0.8.11             \n [79] ggfun_0.1.7                 spatstat.univar_3.1-1      \n [81] data.table_1.16.2           vctrs_0.6.5                \n [83] png_0.1-8                   treeio_1.30.0              \n [85] gtable_0.3.6                cachem_1.1.0               \n [87] xfun_0.49                   mime_0.12                  \n [89] S4Arrays_1.6.0              ConsensusClusterPlus_1.70.0\n [91] pheatmap_1.0.12             iterators_1.0.14           \n [93] cytolib_2.18.0              statmod_1.5.0              \n [95] TH.data_1.1-2               nlme_3.1-166               \n [97] ggtree_3.14.0               bit64_4.5.2                \n [99] filelock_1.0.3              svgPanZoom_0.3.4           \n[101] vipor_0.4.7                 DBI_1.2.3                  \n[103] colorspace_2.1-1            raster_3.6-30              \n[105] tidyselect_1.2.1            curl_6.0.1                 \n[107] bit_4.5.0                   compiler_4.4.1             \n[109] diffcyt_1.26.0              DelayedArray_0.32.0        \n[111] plotly_4.10.4               scales_1.3.0               \n[113] rappdirs_0.3.3              tiff_0.1-12                \n[115] stringr_1.5.1               digest_0.6.37              \n[117] goftest_1.2-3               fftwtools_0.9-11           \n[119] spatstat.utils_3.1-1        minqa_1.2.8                \n[121] rmarkdown_2.29              XVector_0.46.0             \n[123] htmltools_0.5.8.1           pkgconfig_2.0.3            \n[125] jpeg_0.1-10                 lme4_1.1-35.5              \n[127] fastmap_1.2.0               rlang_1.1.4                \n[129] GlobalOptions_0.1.2         htmlwidgets_1.6.4          \n[131] ggthemes_5.1.0              UCSC.utils_1.2.0           \n[133] shiny_1.9.1                 ggh4x_0.2.8                \n[135] farver_2.1.2                zoo_1.8-12                 \n[137] jsonlite_1.8.9              RCurl_1.98-1.16            \n[139] magrittr_2.0.3              Formula_1.2-5              \n[141] GenomeInfoDbData_1.2.13     ggplotify_0.1.2            \n[143] patchwork_1.3.0             Rhdf5lib_1.28.0            \n[145] munsell_0.5.1               Rcpp_1.0.13-1              \n[147] viridis_0.6.5               ape_5.8                    \n[149] ggnewscale_0.5.0            stringi_1.8.4              \n[151] zlibbioc_1.52.0             MASS_7.3-61                \n[153] plyr_1.8.9                  parallel_4.4.1             \n[155] deldir_2.0-4                Biostrings_2.74.0          \n[157] splines_4.4.1               tensor_1.5                 \n[159] circlize_0.4.16             locfit_1.5-9.10            \n[161] igraph_2.1.1                ggpubr_0.6.0               \n[163] uuid_1.2-1                  ranger_0.17.0              \n[165] spatstat.geom_3.3-4         ggsignif_0.6.4             \n[167] rngtools_1.5.2              reshape2_1.4.4             \n[169] BiocVersion_3.20.0          XML_3.99-0.17              \n[171] evaluate_1.0.1              BiocManager_1.30.25        \n[173] nloptr_2.1.1                foreach_1.5.2              \n[175] tweenr_2.0.3                httpuv_1.6.15              \n[177] tidyr_1.3.1                 purrr_1.0.2                \n[179] polyclip_1.10-7             clue_0.3-66                \n[181] ggforce_0.4.2               xtable_1.8-4               \n[183] broom_1.0.7                 tidytree_0.4.6             \n[185] rstatix_0.7.2               later_1.4.1                \n[187] viridisLite_0.4.2           class_7.3-22               \n[189] lmerTest_3.1-3              aplot_0.2.3                \n[191] AnnotationDbi_1.68.0        memoise_2.0.1              \n[193] beeswarm_0.4.0              FlowSOM_2.14.0             \n[195] cluster_2.1.6               concaveman_1.1.0",
    "crumbs": [
      "Marker expression",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Changes in marker expression</span>"
    ]
  },
  {
    "objectID": "07-classification.html",
    "href": "07-classification.html",
    "title": "\n12  Finding associations between clinical variables and spatial features\n",
    "section": "",
    "text": "12.1 Introduction to ClassifyR\nClassifyR provides a structured pipeline for cross-validated classification. Classification is viewed in terms of four stages: data transformation, feature selection, classifier training, and prediction. The driver functions crossValidate and runTests implements varieties of cross-validation. They are:\nWe will use the Keren 2018 dataset to perform two predictions: 1) predict the patient’s tumour type (compartmentalised or mixed) and 2) predict the patient’s survival outcome.\n# load the Keren 2018 dataset\nkerenSPE &lt;- SpatialDatasets::spe_Keren_2018()\n\n# remove any missing data in our outcome columns\nkerenSPE = kerenSPE[, complete.cases(colData(kerenSPE)[, c(\"Censored\", \"Survival_days_capped*\",\n                                                           \"tumour_type\")])]\n# load pre-computed data for efficiency\nkontextMat &lt;- readRDS(\"data/kontextMat.rds\")\nstateMat &lt;- readRDS(\"data/stateMat.rds\")",
    "crumbs": [
      "Classification",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Finding associations between clinical variables and spatial features</span>"
    ]
  },
  {
    "objectID": "07-classification.html#introduction-to-classifyr",
    "href": "07-classification.html#introduction-to-classifyr",
    "title": "\n12  Finding associations between clinical variables and spatial features\n",
    "section": "",
    "text": "Permutation of the order of samples followed by k-fold cross-validation\nRepeated \\(x\\%\\) test set cross-validation\nleave-k-out cross-validation",
    "crumbs": [
      "Classification",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Finding associations between clinical variables and spatial features</span>"
    ]
  },
  {
    "objectID": "07-classification.html#classification-of-patients-by-condition",
    "href": "07-classification.html#classification-of-patients-by-condition",
    "title": "\n12  Finding associations between clinical variables and spatial features\n",
    "section": "\n12.2 Classification of patients by condition",
    "text": "12.2 Classification of patients by condition\nWe will use the Keren 2018 dataset to classify a patient’s tumour into one of two types: compartmentalised and mixed. First, we will filter out all cases which had cold tumours.\n\n# filter out cold tumours\nkerenSPE = kerenSPE[, colData(kerenSPE)$tumour_type != \"cold\"]\nkerenSPE$tumour_type = droplevels(kerenSPE$tumour_type)\nlevels(kerenSPE$tumour_type) = c(\"compartmentalised\", \"mixed\")\n\nkontextMat = kontextMat[rownames(kontextMat) %in% unique(kerenSPE$imageID), ]\nstateMat = stateMat[rownames(stateMat) %in% unique(kerenSPE$imageID), ]\n\nWe will build a list of feature matrices using the features we’ve generated in the previous chapters:\n\nCell type proportions (FuseSOM)\nCo-localisation between pairs of cell types using the L-function (spicyR)\nCell type co-localisation with respect to a parent population using Kontextual (Statial)\nRegions of co-localisation, or spatial domains (lisaClust)\nMarker means in each cell type (Statial)\nMarker means in each cell type in each region (Statial)\nProximity-associated changes in marker expression using SpatioMark (Statial)\n\n\ndata &lt;- list()\n\n# Cell type proportions (FuseSOM)\ndata[[\"proportions\"]] &lt;- getProp(kerenSPE, \"cellType\")\n\n# Cell localisation (spicyR)\ndata[[\"spicyR\"]] &lt;- getPairwise(kerenSPE,\n                                BPPARAM = BPPARAM) |&gt; as.data.frame()\n\n# Cell localisation with respect to a parent (Kontextual)\ndata[[\"Kontextual\"]] &lt;- kontextMat\n\n# Spatial Domains (lisaClust)\ndata[[\"lisaClust\"]] &lt;- getProp(lisaClust(kerenSPE, k = 5,\n                                         BPPARAM = BPPARAM), \"region\")\n\nGenerating local L-curves.\n\n# Marker means in each cell type (Statial)\ndata[[\"celltypeMarkerMeans\"]] &lt;- getMarkerMeans(kerenSPE, imageID = \"imageID\",\n                                        cellType = \"cellType\",\n                                        region = \"cellType\")\n\n# Marker means in each cell type in each region (Statial)\ndata[[\"regionMarkerMeans\"]] &lt;- getMarkerMeans(lisaClust(kerenSPE, k = 5,\n                                                        BPPARAM = BPPARAM), \n                                        imageID = \"imageID\",\n                                        cellType = \"cellType\",\n                                        region = \"region\")\n\nGenerating local L-curves.\n\n# Proximity-associated changes in marker expression (SpatioMark)\ndata[[\"SpatioMark\"]] &lt;- stateMat\nTime for this code chunk to run with 5.5 cores: 33.54 seconds\n\nWe will then generate a factor vector of our outcome variable.\n\n# outcome vector\noutcome = kerenSPE$tumour_type[!duplicated(kerenSPE$imageID)]\nnames(outcome) = kerenSPE$imageID[!duplicated(kerenSPE$imageID)]\n\nhead(outcome, 5)\n\n                1                 2                 3                 4 \n            mixed             mixed compartmentalised compartmentalised \n                5 \ncompartmentalised \nLevels: compartmentalised mixed\n\n\nClassifyR provides a convenient function, crossValidate, to build and test models. crossValidate must be supplied with measurements, a simple tabular data container or a list-like structure of such related tabular data on common samples. It can be in the form of a matrix, data.frame, DataFrame, MultiAssayExperiment or a list of data.frames.\ncrossValidate must also be supplied with outcome, which represents the prediction to be made. outcome can be either a factor containing the class labels for each observation, or a character of length 1 that matches a column name in measurements which holds the classes. If a character is provided, crossValidate will automatically remove the classes before training.\nBy default, crossValidate will build and train a random forest. Alternative classifiers can be specified using the classifier argument. To view all available feature selection and classification approaches, use the available function.\n\n# perform 50 repeats of 5-fold cross-validation\ncv = crossValidate(measurements = data,\n                   outcome = outcome,\n                   nFolds = 5,\n                   nRepeats = 50,\n                   nCores = nCores)\nTime for this code chunk to run with 5.5 cores: 25.54 seconds\n\nWe can use performancePlot to visualise performance metrics for all our features. Here, we visualise the AUC for each of the seven feature matrices we tested. Additional performance metrics can be specified in the metric argument.\n\nperformancePlot(\n  cv,\n  metric = \"AUC\",\n  characteristicsList = list(x = \"Assay Name\"),\n  orderingList = list(\"Assay Name\" = c(\"proportions\", \"spicyR\", \"lisaClust\", \"Kontextual\", \"celltypeMarkerMeans\", \"regionMarkerMeans\", \"SpatioMark\"))\n)\n\n\n\n\n\n\n\nFrom the graph, both lisaClust and proportions appear to capture information which is predictive of the tumour type of patients.",
    "crumbs": [
      "Classification",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Finding associations between clinical variables and spatial features</span>"
    ]
  },
  {
    "objectID": "07-classification.html#classification-of-patients-by-survival",
    "href": "07-classification.html#classification-of-patients-by-survival",
    "title": "\n12  Finding associations between clinical variables and spatial features\n",
    "section": "\n12.3 Classification of patients by survival",
    "text": "12.3 Classification of patients by survival\ncrossValidate also has the capacity to test classification performance for a survival outcome. In this case, outcome must be a Surv object of the same length as the number of samples in the feature matrix and should contain information about the time and censoring of the samples. Alternatively, we can specify outcome to be a character of length 2 or 3 that each match a column name in a data frame which holds information about the time and censoring of the samples. The time-to-event columns will automatically be removed before training is done.\nWe will first add a survival column to the kerenSPE object.\n\n# create a Surv object named \"survival\"\nkerenSPE$event = 1 - kerenSPE$Censored\nkerenSPE$survival = Surv(kerenSPE$`Survival_days_capped*`, kerenSPE$event)\n\n# outcome vector\nsurv_outcome = kerenSPE$survival[!duplicated(kerenSPE$imageID)]\nnames(surv_outcome) = kerenSPE$imageID[!duplicated(kerenSPE$imageID)]\n\nsurv_outcome\n\n    1     2     3     4     5     6     7     8     9    10    11    12    13 \n 2612   745 3130+ 2523+ 1683+ 2275+   584   946 3767+ 3822+ 3774+ 4353+  1072 \n   14    16    17    18    20    21    23    27    28    29    31    32    33 \n4145+   530  2842 5063+ 4761+   635    91  3658 3767+  1319  1009 1568+ 1738+ \n   34    35    36    37    39    40    41 \n2832+ 2759+ 3063+ 2853+ 2096+  3573 3355+ \n\n\nWe can then run crossValidate and specify the outcome to be surv_outcome, and use performancePlot to visualise the performance of the cross-validation. Since we are performing survival analysis, we will specify metric = \"C-index\".\n\n# perform 50 repeats of 5-fold cross-validation\nsurv_cv = crossValidate(measurements = data,\n                   outcome = surv_outcome,\n                   nFolds = 5,\n                   nRepeats = 50,\n                   nCores = nCores)\n\nperformancePlot(surv_cv,\n  metric = \"C-index\",\n  characteristicsList = list(x = \"Assay Name\"),\n  orderingList = list(\"Assay Name\" = c(\"proportions\", \"spicyR\", \"lisaClust\", \"Kontextual\", \"celltypeMarkerMeans\", \"regionMarkerMeans\", \"SpatioMark\"))\n)\n\n\n\n\n\n\n\nFrom the graph, we can see that lisaClust appears to capture information that is predictive of survival outcomes comparatively well.",
    "crumbs": [
      "Classification",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Finding associations between clinical variables and spatial features</span>"
    ]
  },
  {
    "objectID": "07-classification.html#easy-and-hard-to-classify-patients",
    "href": "07-classification.html#easy-and-hard-to-classify-patients",
    "title": "\n12  Finding associations between clinical variables and spatial features\n",
    "section": "\n12.4 Easy and hard to classify patients",
    "text": "12.4 Easy and hard to classify patients\nThe samplesMetricMap function allows the visual comparison of sample-wise error rate or accuracy measures from the cross-validation process.\n\n12.4.1 Predicting tumour type\n\nsamplesMetricMap(cv,  \n                 classColours = c(\"#3F48CC\", \"#880015\"),\n                 metricColours = list(c(\"#FFFFFF\", \"#CFD1F2\", \"#9FA3E5\", \"#6F75D8\", \"#3F48CC\"),\n                                      c(\"#FFFFFF\", \"#E1BFC4\", \"#C37F8A\", \"#A53F4F\", \"#880015\")))\n\n\n\n\n\n\n\nTableGrob (2 x 1) \"arrange\": 2 grobs\n  z     cells    name                grob\n1 1 (2-2,1-1) arrange      gtable[layout]\n2 2 (1-1,1-1) arrange text[GRID.text.409]\n\n\nThe benefit of this plot is that it allows the easy identification of samples which are hard to classify and could be explained by considering additional information about them. For example, we can see that patients 36 and 13 in particular were difficult to classify. Overall, both cell type proportions (FuseSOM) and cell type co-localisation (spicyR and Kontextual) performed comparitively well at classifying patients, and compartmentalised tumours were easier to classify compared to mixed tumours.\n\n12.4.2 Predicting survival outcomes\nWe can also use sampleMetricMap to identify samples that were difficult to classify with respect to a survival outcome.\n\nsamplesMetricMap(surv_cv)\n\n\n\n\n\n\n\nTableGrob (2 x 1) \"arrange\": 2 grobs\n  z     cells    name                grob\n1 1 (2-2,1-1) arrange      gtable[layout]\n2 2 (1-1,1-1) arrange text[GRID.text.561]\n\n\nWe can see that there was some difficulty in classying patient 35, and that overall, features showed similar performance across samples. lisaClust shows the overall highest performance, especially for samples 31-20.\n DataFrame(), \n                       outcome, crossValParams, SVMparams)\n```\n:::\n\nThe index of chosen of the parameters, as well as all combinations of parameters and their associated performance metric, are stored for every validation, and can be accessed with the `tunedParameters` function.\n\n::: {.cell}\n\n```{.r .cell-code}\ntunedParameters(SVMresults)[1:5]\n```\n:::\n--&gt;\nIn this way, we can predict clinical outcomes and identify samples that are hard to classify.\nIn subsequent sections, we will demonstrate how the end-to-end workflow can be applied to a single dataset in the form of case studies.",
    "crumbs": [
      "Classification",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Finding associations between clinical variables and spatial features</span>"
    ]
  },
  {
    "objectID": "08-case_study1.html",
    "href": "08-case_study1.html",
    "title": "\n13  Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)\n",
    "section": "",
    "text": "13.1 Read in images\nAs before, we can load the Ferguson 2022 image data from the SpatialDatasets package into a CytoImageList and store them as h5 file-on-disk in a temporary directory. We will also assign the metadata columns of the CytoImageList object using the mcols function.\npathToImages &lt;- SpatialDatasets::Ferguson_Images()\ntmp &lt;- tempfile()\nunzip(pathToImages, exdir = tmp)\n\n# Store images in a CytoImageList on_disk as h5 files to save memory.\nimages &lt;- cytomapper::loadImages(\n  tmp,\n  single_channel = TRUE,\n  on_disk = TRUE,\n  h5FilesPath = HDF5Array::getHDF5DumpDir(),\n  BPPARAM = BPPARAM\n)\n\n# assign metadata columns\nmcols(images) &lt;- S4Vectors::DataFrame(imageID = names(images))\nTime for this code chunk to run with 5.5 cores: 133.92 seconds\nAs we’re reading the image channels directly from the names of the TIFF image, we will first clean them for ease of downstream processing.\nchannelNames(images) &lt;- channelNames(images) |&gt;\n                          # remove preceding letters\n                          sub(pattern = \".*_\", replacement = \"\", x = _) |&gt; \n                          # remove the .ome\n                          sub(pattern = \".ome\", replacement = \"\", x = _)\nSimilarly, the image names will be taken from the folder name containing the individual TIFF images for each channel. These will often also need to be cleaned.\n# cleaning image names to obtain image IDs\nsplit_names &lt;- function(x) {\n  sapply(strsplit(x, \"_\"), `[`, 3)\n}\n\nnames(images) &lt;- names(images) |&gt; split_names()\nmcols(images) &lt;- S4Vectors::DataFrame(imageID = names(images))",
    "crumbs": [
      "Case studies",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)</span>"
    ]
  },
  {
    "objectID": "08-case_study1.html#simpleseg-segment-the-cells-in-the-images",
    "href": "08-case_study1.html#simpleseg-segment-the-cells-in-the-images",
    "title": "\n13  Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)\n",
    "section": "\n13.2 SimpleSeg: Segment the cells in the images",
    "text": "13.2 SimpleSeg: Segment the cells in the images\nOur simpleSeg R package Bioconductor provides a series of functions to generate simple segmentation masks of images. A key strength of the simpleSeg package is that we have included multiple ways to perform some simple segmentation operations and incorporated multiple automatic procedures to optimise some key parameters when these aren’t specified. These functions leverage the functionality of the EBImage package on Bioconductor. For more flexibility when performing your segmentation in R, we recommend learning to use the EBImage package.\n\n13.2.1 Run simpleSeg\nIf your images are stored in a list or CytoImageList they can be segmented with a simple call to simpleSeg. simpleSeg is an R implementation of a simple segmentation technique which traces out the nuclei using a specified channel (by setting nucleus =) and then dilates around the traced nuclei by a specified amount (controlled using discSize). The nucleus can be traced out using either one specified channel, or by using the principal components of all channels most correlated to the specified nuclear channel by setting pca = TRUE.\nIn the example below, we used simpleSeg to trace the nuclei signal in the images based on the HH3 channel, expanding outward from the nucleus by 3 pixels. A more detailed explanation of each of the key parameters is available in the Processing section.\n\n# generate masks\nmasks &lt;- simpleSeg(images,\n                   nucleus = c(\"HH3\"),\n                   cellBody = \"dilate\",\n                   discSize = 3,\n                   sizeSelection = 20,\n                   transform = \"sqrt\",\n                   tissue = c(\"panCK\", \"CD45\", \"HH3\"),\n                   cores = nCores)\nTime for this code chunk to run with 5.5 cores: 38.88 seconds\n\n\n13.2.2 Visualise separation\nWe can then use the display and colorLabels functions from EBImage to examine the performance of the cell segmentation.\n\nEBImage::display(colorLabels(masks[[1]]))\n\n\n\n\n\n\n\n\n13.2.3 Visualise outlines\nThe plotPixels function in cytomapper makes it easy to overlay the mask on top of the nucleus intensity marker to see how well our segmentation process has performed. Here, we can see that the segmentation appears to be performing reasonably. If you see over or under-segmentation of your images, discSize is a key parameter in simpleSeg for optimising the size of the dilation disc after segmenting out the nuclei.\n\nplotPixels(image = images[\"F3\"], \n           mask = masks[\"F3\"],\n           img_id = \"imageID\", \n           colour_by = c(\"HH3\"), \n           display = \"single\",\n           colour = list(HH3 = c(\"black\",\"blue\")),\n           legend = NULL,\n           bcg = list(\n             HH3 = c(1, 1, 2)\n           ))\n\n\n\n\n\n\n\nIf you wish to visualise multiple markers instead of just the HH3 marker and see how the segmentation mask performs, this can also be done. Here, we can see that our segmentation mask has done a good job of capturing the CD31 signal, but perhaps not such a good job of capturing the FXIIIA signal, which often lies outside of our dilated nuclear mask. This could suggest that we might need to increase the discSize of our dilation.\n\nplotPixels(image = images[\"F3\"], \n           mask = masks[\"F3\"],\n           img_id = \"imageID\", \n           colour_by = c(\"HH3\", \"CD31\", \"FX111A\"), \n           display = \"single\",\n           colour = list(HH3 = c(\"black\",\"blue\"),\n                         CD31 = c(\"black\", \"red\"),\n                         FX111A = c(\"black\", \"green\") ),\n           legend = NULL,\n           bcg = list(\n             HH3 = c(1, 1, 2),\n             CD31 = c(0, 1, 2),\n             FX111A = c(0, 1, 1.5)\n           ))\n\n\n\n\n\n\n\nHere, we can see that our segmentation mask has done a good job of capturing the CD31 signal, but perhaps not such a good job of capturing the FXIIIA signal, which often lies outside of our dilated nuclear mask. This could suggest that we might need to increase the discSize of our dilation.",
    "crumbs": [
      "Case studies",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)</span>"
    ]
  },
  {
    "objectID": "08-case_study1.html#summarise-cell-features",
    "href": "08-case_study1.html#summarise-cell-features",
    "title": "\n13  Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)\n",
    "section": "\n13.3 Summarise cell features",
    "text": "13.3 Summarise cell features\nWe can then use the measureObjects function from the cytomapper package to characterise the phenotypes of each of the segmented cells. measureObjects will calculate the average intensity of each channel within each cell as well as a few morphological features. By default, measureObjects will return a SingleCellExperiment object, where the channel intensities are stored in the counts assay and the spatial location of each cell is stored in colData in the m.cx and m.cy columns. We can ask measureObjects to return a SpatialExperiment object instead by specifying return_as = \"spe\", and the spatial coordinates of each cell will be stored in the spatialCoords slot.\n\n# Summarise the expression of each marker in each cell\ncells &lt;- cytomapper::measureObjects(masks,\n                                    images,\n                                    img_id = \"imageID\",\n                                    return_as = \"spe\",\n                                    BPPARAM = BPPARAM)\n\nspatialCoordsNames(cells) &lt;- c(\"x\", \"y\")\nTime for this code chunk to run with 5.5 cores: 335.3 seconds",
    "crumbs": [
      "Case studies",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)</span>"
    ]
  },
  {
    "objectID": "08-case_study1.html#load-the-clinical-data",
    "href": "08-case_study1.html#load-the-clinical-data",
    "title": "\n13  Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)\n",
    "section": "\n13.4 Load the clinical data",
    "text": "13.4 Load the clinical data\nTo associate features in our image with disease progression, it is important to read in information which links image identifiers to their progression status. The clinical data is available through the SpatialDatasets package.\n\nclinical &lt;- SpatialDatasets::fergusonClinical()\n\n# ensure image IDs match\nrownames(clinical) &lt;- clinical$imageID\nclinical &lt;- clinical[names(images), ]\n\n# put the clinical data into the colData slot\ncolData(cells) &lt;- cbind(colData(cells), clinical[cells$imageID, ])\n\nIf needed, the SpatialExperiment object can be stored as an R Data file.\n\nsave(cells, file = \"spe_Ferguson_2022.rda\")\n\nIn case you already have your SpatialExperiment/SingleCellExperiment object, you may only be interested in our downstream workflow. For the sake of convenience, we’ve provided capability to directly load in the SpatialExperiment object that we’ve generated.\n\nload(\"data/cells.rda\")",
    "crumbs": [
      "Case studies",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)</span>"
    ]
  },
  {
    "objectID": "08-case_study1.html#normalise-the-data",
    "href": "08-case_study1.html#normalise-the-data",
    "title": "\n13  Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)\n",
    "section": "\n13.5 Normalise the data",
    "text": "13.5 Normalise the data\nNext, we can check if the marker intensities of each cell require some form of transformation or normalisation. The reason we do this is two-fold:\n\nThe intensities of images are often highly skewed, preventing any meaningful downstream analysis.\nThe intensities across different images are often different, meaning that what is considered “positive” can be different across images.\n\nBy transforming and normalising the data, we aim to reduce these two effects. Below, we extract the marker intensities from the counts assay and take a closer look at the CD3 marker, which should be expressed in the majority of T cells.\n\n# Plot densities of CD3 for each image.\ncells |&gt; \n  join_features(features = rownames(cells), shape = \"wide\", assay = \"counts\") |&gt; \n  ggplot(aes(x = CD3, colour = imageID)) + \n  geom_density() + \n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\nHere, we can see that the intensities are very clearly skewed, and it is difficult to distinguish a CD3- cell from a CD3+ cell. Further, we can clearly see some image-level batch effect, where across images, the intensity peaks differ drastically.\nAnother method of visualising batch effects is using a dimensionality reduction technique and visualising how the images separate out on a 2D plot. If no batch effect is expected, we should see the images largely overlap with each other.\n\n# Usually we specify a subset of the original markers which are informative to separating out distinct cell types for the UMAP and clustering.\nct_markers &lt;- c(\"podoplanin\", \"CD13\", \"CD31\",\n                \"panCK\", \"CD3\", \"CD4\", \"CD8a\",\n                \"CD20\", \"CD68\", \"CD16\", \"CD14\", \"HLADR\", \"CD66a\")\n\n\nset.seed(51773)\n# Perform dimension reduction using UMAP.\ncells &lt;- scater::runUMAP(\n  cells,\n  subset_row = ct_markers,\n  exprs_values = \"counts\"\n)\n\n# Select a subset of images to plot.\nsomeImages &lt;- unique(cells$imageID)[c(1, 5, 10, 20, 30, 40)]\n\n# UMAP by imageID.\nscater::plotReducedDim(\n  cells[, cells$imageID %in% someImages],\n  dimred = \"UMAP\",\n  colour_by = \"imageID\"\n)\n\n\n\n\n\n\n\nThe UMAP also indicates that some level of batch effect exists in our dataset.\nTo mitigate this, we can use the normalizeCells function from simpleSeg. Below, we perform normalisation (specified by method =) by 1) trimming the 99th percentile, 2) dividing by the mean and 3) removing the 1st principal component. This modified data is then stored in the norm assay by default.\n\n# Leave out the nuclei markers from our normalisation process. \nuseMarkers &lt;- rownames(cells)[!rownames(cells) %in% c(\"DNA1\", \"DNA2\", \"HH3\")]\n\n# Transform and normalise the marker expression of each cell type.\ncells &lt;- normalizeCells(cells,\n                        markers = useMarkers,\n                        transformation = NULL,\n                        method = c(\"trim99\", \"mean\", \"PC1\"),\n                        assayIn = \"counts\",\n                        cores = nCores\n)\n\n# Plot densities of CD3 for each image\ncells |&gt; \n  join_features(features = rownames(cells), shape = \"wide\", assay = \"norm\") |&gt; \n  ggplot(aes(x = CD3, colour = imageID)) + \n  geom_density() + \n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\nWe can see that this normalised data appears more bimodal, not perfectly, but likely to a sufficient degree for clustering, as we can at least observe a clear CD3+ peak at 1.00, and a CD3- peak at around 0.3. For more information on available normalisation and transformation methods and a detailed explanation of the parameters, refer to our Quality Control section.\nWe can also appreciate through the UMAP a reduction of the batch effect we initially saw.\n\nset.seed(51773)\n# Perform dimension reduction using UMAP.\ncells &lt;- scater::runUMAP(\n  cells,\n  subset_row = ct_markers,\n  exprs_values = \"norm\",\n  name = \"normUMAP\"\n)\n\nsomeImages &lt;- unique(cells$imageID)[c(1, 5, 10, 20, 30, 40)]\n\n# UMAP by imageID.\nscater::plotReducedDim(\n  cells[, cells$imageID %in% someImages],\n  dimred = \"normUMAP\",\n  colour_by = \"imageID\"\n)",
    "crumbs": [
      "Case studies",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)</span>"
    ]
  },
  {
    "objectID": "08-case_study1.html#fusesom-cluster-cells-into-cell-types",
    "href": "08-case_study1.html#fusesom-cluster-cells-into-cell-types",
    "title": "\n13  Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)\n",
    "section": "\n13.6 FuseSOM: Cluster cells into cell types",
    "text": "13.6 FuseSOM: Cluster cells into cell types\nWe can also appreciate from the UMAP above that there is a division of clusters, most likely representing different cell types. We next aim to empirically distinguish each cluster using our FuseSOM package for clustering. FuseSOM provides a pipeline for the clustering of highly multiplexed in situ imaging cytometry assays. This pipeline uses the Self Organising Map architecture coupled with Multiview hierarchical clustering and provides functions for the estimation of the number of clusters.\nHere, we cluster using the runFuseSOM function. We specify the number of clusters to identify to be numClusters = 10. We also specify a set of cell-type specific markers to use (ct_markers), as we want our clusters to be distinct based off cell type markers, rather than markers which might pick up a transitioning cell state.\n\n# Generate SOM and cluster cells into 10 groups\ncells &lt;- runFuseSOM(\n  cells,\n  markers = ct_markers,\n  assay = \"norm\",\n  numClusters = 10)\n\nWe can also observe how reasonable our choice of k = 10 was, using the estimateNumCluster and optiPlot functions. Here we examine the Gap method, but others, such as Silhouette and Within Cluster Distance are also available. We can see that there are elbow points in the gap statistic at k = 7, k = 10, and k = 11. We’ve specified k = 10, striking a good balance between the number of clusters and the gap statistic. For more discussion on how to select an appropriate value for k, refer to our Unsupervised Clustering section.\n\ncells &lt;- estimateNumCluster(cells, kSeq = 2:30)\noptiPlot(cells, method = \"gap\")\n\n\n\n\n\n\n\n\n13.6.1 Interpreting cluster phenotype\nWe can begin the process of understanding what each of these cell clusters are by using the plotGroupedHeatmap function from scater.\n\n# Visualise marker expression in each cluster.\nscater::plotGroupedHeatmap(\n  cells,\n  features = ct_markers,\n  group = \"clusters\",\n  exprs_values = \"norm\",\n  center = TRUE,\n  scale = TRUE,\n  zlim = c(-3, 3),\n  cluster_rows = FALSE,\n  block = \"clusters\"\n)\n\n\n\n\n\n\n\nAt the least, here we can see we capture all the major immune populations that we expect to see, including the CD4 and CD8 T cells, the CD20+ B cells, the CD68+ myeloid populations, the CD66+ granulocytes, the podoplanin+ epithelial cells, and the panCK+ tumour cells.\nGiven domain-specific knowledge of the tumour-immune landscape, we can go ahead and annotate these clusters as cell types given their expression profiles.\n\ncells &lt;- cells |&gt;\n  mutate(cellType = case_when(\n    clusters == \"cluster_1\" ~ \"GC\", # Granulocytes\n    clusters == \"cluster_2\" ~ \"MC\", # Myeloid cells\n    clusters == \"cluster_3\" ~ \"SC\", # Squamous cells\n    clusters == \"cluster_4\" ~ \"EP\", # Epithelial cells\n    clusters == \"cluster_5\" ~ \"SC\", # Squamous cells (tumour cells)\n    clusters == \"cluster_6\" ~ \"TC_CD4\", # CD4 T cells\n    clusters == \"cluster_7\" ~ \"BC\", # B cells\n    clusters == \"cluster_8\" ~ \"EC\", # Endothelial cells\n    clusters == \"cluster_9\" ~ \"TC_CD8\", # CD8 T cells\n    clusters == \"cluster_10\" ~ \"DC\" # Dendritic cells\n  ))\n\nWe might also be interested in how these cell types are distributed on the images themselves. Here we examine the distribution of clusters on image F3, noting the healthy epithelial and endothelial structures surrounded by tumour cells.\n\nreducedDim(cells, \"spatialCoords\") &lt;- spatialCoords(cells)\n\ncells |&gt; \n  filter(imageID == \"F3\") |&gt; \n  plotReducedDim(\"spatialCoords\", colour_by = \"cellType\")\n\n\n\n\n\n\n\nWe can also use the UMAP we computed earlier to visualise our data in a lower dimension and see how well our annotated cell types cluster out.\n\n# UMAP by cell type\nscater::plotReducedDim(\n  cells[, cells$imageID %in% someImages],\n  dimred = \"normUMAP\",\n  colour_by = \"cellType\"\n)\n\n\n\n\n\n\n\n\n13.6.2 Testing for association between the proportion of each cell type and progressor status\nWe recommend using a package such as diffcyt for testing for changes in abundance of cell types. However, the colTest function from the spicyR package allows us to quickly test for associations between the proportions of the cell types and progression status using either Wilcoxon rank sum tests or t-tests.\n\n# Test for changes in cell type proportion across progression status with student's t-test\ntestProp &lt;- colTest(cells, \n                    condition = \"group\", \n                    feature = \"cellType\",\n                    type = \"ttest\")\n\nhead(testProp)\n\n       mean in group NP mean in group P tval.t   pval adjPval cluster\nTC_CD4           0.0590          0.0330   2.70 0.0092   0.049  TC_CD4\nGC               0.0250          0.0510  -2.80 0.0110   0.049      GC\nTC_CD8           0.1000          0.0840   1.70 0.1000   0.300  TC_CD8\nEP               0.0062          0.0046   1.00 0.3200   0.500      EP\nSC               0.0700          0.0840  -1.00 0.3200   0.500      SC\nDC               0.0340          0.0300   0.99 0.3300   0.500      DC\n\n\nHere, we can see that both CD4 T and granulocytes cells appear to be present in different proportions in non-progressors compared to progressors.\nLet’s examine one of these clusters using our getProp function from the spicyR package, which conveniently transforms our proportions into a feature matrix of images by cell type, enabling convenient downstream classification or analysis.\n\nprop &lt;- getProp(cells, feature = \"cellType\")\nprop[1:5, 1:5]\n\n           BC         DC          EC           EP         GC\nA2 0.04290358 0.01690141 0.003250271 0.0010834236 0.02881907\nA3 0.04834329 0.01991671 0.002715915 0.0005431831 0.01575231\nA4 0.04116013 0.01163598 0.002952414 0.0053838138 0.01823550\nA5 0.09108911 0.04780764 0.017821782 0.0008486563 0.01838755\nA6 0.08572844 0.02824579 0.013875124 0.0019821606 0.01189296\n\n\nNext, let’s visualise how different the proportions are for the most significant cell type (CD4 T cell) across progression statuses using a boxplot.\n\n# Obtain most significant cell type - CD4 T cells\nclusterToUse &lt;- rownames(testProp)[1]\n\nprop |&gt;\n  select(all_of(clusterToUse)) |&gt;\n  tibble::rownames_to_column(\"imageID\") |&gt;\n  left_join(clinical, by = \"imageID\") |&gt;\n  ggplot(aes(x = group, y = .data[[clusterToUse]], fill = group)) +\n  geom_boxplot()\n\n\n\n\n\n\n\nThe boxplot visualisation of CD4 T cell proportion clearly shows that progressors have a lower proportion of CD4 T cells in the tumour core. We can repeat the above for granulocytes as well. In contrast to CD4 T cells, progressors have a higher proportion of granulocytes compared to non-progressors.\n\n# Obtain second most significant cell type - granulocytes\nclusterToUse &lt;- rownames(testProp)[2]\n\nprop |&gt;\n  select(all_of(clusterToUse)) |&gt;\n  tibble::rownames_to_column(\"imageID\") |&gt;\n  left_join(clinical, by = \"imageID\") |&gt;\n  ggplot(aes(x = group, y = .data[[clusterToUse]], fill = group)) +\n  geom_boxplot()\n\n\n\n\n\n\n\nIf you have already clustered and annotated your cells, you may only be interested in our downstream analysis capabilities, looking into identifying localisation (spicyR), cell regions (lisaClust), and cell-cell interactions (SpatioMark & Kontextual). Therefore, for the sake of convenience, we’ve provided capability to directly load in the SpatialExperiment (SPE) object that we’ve generated up to this point, complete with clusters, cell type annotations, and normalised intensities.\n\nload(\"data/computed_cells.rda\")",
    "crumbs": [
      "Case studies",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)</span>"
    ]
  },
  {
    "objectID": "08-case_study1.html#spicyr-test-spatial-relationships",
    "href": "08-case_study1.html#spicyr-test-spatial-relationships",
    "title": "\n13  Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)\n",
    "section": "\n13.7 spicyR: Test spatial relationships",
    "text": "13.7 spicyR: Test spatial relationships\nOur spicyR package offers a range of functions to support the analysis of immunofluorescence, imaging mass cytometry data, and other assays that provide deep phenotyping of individual cells and their spatial distribution. In this example, we use the spicy function to assess changes in spatial relationships between pairwise combinations of cells.\nIn simple terms, spicyR utilises the L-function to evaluate whether cell types are localized or dispersed. The L-function quantifies “closeness” between points, where higher values indicate increased localisation and lower values suggest dispersion.\nHere, we quantify spatial relationships using a combination of 10 radii from 10 to 100 by specifying Rs = 1:10*10 and mildly account for some global tissue structure using sigma = 50. For a more detailed explanation of the key parameters, refer to the Cell Localisation section. Additional information on optimising the parameters can be found in the spicyR paper.\n\nspicyTest &lt;- spicy(cells,\n                   condition = \"group\",\n                   cellTypeCol = \"cellType\",\n                   imageIDCol = \"imageID\",\n                   Rs = 1:10*10,\n                   sigma = 50,\n                   BPPARAM = BPPARAM)\n\ntopPairs(spicyTest, n = 10)\n\n        intercept coefficient    p.value adj.pvalue from to\nGC__MC  2.5225478   -4.772656 0.02970197  0.5084069   GC MC\nEP__BC -1.6808757   11.358866 0.03072870  0.5084069   EP BC\nBC__EP -1.7355224   10.878726 0.04145476  0.5084069   BC EP\nGC__EP  0.4338434  -15.446652 0.04286558  0.5084069   GC EP\nSC__SC 36.2057721  -12.991741 0.05423307  0.5084069   SC SC\nEP__GC  0.2370792  -14.226026 0.06087964  0.5084069   EP GC\nSC__DC -0.7454582    6.168406 0.06162965  0.5084069   SC DC\nMC__GC  2.2961515   -4.183908 0.06210399  0.5084069   MC GC\nDC__SC -0.3706126    6.001380 0.06561924  0.5084069   DC SC\nGC__GC 43.6023084  -15.697248 0.08022246  0.5084069   GC GC\n\n\nThe most significant interaction appears to occur between granulocytes (GC) and myeloid cells (MC) with a p-value of 0.029. We can visualise these relationships using the signifPlot function.\n\n# Visualise which relationships are changing the most.\nsignifPlot(spicyTest)\n\n\n\n\n\n\n\nWe observe that cell type pairs appear to become less attractive (or avoid more) in the progression sample, except for epithelial cells (EP), which appear to become localised. We can also see that granulocytes (GC) and myeloid cells (MC) are more dispersed in progressors compared to non-progressors.\nAs an example, we will use the spicyBoxPlot function to investigate whether the SC tumour cell type localizes with the granulocytes and assess whether this localisation influences tumour progression versus non-progression.\n\nspicyBoxPlot(spicyTest, \n             from = \"SC\", \n             to = \"GC\")\n\n\n\n\n\n\n\nAlternatively, we can look at the most differentially localised relationship between progressors and non-progressors by specifying rank = 1.\n\nspicyBoxPlot(spicyTest, \n             rank = 1)\n\n\n\n\n\n\n\nNow that we have examined cellular localisation relationships, we will move on to identifying spatial domains, or regions of co-localisation.",
    "crumbs": [
      "Case studies",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)</span>"
    ]
  },
  {
    "objectID": "08-case_study1.html#lisaclust-find-cellular-neighbourhoods",
    "href": "08-case_study1.html#lisaclust-find-cellular-neighbourhoods",
    "title": "\n13  Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)\n",
    "section": "\n13.8 lisaClust: Find cellular neighbourhoods",
    "text": "13.8 lisaClust: Find cellular neighbourhoods\nOur lisaClust package on Bioconductor provides a series of functions to identify and visualise regions of tissue where spatial associations between cell types is similar. This package can be used to provide a high-level summary of cell-type co-localisation in multiplexed imaging data that has been segmented at a single-cell resolution. Here we use the lisaClust function to clusters cells into 4 regions with distinct spatial ordering. By default, these identified regions are stored in the regions column in the colData of our SpatialExperiment object.\n\n# Cluster cells into spatial regions with similar composition.\ncells &lt;- lisaClust(\n  cells,\n  k = 4,\n  sigma = 50,\n  cellType = \"cellType\",\n  BPPARAM = BPPARAM)\n\nGenerating local L-curves.\n\n\nFor more information on how to choose an appropriate value for k , refer to the section on Identifying spatial domains.\n\n13.8.1 Region-cell type enrichment heatmap\nWe can try to interpret which spatial orderings the regions are quantifying using the regionMap function. This plots the frequency of each cell type in a region relative to what you would expect by chance.\n\n# Visualise the enrichment of each cell type in each region\nregionMap(cells, cellType = \"cellType\", limit = c(0.2, 2))\n\n\n\n\n\n\n\nWe can see here that our regions have neatly separated according to biological milieu, with region 2 containing our tumour cells and healthy epithelial cells, and regions 1 and 3 containing our immune cell types.\n\n13.8.2 Visualise regions\nWe can quickly examine the spatial arrangement of these regions using plotReducedDim on image F3, where we can see the same division of immune, healthy, and tumour tissue that we identified in our regionMap.\n\ncells |&gt; \n  filter(imageID == \"F3\") |&gt; \n  plotReducedDim(\"spatialCoords\", colour_by = \"region\")\n\n\n\n\n\n\n\nAlthough slower, we have also implemented a function called hatchingPlot that overlays region information using a hatching pattern, allowing it to be viewed alongside cell type classifications. The granularity of the region boundaries can be controlled using the nbp argument.\n\n# Use hatching to visualise regions and cell types.\nhatchingPlot(\n  cells,\n  useImages = \"F3\",\n  cellType = \"cellType\",\n  nbp = 300)\n\nConcave windows are temperamental. Try choosing values of window.length &gt; and &lt; 1 if you have problems.\n\n\n\n\n\n\n\n\n\n13.8.3 Test for association with progression\nSimilar to cell type proportions, we can quickly use the colTest function to test for associations between the proportions of cells in each region and progression status by specifying feature = \"region\".\n\n# Test if the proportion of each region is associated\n# with progression status.\ntestRegion &lt;- colTest(\n  cells,\n  feature = \"region\",\n  condition = \"group\",\n  type = \"ttest\")\n\ntestRegion\n\n         mean in group NP mean in group P tval.t  pval adjPval  cluster\nregion_3            0.260           0.280  -1.90 0.062    0.25 region_3\nregion_1            0.120           0.092   1.10 0.280    0.43 region_1\nregion_2            0.067           0.052   1.00 0.320    0.43 region_2\nregion_4            0.560           0.570  -0.61 0.550    0.55 region_4\n\n\nFrom the results above, it appears that none of the regions above are significantly associated with changes in progression status.",
    "crumbs": [
      "Case studies",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)</span>"
    ]
  },
  {
    "objectID": "08-case_study1.html#statial-identify-changes-in-cell-state",
    "href": "08-case_study1.html#statial-identify-changes-in-cell-state",
    "title": "\n13  Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)\n",
    "section": "\n13.9 Statial: Identify changes in cell state",
    "text": "13.9 Statial: Identify changes in cell state\nOur Statial package provides a suite of functions (Kontextual) for robust quantification of cell type localisation which are invariant to changes in tissue structure. In addition, we provide a suite of functions (SpatioMark) for uncovering continuous changes in marker expression associated with varying levels of localisation.\n\n13.9.1 SpatioMark: Continuous changes in marker expression associated with varying levels of localisation\nThe first step in analysing these changes is to calculate the spatial proximity (getDistances) of each cell to every cell type. These values will then be stored in the reducedDims slot of the SingleCellExperiment object under the names distances. SpatioMark also provides functionality to look into proximal cell abundance using the getAbundance function, which is further explored in the Changes in marker expression section.\n\ncells$m.cx &lt;- spatialCoords(cells)[,\"x\"]\ncells$m.cy &lt;- spatialCoords(cells)[,\"y\"]\n\ncells &lt;- getDistances(cells,\n  maxDist = 200,\n  nCores = nCores,\n  cellType = \"cellType\",\n  spatialCoords = c(\"m.cx\", \"m.cy\"))\n\nWe can then visualise an example image, specified with image = \"F3\" and a particular marker interaction with cell type localisation. To visualise these changes, we specify two cell types with the from and to parameters, and a marker with the marker parameter (cell-cell-marker interactions). Here, we specify the changes in the marker podoplanin in SC tumour cells as its localisation to EP epithelial cells increases or decreases, where we can observe that podoplanin decreases in tumour cells as its distance to the central cluster of epithelial cells increases.\n\np &lt;- plotStateChanges(\n  cells = cells,\n  cellType = \"cellType\",\n  spatialCoords = c(\"m.cx\", \"m.cy\"),\n  type = \"distances\",\n  image = \"F3\",\n  from = \"SC\",\n  to = \"EP\",\n  marker = \"podoplanin\",\n  size = 1,\n  shape = 19,\n  interactive = FALSE,\n  plotModelFit = FALSE,\n  method = \"lm\")\n\n# plot image\np$image\n\n\n\n\n\n\n\n\n# plot the scatter plot\np$scatter\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\nSpatioMark aims to holistically uncover all such significant relationships by looking at all interactions across all images. The calcStateChanges function provided by Statial can be expanded for this exact purpose - by not specifying cell types, a marker, or an image, calcStateChanges will examine the most significant correlations between distance and marker expression across the entire dataset.\n\nstate_dist &lt;- calcStateChanges(\n  cells = cells,\n  cellType = \"cellType\",\n  type = \"distances\",\n  assay = 2,\n  nCores = nCores,\n  minCells = 100)\n\nhead(state_dist, n = 10)\n\n      imageID primaryCellType otherCellType marker          coef      tval\n33985      D2              MC            EP  panCK -0.0014208511 -42.89401\n34018      D2              MC            EP   TIM3 -0.0020978820 -45.18062\n35382      D6              MC            EC   PDL2  0.0022307758  45.52160\n39205      H5              MC            EC  panCK  0.0019813589  40.18073\n30579      B1              MC        TC_CD4  CXCR3 -0.0024987114 -39.88387\n35348      D6              MC            DC  HLADR -0.0012832774 -37.22198\n30580      B1              MC        TC_CD4 pSTAT3 -0.0020861385 -38.38652\n30598      B1              MC        TC_CD4   TIM3 -0.0027262127 -38.34353\n34071      D2              MC            EC  CXCR3  0.0009606071  35.33383\n30592      B1              MC        TC_CD4    CD3 -0.0016079293 -37.20099\n               pval           fdr\n33985  0.000000e+00  0.000000e+00\n34018  0.000000e+00  0.000000e+00\n35382  0.000000e+00  0.000000e+00\n39205 1.710203e-270 3.246136e-266\n30579 3.903858e-266 5.927931e-262\n35348 4.193186e-256 5.306058e-252\n30580 1.025037e-250 1.111785e-246\n30598 2.828398e-250 2.684291e-246\n34071 7.245409e-240 6.112227e-236\n30592 1.327995e-238 1.008267e-234\n\n\nHere, we can see that one of the most significant relationships is between myeloid cells (MC) and epithelial cells (EP) for the marker panCK in image D2. The negative coefficient associated with this relationship tells us that as myeloid cells and epithelial cells become more localised, panCK expression on the myeloid cells decreases.\nWe can confirm this by examining image D2 using the plotStateChanges function.\n\np &lt;- plotStateChanges(\n  cells = cells,\n  cellType = \"cellType\",\n  spatialCoords = c(\"m.cx\", \"m.cy\"),\n  type = \"distances\",\n  image = \"D2\",\n  from = \"MC\",\n  to = \"EP\",\n  marker = \"panCK\",\n  size = 1,\n  shape = 19,\n  interactive = FALSE,\n  plotModelFit = FALSE,\n  method = \"lm\")\n\n# plot image\np$image\n\n\n\n\n\n\n\n\n# plot the scatter plot\np$scatter\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\nThe results from our SpatioMark outputs can be converted from a data.frame to a matrix, using the prepMatrix function. The choice of extracting either the t-statistic or the coefficient of the linear regression can be specified using the column = \"tval\" parameter, with the coefficient being the default extracted parameter. We can see that with SpatioMark, we get some features which are significant after adjusting for FDR.\n\n# Preparing outcome vector\noutcome &lt;- cells$group[!duplicated(cells$imageID)]\nnames(outcome) &lt;- cells$imageID[!duplicated(cells$imageID)]\n\n# Preparing features for Statial\ndistMat &lt;- prepMatrix(state_dist)\n\ndistMat &lt;- distMat[names(outcome), ]\n\n# Remove some very small values\ndistMat &lt;- distMat[, colMeans(abs(distMat) &gt; 0.0001) &gt; .8]\n\n# test for changes in marker expression across outcomes\nresults &lt;- colTest(distMat, outcome, type = \"ttest\")\nhead(results)\n\n                    mean in group NP mean in group P tval.t    pval adjPval\nMC__MC__VISTA               -0.00610        -2.1e-03   -3.8 0.00051    0.16\nMC__MC__CADM1               -0.00580        -2.2e-03   -3.6 0.00110    0.16\nMC__BC__OX40                -0.00043         5.9e-05   -3.6 0.00110    0.16\nMC__BC__VISTA               -0.00085        -2.2e-04   -3.4 0.00170    0.17\nTC_CD8__TC_CD4__CD3         -0.00053        -1.3e-04   -3.3 0.00190    0.17\nMC__MC__NFKBp65             -0.00520        -2.1e-03   -3.2 0.00250    0.18\n                                cluster\nMC__MC__VISTA             MC__MC__VISTA\nMC__MC__CADM1             MC__MC__CADM1\nMC__BC__OX40               MC__BC__OX40\nMC__BC__VISTA             MC__BC__VISTA\nTC_CD8__TC_CD4__CD3 TC_CD8__TC_CD4__CD3\nMC__MC__NFKBp65         MC__MC__NFKBp65\n\n\nWhen we compare changes in marker expression across outcomes, we can see that one of the most significant relationships is MC_BC_OX40 , or the expression of marker OX40 in myeloid cells (MC) and their localisation with B cells (BC). Expression of the marker OX40 in MC is lower in progressors vs non-progressors. OX40 is a co-stimulatory receptor found on activated T cells, primarily CD4+ and CD8+ T cells. It belongs to the tumor necrosis factor receptor (TNFR) superfamily and plays a crucial role in regulating the immune response.\nUnderstanding the spatial relationships of cells within tissue is crucial for interpreting their roles within tissues. However, without defining appropriate contexts, these relationships can be misinterpreted due to confounding factors such as tissue stricture and the choice of region to image. Kontextual provides a framework to generate contexts to measure spatial relationships between cells.\n\n13.9.2 Kontextual: Robust quantification of cell type localisation which is invariant to changes in tissue structure\nKontextual is a method to evaluate the localisation relationship between two cell types in an image. Kontextual builds on the L-function by contextualising the relationship between two cell types in reference to the typical spatial behaviour of a \\(3^{rd}\\) cell type/population. By taking this approach, Kontextual is invariant to changes in the window of the image as well as tissue structures which may be present.\nThe definitions of cell types and cell states are somewhat ambiguous, cell types imply well defined groups of cells that serve different roles from one another, on the other hand cell states imply that cells are a dynamic entity which cannot be discretised, and thus exist in a continuum. For the purposes of using Kontextual we treat cell states as identified clusters of cells, where larger clusters represent a “parent” cell population, and finer sub-clusters representing a “child” cell population. For example a CD4 T cell may be considered a child to a larger parent population of Immune cells. Kontextual thus aims to see how a child population of cells deviate from the spatial behaviour of their parent population, and how that influences the localisation between the child cell state and another cell state.\n\n13.9.2.1 Cell type hierarchy\nA key input for Kontextual is an annotation of cell type hierarchies. We will need these to organise all the cells present into cell state populations or clusters, e.g. all the different B cell types are put in a vector called bcells.\nHere, we use the treekoR package on Bioconductor to define these hierarchies in a data driven way.\n\nexprs &lt;- t(assay(cells, \"norm\")) |&gt; data.frame()\nfergusonTree &lt;- treekoR::getClusterTree(exprs,\n                                        cells$cellType,\n                                        hierarchy_method = \"hopach\",\n                                        scale_exprs = FALSE)\n\nparent1 &lt;- c(\"TC_CD8\", \"TC_CD4\", \"DC\")\nparent2 &lt;- c(\"BC\", \"GC\")\nparent3 &lt;- c(parent1, parent2)\n\nparent4 &lt;- c(\"MC\", \"EP\", \"SC\")\nparent5 &lt;- c(parent4, \"EC\")\n\nall = c(parent1, parent2, parent3, parent4, parent5)\n\ntreeDf = Statial::parentCombinations(all, parent1, parent2, parent3, parent4, parent5)\n\nfergusonTree$clust_tree |&gt; plot()\n\n\n\n\n\n\n\nKontextual accepts a SingleCellExperiment object, a single image, or list of images from a SingleCellExperiment object, which gets passed into the cells argument. Here, we’ve specified Kontextual to perform calculations on all pairwise combinations for every cluster using the parentCombinations function to create the treeDf dataframe which we’ve specified in the parentDf parameter. The argument r will specify the radius which the cell relationship will be evaluated on. Kontextual supports parallel processing, the number of cores can be specified using the cores argument. Kontextual can take a single value or multiple values for each argument and will test all combinations of the arguments specified.\nWe can calculate all pairwise relationships across all images for a single radius.\n\nkontext &lt;- Kontextual(\n  cells = cells,\n  cellType = \"cellType\",\n  spatialCoords = c(\"m.cx\", \"m.cy\"),\n  parentDf = treeDf,\n  r = 50,\n  cores = nCores)\n\nAgain, we can use the same colTest to quickly test for associations between the Kontextual values and survival probability using either Wilcoxon rank sum tests or t-tests. Similar to SpatioMark, we can specify using either the original L-function by specifying column = \"original\" in our prepMatrix function.\n\n# Converting Kontextual result into data matrix\nkontextMat &lt;- prepMatrix(kontext)\n\n# Replace NAs with 0\nkontextMat[is.na(kontextMat)] &lt;- 0\n\nresults &lt;- spicyR::colTest(kontextMat, outcome, type = \"ttest\")\n\nhead(results)\n\n                    mean in group NP mean in group P tval.t    pval adjPval\nMC__TC_CD4__parent3            -1.10             3.4   -3.7 0.00086    0.12\nEP__BC__parent3                -4.90             6.7   -3.3 0.00200    0.13\nEP__BC__parent2                 0.73             9.8   -3.1 0.00500    0.13\nDC__BC__parent3                -4.00             2.3   -2.9 0.00580    0.13\nDC__SC__parent5                 0.24             7.9   -2.9 0.00590    0.13\nMC__TC_CD4__parent1             0.13             3.7   -2.9 0.00600    0.13\n                                cluster\nMC__TC_CD4__parent3 MC__TC_CD4__parent3\nEP__BC__parent3         EP__BC__parent3\nEP__BC__parent2         EP__BC__parent2\nDC__BC__parent3         DC__BC__parent3\nDC__SC__parent5         DC__SC__parent5\nMC__TC_CD4__parent1 MC__TC_CD4__parent1\n\n\nThe most significant relationship is MC__TC_CD4__parent3 . When we compare the mean values for this relationship between progressors and non-progressors, we can see that myeloid cells (MC) and CD4 T cells show increased co-localisation in progressors vs non-progressors with respect to the parent 3 broader population. When we refer to the cell type hierarchy we defined, we can see that parent 3 refers to the parent population of all immune cells.\nNow that we have identified and calculated several features that can be used to measure spatial associations across cell types and regions of localisation, we will see how these metrics can be used to predict clinical outcomes for patients.",
    "crumbs": [
      "Case studies",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)</span>"
    ]
  },
  {
    "objectID": "08-case_study1.html#classifyr-classification",
    "href": "08-case_study1.html#classifyr-classification",
    "title": "\n13  Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)\n",
    "section": "\n13.10 ClassifyR: Classification",
    "text": "13.10 ClassifyR: Classification\nOur ClassifyR package on Bioconductor provides a convenient framework for evaluating classification in R. We provide functionality to easily include four key modelling stages: data transformation, feature selection, classifier training and prediction, into a cross-validation loop. Here we use the crossValidate function to perform 100 repeats of 5-fold cross-validation to evaluate the performance of a random forest applied to five quantifications of our IMC data:\n\nCell type proportions (FuseSOM)\nCell type localisation from spicyR using the L-function\nRegion proportions from lisaClust\nCell type localisation reference to a parent cell type from Kontextual\nCell changes in response to proximal changes from SpatioMark\n\nFor a more thorough explanation of ClassifyR, refer to our Classification section.\n\n# Create list to store data.frames\ndata &lt;- list()\n\n# Add proportions of each cell type in each image\ndata[[\"Proportions\"]] &lt;- getProp(cells, \"cellType\")\n\n# Add pair-wise associations\nspicyMat &lt;- bind(spicyTest)\nspicyMat[is.na(spicyMat)] &lt;- 0\nspicyMat &lt;- spicyMat |&gt;\n  select(!condition) |&gt;\n  tibble::column_to_rownames(\"imageID\")\n\ndata[[\"SpicyR\"]] &lt;- spicyMat\n\n# Add proportions of each region in each image\n# to the list of dataframes.\ndata[[\"LisaClust\"]] &lt;- getProp(cells, \"region\")\n\n\n# Add SpatioMark features\ndata[[\"SpatioMark\"]] &lt;- distMat\n\n# Add Kontextual features\ndata[[\"Kontextual\"]] &lt;- kontextMat\n\n\n# Set seed\nset.seed(51773)\n\n# Perform cross-validation of a random forest model\n# with 100 repeats of 5-fold cross-validation.\ncv &lt;- crossValidate(\n  measurements = data,\n  outcome = outcome,\n  classifier = \"randomForest\",\n  nFolds = 5,\n  nRepeats = 50,\n  nCores = nCores)\n\n\n13.10.1 Visualise cross-validated prediction performance\nHere we use the performancePlot function to assess the AUC from each repeat of the 5-fold cross-validation.\n\n# Calculate AUC for each cross-validation repeat and plot.\nperformancePlot(\n  cv,\n  metric = \"AUC\",\n  characteristicsList = list(x = \"Assay Name\"),\n  orderingList = list(\"Assay Name\" = c(\"Proportions\", \"SpicyR\", \"LisaClust\", \"Kontextual\", \"SpatioMark\"))\n)\n\n\n\n\n\n\n\nBoth lisaClust and Kontextual appear to capture information that is predictive of patient outcome.\nWe can also visualise which features were good at classifying which patients using the sampleMetricMap function from ClassifyR.\n\nsamplesMetricMap(cv)\n\n\n\n\n\n\n\nTableGrob (2 x 1) \"arrange\": 2 grobs\n  z     cells    name                 grob\n1 1 (2-2,1-1) arrange       gtable[layout]\n2 2 (1-1,1-1) arrange text[GRID.text.2163]\n\n\nOverall, it appears that we were more easily able to identify non-progressors compared to progressors, and patients G6 and H2 within the progressor cohort were particularly difficult to classify.\nHere we have used a pipeline of our spatial analysis R packages to demonstrate an easy way to segment, cluster, normalise, quantify and classify high dimensional in situ cytometry data all within R.",
    "crumbs": [
      "Case studies",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)</span>"
    ]
  },
  {
    "objectID": "08-case_study1.html#sessioninfo",
    "href": "08-case_study1.html#sessioninfo",
    "title": "\n13  Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)\n",
    "section": "\n13.11 sessionInfo",
    "text": "13.11 sessionInfo\n\nsessionInfo()\n\nR version 4.4.1 (2024-06-14)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Sonoma 14.4.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Australia/Sydney\ntzcode source: internal\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] SpatialDatasets_1.4.0           ExperimentHub_2.14.0           \n [3] AnnotationHub_3.14.0            BiocFileCache_2.14.0           \n [5] dbplyr_2.5.0                    SpatialExperiment_1.16.0       \n [7] ttservice_0.4.1                 tidyr_1.3.1                    \n [9] tidySingleCellExperiment_1.16.0 Statial_1.8.0                  \n[11] lisaClust_1.14.4                ClassifyR_3.10.5               \n[13] survival_3.7-0                  BiocParallel_1.40.0            \n[15] MultiAssayExperiment_1.32.0     generics_0.1.3                 \n[17] spicyR_1.18.0                   scater_1.34.0                  \n[19] scuttle_1.16.0                  ggpubr_0.6.0                   \n[21] FuseSOM_1.8.0                   simpleSeg_1.8.0                \n[23] ggplot2_3.5.1                   dplyr_1.1.4                    \n[25] cytomapper_1.18.0               SingleCellExperiment_1.28.1    \n[27] SummarizedExperiment_1.36.0     Biobase_2.66.0                 \n[29] GenomicRanges_1.58.0            GenomeInfoDb_1.42.0            \n[31] IRanges_2.40.0                  S4Vectors_0.44.0               \n[33] BiocGenerics_0.52.0             MatrixGenerics_1.18.0          \n[35] matrixStats_1.4.1               EBImage_4.48.0                 \n\nloaded via a namespace (and not attached):\n  [1] tiff_0.1-12                 dcanr_1.22.0               \n  [3] FCPS_1.3.4                  nnet_7.3-19                \n  [5] goftest_1.2-3               Biostrings_2.74.0          \n  [7] HDF5Array_1.34.0            TH.data_1.1-2              \n  [9] vctrs_0.6.5                 spatstat.random_3.3-2      \n [11] shape_1.4.6.1               digest_0.6.37              \n [13] png_0.1-8                   proxy_0.4-27               \n [15] ggrepel_0.9.6               deldir_2.0-4               \n [17] permute_0.9-7               magick_2.8.5               \n [19] MASS_7.3-61                 reshape2_1.4.4             \n [21] httpuv_1.6.15               foreach_1.5.2              \n [23] withr_3.0.2                 ggfun_0.1.7                \n [25] psych_2.4.6.26              xfun_0.49                  \n [27] ellipsis_0.3.2              doRNG_1.8.6.1              \n [29] memoise_2.0.1               ggbeeswarm_0.7.2           \n [31] RProtoBufLib_2.18.0         diptest_0.77-1             \n [33] princurve_2.1.6             systemfonts_1.1.0          \n [35] tidytree_0.4.6              zoo_1.8-12                 \n [37] GlobalOptions_0.1.2         V8_6.0.0                   \n [39] DEoptimR_1.1-3-1            Formula_1.2-5              \n [41] prabclus_2.3-4              KEGGREST_1.46.0            \n [43] promises_1.3.2              httr_1.4.7                 \n [45] rstatix_0.7.2               rhdf5filters_1.18.0        \n [47] fpc_2.2-13                  rhdf5_2.50.0               \n [49] rstudioapi_0.17.1           UCSC.utils_1.2.0           \n [51] concaveman_1.1.0            curl_6.0.1                 \n [53] zlibbioc_1.52.0             ScaledMatrix_1.14.0        \n [55] analogue_0.17-7             polyclip_1.10-7            \n [57] GenomeInfoDbData_1.2.13     SparseArray_1.6.0          \n [59] fftwtools_0.9-11            xtable_1.8-4               \n [61] stringr_1.5.1               doParallel_1.0.17          \n [63] evaluate_1.0.1              S4Arrays_1.6.0             \n [65] irlba_2.3.5.1               colorspace_2.1-1           \n [67] filelock_1.0.3              spatstat.data_3.1-4        \n [69] flexmix_2.3-19              magrittr_2.0.3             \n [71] ggtree_3.14.0               later_1.4.1                \n [73] viridis_0.6.5               modeltools_0.2-23          \n [75] lattice_0.22-6              genefilter_1.88.0          \n [77] spatstat.geom_3.3-4         robustbase_0.99-4-1        \n [79] XML_3.99-0.17               cowplot_1.1.3              \n [81] RcppAnnoy_0.0.22            ggupset_0.4.0              \n [83] class_7.3-22                svgPanZoom_0.3.4           \n [85] pillar_1.9.0                nlme_3.1-166               \n [87] iterators_1.0.14            compiler_4.4.1             \n [89] beachmat_2.22.0             stringi_1.8.4              \n [91] tensor_1.5                  minqa_1.2.8                \n [93] plyr_1.8.9                  treekoR_1.14.0             \n [95] crayon_1.5.3                abind_1.4-8                \n [97] gridGraphics_0.5-1          locfit_1.5-9.10            \n [99] sp_2.1-4                    bit_4.5.0                  \n[101] terra_1.7-78                sandwich_3.1-1             \n[103] multcomp_1.4-26             fastcluster_1.2.6          \n[105] codetools_0.2-20            BiocSingular_1.22.0        \n[107] coop_0.6-3                  GetoptLong_1.0.5           \n[109] plotly_4.10.4               mime_0.12                  \n[111] splines_4.4.1               circlize_0.4.16            \n[113] Rcpp_1.0.13-1               profileModel_0.6.1         \n[115] knitr_1.49                  blob_1.2.4                 \n[117] utf8_1.2.4                  clue_0.3-66                \n[119] BiocVersion_3.20.0          lme4_1.1-35.5              \n[121] fs_1.6.5                    nnls_1.6                   \n[123] ggsignif_0.6.4              ggplotify_0.1.2            \n[125] tibble_3.2.1                Matrix_1.7-1               \n[127] scam_1.2-17                 statmod_1.5.0              \n[129] svglite_2.1.3               tweenr_2.0.3               \n[131] pkgconfig_2.0.3             pheatmap_1.0.12            \n[133] tools_4.4.1                 cachem_1.1.0               \n[135] RSQLite_2.3.8               viridisLite_0.4.2          \n[137] DBI_1.2.3                   numDeriv_2016.8-1.1        \n[139] fastmap_1.2.0               rmarkdown_2.29             \n[141] scales_1.3.0                grid_4.4.1                 \n[143] shinydashboard_0.7.2        broom_1.0.7                \n[145] patchwork_1.3.0             brglm_0.7.2                \n[147] BiocManager_1.30.25         carData_3.0-5              \n[149] farver_2.1.2                mgcv_1.9-1                 \n[151] yaml_2.3.10                 ggthemes_5.1.0             \n[153] cli_3.6.3                   purrr_1.0.2                \n[155] hopach_2.66.0               lifecycle_1.0.4            \n[157] uwot_0.2.2                  mvtnorm_1.3-2              \n[159] kernlab_0.9-33              backports_1.5.0            \n[161] annotate_1.84.0             cytolib_2.18.0             \n[163] gtable_0.3.6                rjson_0.2.23               \n[165] parallel_4.4.1              ape_5.8                    \n[167] limma_3.62.1                edgeR_4.4.0                \n[169] jsonlite_1.8.9              bitops_1.0-9               \n[171] bit64_4.5.2                 Rtsne_0.17                 \n[173] FlowSOM_2.14.0              yulab.utils_0.1.8          \n[175] vegan_2.6-8                 spatstat.utils_3.1-1       \n[177] BiocNeighbors_2.0.0         ranger_0.17.0              \n[179] flowCore_2.18.0             bdsmatrix_1.3-7            \n[181] spatstat.univar_3.1-1       lazyeval_0.2.2             \n[183] ConsensusClusterPlus_1.70.0 shiny_1.9.1                \n[185] htmltools_0.5.8.1           diffcyt_1.26.0             \n[187] rappdirs_0.3.3              glue_1.8.0                 \n[189] XVector_0.46.0              RCurl_1.98-1.16            \n[191] treeio_1.30.0               mclust_6.1.1               \n[193] mnormt_2.1.1                coxme_2.2-22               \n[195] jpeg_0.1-10                 gridExtra_2.3              \n[197] boot_1.3-31                 igraph_2.1.1               \n[199] R6_2.5.1                    ggiraph_0.8.11             \n[201] labeling_0.4.3              ggh4x_0.2.8                \n[203] cluster_2.1.6               rngtools_1.5.2             \n[205] Rhdf5lib_1.28.0             aplot_0.2.3                \n[207] nloptr_2.1.1                DelayedArray_0.32.0        \n[209] tidyselect_1.2.1            vipor_0.4.7                \n[211] ggforce_0.4.2               raster_3.6-30              \n[213] car_3.1-3                   AnnotationDbi_1.68.0       \n[215] rsvd_1.0.5                  munsell_0.5.1              \n[217] DataVisualizations_1.3.2    data.table_1.16.2          \n[219] htmlwidgets_1.6.4           ComplexHeatmap_2.22.0      \n[221] RColorBrewer_1.1-3          rlang_1.1.4                \n[223] spatstat.sparse_3.1-0       spatstat.explore_3.3-3     \n[225] colorRamps_2.3.4            lmerTest_3.1-3             \n[227] uuid_1.2-1                  ggnewscale_0.5.0           \n[229] fansi_1.0.6                 beeswarm_0.4.0",
    "crumbs": [
      "Case studies",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Case Study: Head and Neck Squamous Cell Carcinoma (Ferguson et al., 2022)</span>"
    ]
  }
]